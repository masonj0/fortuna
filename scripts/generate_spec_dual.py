# scripts/generate_spec_dual.py
# A unified, intelligent spec generator by Jules 1221
# This script generates distinct PyInstaller specs for different build modes.

import argparse
import os
import sys
import subprocess
from pathlib import Path

# Fix for UnicodeEncodeError on Windows runners with special characters in logs
if sys.platform == 'win32':
    try:
        # This is the most reliable way to ensure UTF-8 output on Windows
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except TypeError:
        # In some environments (like older Python versions or certain terminals),
        # reconfigure might not be available. We fall back to a less ideal but
        # still helpful method.
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

def generate_spec(mode: str):
    """
    Generates a PyInstaller spec file based on the specified mode ('ui' or 'svc').
    """
    print(f"--- üêç Unified Spec Generator (Mode: {mode}) ---")

    # 1. Determine configuration based on mode
    if mode == 'ui':
        binary_name = 'fortuna-ui-bridge'
        entry_point_name = 'main.py'
        is_console = True  # Electron bridge needs console for stdio
        datas = "[('{frontend_dist.as_posix()}', 'frontend_dist')]"
        hidden_imports = """[
        'uvicorn.logging',
        'uvicorn.loops.auto',
        'uvicorn.protocols.http.auto',
        'win32timezone'
    ]"""
    elif mode == 'svc':
        binary_name = 'fortuna-core-service'
        entry_point_name = 'service_entry.py' # Dedicated Windows Service entry
        is_console = False # Windows Service should be a GUI app
        datas = "[]" # Service does not bundle the UI
        hidden_imports = """[
        'uvicorn.logging',
        'uvicorn.loops.auto',
        'uvicorn.protocols.http.auto',
        'win32timezone',
        'win32serviceutil',
        'win32service',
        'win32event'
    ]"""
    else:
        print(f"‚ùå Invalid mode specified: {mode}. Use 'ui' or 'svc'.")
        sys.exit(1)

    print(f"Binary Name: {binary_name}")
    print(f"Entry Point: {entry_point_name}")

    # 2. Path Validation
    script_dir = Path(__file__).parent.resolve()
    project_root = script_dir.parent.resolve()
    entry_point = project_root / "web_service" / "backend" / entry_point_name
    frontend_dist = project_root / "web_platform" / "frontend" / "out"

    if not entry_point.exists():
        print(f"‚ùå Entry point not found: {entry_point}")
        sys.exit(1)

    # 3. Locate critical DLLs
    python_home = Path(sys.base_prefix)
    dlls_to_bundle = [
        python_home / 'python311.dll',
        python_home / 'vcruntime140.dll'
    ]
    binaries = []
    for dll_path in dlls_to_bundle:
        if dll_path.exists():
            binaries.append((str(dll_path).replace('\\\\', '/'), '.'))
            print(f"‚úÖ Found required DLL: {dll_path}")
        else:
             print(f"‚ö†Ô∏è Could not find optional DLL, skipping: {dll_path}")

    # 4. Define the spec file content
    spec_content = f"""
# -*- mode: python ; coding: utf-8 -*-
# Generated by scripts/generate_spec_dual.py (Mode: {mode})

block_cipher = None

a = Analysis(
    ['{entry_point.as_posix()}'],
    pathex=['{project_root.as_posix()}'],
    binaries={binaries},
    datas={datas},
    hiddenimports={hidden_imports},
    hookspath=[],
    runtime_hooks=[],
    excludes=['python_service'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{binary_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console={is_console},
    icon=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='{binary_name}',
)
"""

    # 5. Write the spec file
    spec_path = project_root / f"{binary_name}.spec"
    print(f"--- Writing spec file to {spec_path} ---")
    with open(spec_path, "w", encoding="utf-8") as f:
        f.write(spec_content)
    print(f"‚úÖ Spec file created.")

    # 6. Run PyInstaller
    print("--- Running PyInstaller build ---")
    cmd = [
        sys.executable,
        "-m", "PyInstaller",
        str(spec_path),
        "--clean",
        "--noconfirm",
        "--log-level", "WARN"
    ]
    print(f"Executing command: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8')
        print("‚úÖ PyInstaller build successful.")
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        print("‚ùå PyInstaller build failed!")
        print("--- STDOUT ---")
        print(e.stdout)
        print("--- STDERR ---")
        print(e.stderr)
        sys.exit(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate a PyInstaller spec file for different build modes.")
    parser.add_argument('--mode', required=True, choices=['ui', 'svc'], help="The build mode: 'ui' for Electron bridge or 'svc' for Windows Service.")
    args = parser.parse_args()
    generate_spec(args.mode)
