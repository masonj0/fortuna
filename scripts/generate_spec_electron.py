# scripts/generate_spec_electron.py
# Infiltrated and rewritten by Jules 1221 based on FORTUNA-MASTER-COMBO-2025-12-21-HOTFIX intelligence.

import os
import sys
import subprocess
from pathlib import Path

# HOTFIX (ENV-005): Force stdout to handle UTF-8 characters for logging in GitHub Actions.
if hasattr(sys.stdout, 'reconfigure'):
    sys.stdout.reconfigure(encoding='utf-8')

def main():
    """
    Generates a production-hardened PyInstaller spec file for the Electron workflows,
    ensures all necessary DLLs and data are bundled, and runs the build.
    This version incorporates hotfixes for Unicode errors and path resolution on Windows.
    """
    print("--- üêç Hardened Electron Spec Generator (Jules 1221 - Hotfix Edition) ---")

    # 1. Path Validation using absolute paths relative to this script's location.
    # This is more robust than relying on CWD or environment variables inside the script.
    try:
        script_dir = Path(__file__).parent.resolve()
        project_root = script_dir.parent.resolve()
        entry_point = project_root / "web_service" / "backend" / "main.py"
        frontend_dist = project_root / "web_platform" / "frontend" / "out"
    except Exception as e:
        print(f"‚ùå Critical error determining paths: {e}")
        sys.exit(1)

    print(f"Project Root: {project_root}")
    print(f"Entry Point: {entry_point}")
    print(f"Frontend Dist: {frontend_dist}")

    if not entry_point.exists():
        print(f"‚ùå Entry point not found: {entry_point}")
        sys.exit(1)
    if not frontend_dist.is_dir():
        print(f"‚ùå Frontend asset directory '{frontend_dist}' not found.")
        sys.exit(1)

    # 2. Locate critical DLLs for bundling (DLL-004)
    python_home = Path(sys.base_prefix)
    dlls_to_bundle = [
        python_home / 'python311.dll',
        python_home / 'vcruntime140.dll'
    ]
    binaries = []
    for dll_path in dlls_to_bundle:
        if dll_path.exists():
            # Normalize path separators for PyInstaller spec file
            binaries.append((str(dll_path).replace('\\\\', '/'), '.'))
            print(f"‚úÖ Found required DLL: {dll_path}")
        else:
            print(f"‚ö†Ô∏è Could not find optional DLL, skipping: {dll_path}")

    # 3. Define the spec file content with normalized forward slashes
    spec_content = f"""
# -*- mode: python ; coding: utf-8 -*-
# Generated by scripts/generate_spec_electron.py (Jules 1221 - Hotfix Edition)

block_cipher = None

a = Analysis(
    ['{entry_point.as_posix()}'],
    pathex=['{project_root.as_posix()}'],
    binaries={binaries},
    datas=[('{frontend_dist.as_posix()}', 'frontend_dist')],
    hiddenimports=[
        'uvicorn.logging',
        'uvicorn.loops.auto',
        'uvicorn.protocols.http.auto',
        'win32timezone',
        'win32serviceutil',
        'win32service',
        'win32event'
    ],
    hookspath=[],
    runtime_hooks=[],
    excludes=['python_service'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='fortuna-backend',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True, # Per hotfix memo, Electron requires a console app.
    icon=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='fortuna-backend',
)
"""

    # 4. Write the spec file to an absolute path
    spec_path = project_root / "fortuna-backend.spec"
    print(f"--- Writing spec file to {spec_path} ---")
    with open(spec_path, "w", encoding="utf-8") as f:
        f.write(spec_content)
    print(f"‚úÖ Spec file created.")

    # 5. Run PyInstaller using absolute path to the spec file
    print("--- Running PyInstaller build ---")
    cmd = [
        sys.executable,
        "-m", "PyInstaller",
        str(spec_path),
        "--clean",
        "--noconfirm",
        "--log-level", "WARN"
    ]
    print(f"Executing command: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8')
        print("‚úÖ PyInstaller build successful.")
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        print("‚ùå PyInstaller build failed!")
        print("--- STDOUT ---")
        print(e.stdout)
        print("--- STDERR ---")
        print(e.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
