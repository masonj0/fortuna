{
    "file_path": "web_platform/frontend/src/components/LiveRaceDashboard.tsx",
    "content": "// web_platform/frontend/src/components/LiveRaceDashboard.tsx\n'use client';\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { RaceFilters } from './RaceFilters';\nimport { RaceCard } from './RaceCard';\nimport { RaceCardSkeleton } from './RaceCardSkeleton';\nimport { EmptyState } from './EmptyState';\nimport { Race, SourceInfo } from '../types/racing';\nimport { useWebSocket } from '../hooks/useWebSocket';\nimport { StatusDetailModal } from './StatusDetailModal';\nimport ManualOverridePanel from './ManualOverridePanel';\nimport { LiveModeToggle } from './LiveModeToggle';\n\n// Type for the API connection status\ntype ConnectionStatus = 'connecting' | 'online' | 'offline';\n\n// Type for the backend process status received from Electron main\ntype BackendState = 'starting' | 'running' | 'error' | 'stopped';\ninterface BackendStatus {\n  state: BackendState;\n  logs: string[];\n}\n\ninterface RaceFilterParams {\n  maxFieldSize: number;\n  minFavoriteOdds: number;\n  minSecondFavoriteOdds: number;\n}\n\nconst BackendErrorPanel = ({ logs, onRestart }: { logs: string[]; onRestart: () => void }) => (\n  <div className=\"bg-slate-800 p-6 rounded-lg border border-red-500/50 text-white\">\n    <h2 className=\"text-2xl font-bold text-red-400 mb-4\">Backend Service Error</h2>\n    <p className=\"text-slate-400 mb-4\">The backend data service failed to start or has crashed. Below are the most recent diagnostic messages.</p>\n    <div className=\"bg-black p-4 rounded-md font-mono text-sm text-slate-300 h-64 overflow-y-auto mb-4\">\n      {logs.map((log, index) => (\n        <p key={index} className=\"whitespace-pre-wrap\">{`> ${log}`}</p>\n      ))}\n    </div>\n    <button\n      onClick={onRestart}\n      className=\"w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n    >\n      Restart Backend Service\n    </button>\n  </div>\n);\n\n\nexport const LiveRaceDashboard = React.memo(() => {\n  const [races, setRaces] = useState<Race[]>([]);\n  const [failedSources, setFailedSources] = useState<SourceInfo[]>([]);\n  const [isInitialLoad, setIsInitialLoad] = useState(true);\n\n  // Separate status for backend process and API connection\n  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('connecting');\n  const [backendStatus, setBackendStatus] = useState<BackendStatus>({ state: 'starting', logs: [] });\n  const [isLiveMode, setIsLiveMode] = useState(false);\n  const [apiKey, setApiKey] = useState<string | null>(null);\n\n  // Get API key on component mount\n  useEffect(() => {\n    const fetchApiKey = async () => {\n      try {\n        const key = window.electronAPI ? await window.electronAPI.getApiKey() : process.env.NEXT_PUBLIC_API_KEY;\n        if (key) {\n          setApiKey(key);\n        } else {\n          console.error('API key could not be retrieved.');\n        }\n      } catch (error) {\n        console.error('Error fetching API key:', error);\n      }\n    };\n    fetchApiKey();\n  }, []);\n\n  const { data: liveData, isConnected: isLiveConnected } = useWebSocket<{ races: Race[], source_info: SourceInfo[] }>(\n    isLiveMode && apiKey ? '/ws/live-updates' : '',\n    { apiKey }\n  );\n\n  // Effect to update state when new live data arrives\n  useEffect(() => {\n    if (isLiveMode && liveData) {\n      console.log('Received live data update:', liveData);\n      setRaces(liveData.races || []);\n      setFailedSources(liveData.source_info?.filter((s: SourceInfo) => s.status === 'FAILED' && s.attemptedUrl) || []);\n      setLastUpdate(new Date());\n      setConnectionStatus('online');\n      setIsInitialLoad(false);\n    }\n  }, [liveData, isLiveMode]);\n\n  const [errorDetails, setErrorDetails] = useState<string | null>(null);\n  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);\n  const [params, setParams] = useState<RaceFilterParams>({\n    maxFieldSize: 10,\n    minFavoriteOdds: 2.5,\n    minSecondFavoriteOdds: 4.0,\n  });\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const fetchQualifiedRaces = useCallback(async () => {\n    // Only fetch if the backend is actually running\n    if (backendStatus.state !== 'running') return;\n\n    setConnectionStatus('connecting');\n    setErrorDetails(null);\n    setFailedSources([]);\n\n    try {\n      const apiKey = window.electronAPI ? await window.electronAPI.getApiKey() : process.env.NEXT_PUBLIC_API_KEY;\n      if (!apiKey) throw new Error('API key not configured or retrieved.');\n\n      const queryParams = new URLSearchParams({\n        max_field_size: params.maxFieldSize.toString(),\n        min_favorite_odds: params.minFavoriteOdds.toString(),\n        min_second_favorite_odds: params.minSecondFavoriteOdds.toString(),\n      });\n\n      const response = await fetch(`/api/races/qualified/trifecta?${queryParams.toString()}`, {\n        headers: { 'X-API-Key': apiKey, 'Content-Type': 'application/json' },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || `API request failed with status ${response.status}`);\n      }\n\n      const data = await response.json();\n      setRaces(data.races || []);\n      setFailedSources(data.source_info?.filter((s: SourceInfo) => s.status === 'FAILED' && s.attemptedUrl) || []);\n      setLastUpdate(new Date());\n      setConnectionStatus('online');\n    } catch (err: any) {\n      setErrorDetails(err.message || 'An unknown API error occurred.');\n      setConnectionStatus('offline');\n      console.error('Failed to fetch qualified races:', err);\n    } finally {\n      setIsInitialLoad(false);\n    }\n  }, [params, backendStatus.state]);\n\n  // Effect for setting up Electron IPC listener and fetching initial status\n  useEffect(() => {\n    console.log('[LiveRaceDashboard] Component did mount.');\n    // Flag to prevent updates after unmount\n    let isMounted = true;\n\n    // Function to get the initial status\n    const getInitialStatus = async () => {\n      if (window.electronAPI?.getBackendStatus) {\n        console.log('[LiveRaceDashboard] electronAPI is available. Requesting initial status.');\n        try {\n          const initialStatus = await window.electronAPI.getBackendStatus();\n          console.log('[LiveRaceDashboard] Received initial status:', initialStatus);\n          if (isMounted) {\n            setBackendStatus(initialStatus);\n            // If the backend is already running, fetch races immediately.\n            if (initialStatus.state === 'running') {\n              console.log('[LiveRaceDashboard] Initial state is \"running\", fetching races.');\n              fetchQualifiedRaces();\n            }\n          }\n        } catch (error) {\n          console.error(\"[LiveRaceDashboard] Failed to get initial backend status:\", error);\n          if (isMounted) {\n            setBackendStatus({ state: 'error', logs: ['Failed to query backend status from main process.'] });\n          }\n        }\n      } else {\n        console.warn('[LiveRaceDashboard] electronAPI is not available. Forcing error state for verification.');\n        if (isMounted) {\n            setBackendStatus({ state: 'error', logs: ['In a web-only environment, backend is unavailable. This is a simulated error for component verification.'] });\n        }\n      }\n    };\n\n    // Set up the listener for ongoing status updates\n    if (window.electronAPI?.onBackendStatusUpdate) {\n      const unsubscribe = window.electronAPI.onBackendStatusUpdate((status: BackendStatus) => {\n        if (isMounted) {\n          setBackendStatus(status);\n        }\n      });\n\n      // Get the initial state right after setting up the listener\n      getInitialStatus();\n\n      // Cleanup: remove the listener when the component unmounts\n      return () => {\n        isMounted = false;\n        if (typeof unsubscribe === 'function') {\n          unsubscribe();\n        }\n      };\n    } else {\n        // If there's no electron API, maybe we are in a web-only environment.\n        // Let's assume the backend is running and try to fetch.\n        fetchQualifiedRaces();\n    }\n  }, [fetchQualifiedRaces]); // Removed isInitialLoad, as this effect should manage its own logic.\n\n  // Effect for periodic data refresh\n  useEffect(() => {\n    if (isLiveMode) {\n      return; // Don't poll when in live mode\n    }\n    const interval = setInterval(() => {\n      if (backendStatus.state === 'running' && connectionStatus === 'online') {\n        fetchQualifiedRaces();\n      }\n    }, 30000); // 30-second refresh\n    return () => clearInterval(interval);\n  }, [backendStatus.state, connectionStatus, fetchQualifiedRaces, isLiveMode]);\n\n\n  const handleParamsChange = useCallback((newParams: RaceFilterParams) => {\n    setParams(newParams);\n  }, []);\n\n  const renderContent = () => {\n    // Priority 1: Backend process has failed.\n    if (backendStatus.state === 'error') {\n      return <BackendErrorPanel logs={backendStatus.logs} onRestart={() => window.electronAPI.restartBackend()} />;\n    }\n\n    // Priority 2: Handle loading states (initial load, backend starting, or API connecting)\n    if (isInitialLoad || backendStatus.state === 'starting' || connectionStatus === 'connecting') {\n      return (\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n          <RaceCardSkeleton /><RaceCardSkeleton /><RaceCardSkeleton /><RaceCardSkeleton />\n        </div>\n      );\n    }\n\n    // Priority 3: API connection is offline, but backend is running.\n    if (connectionStatus === 'offline') {\n      return <EmptyState\n          title=\"API Connection Offline\"\n          message={errorDetails || \"The backend service is running, but the dashboard could not connect to its API.\"}\n          actionButton={<button onClick={fetchQualifiedRaces} className=\"mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\">Retry Connection</button>}\n      />;\n    }\n\n    // Priority 4: Online but no races match criteria.\n    if (races.length === 0) {\n      return failedSources.length > 0\n        ? <EmptyState title=\"Incomplete Results\" message=\"Some data sources failed. No races matched your filters from the sources that responded.\" />\n        : <EmptyState title=\"No Races Found\" message=\"All data sources responded, but no races matched your current filters.\" />;\n    }\n\n    // Default: Show the race cards.\n    return (\n      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n        {races.map((race) => <RaceCard key={race.id} race={race} />)}\n      </div>\n    );\n  };\n\n  const getStatusIndicator = () => {\n    if (backendStatus.state === 'error') {\n      return { color: 'bg-red-500', text: 'Backend Error' };\n    }\n    if (backendStatus.state === 'starting') {\n      return { color: 'bg-yellow-500', text: 'Backend Starting...' };\n    }\n    if (isLiveMode) {\n      return isLiveConnected\n        ? { color: 'bg-cyan-500', text: 'Live' }\n        : { color: 'bg-yellow-500', text: 'Live Connecting...' };\n    }\n    switch (connectionStatus) {\n      case 'online': return { color: 'bg-green-500', text: 'Online' };\n      case 'offline': return { color: 'bg-orange-500', text: 'API Offline' };\n      default: return { color: 'bg-yellow-500', text: 'Connecting...' };\n    }\n  };\n\n  const { color: statusColor, text: statusText } = getStatusIndicator();\n\n  return (\n    <>\n      <div className=\"space-y-6\">\n        <div className=\"flex justify-between items-start\">\n            <div className=\"text-left space-y-2\">\n                <h1 className=\"text-4xl font-bold text-white\">\ud83c\udfc7 Fortuna Faucet</h1>\n                <p className=\"text-slate-400\">\n                Last updated: {lastUpdate ? lastUpdate.toLocaleTimeString() : 'N/A'}\n                </p>\n            </div>\n            <div className=\"flex items-center gap-4\">\n                <button\n                    onClick={() => (connectionStatus === 'offline' || backendStatus.state === 'error') && setIsModalOpen(true)}\n                    className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium text-white ${statusColor} ${(connectionStatus === 'offline' || backendStatus.state === 'error') ? 'cursor-pointer hover:opacity-80' : 'cursor-default'}`}\n                >\n                    <span className={`w-2.5 h-2.5 rounded-full bg-white ${connectionStatus === 'online' ? 'animate-pulse' : ''}`}></span>\n                    {statusText}\n                </button>\n                <LiveModeToggle\n                  isLive={isLiveMode}\n                  onToggle={setIsLiveMode}\n                  isDisabled={backendStatus.state !== 'running' || connectionStatus === 'offline'}\n                />\n                <button\n                    onClick={fetchQualifiedRaces}\n                    disabled={isLiveMode || connectionStatus === 'connecting' || backendStatus.state !== 'running'}\n                    className=\"px-4 py-2 bg-slate-700 text-white rounded hover:bg-slate-600 disabled:bg-slate-800 disabled:text-slate-500\"\n                >\n                    Refresh\n                </button>\n            </div>\n        </div>\n\n        <RaceFilters onParamsChange={handleParamsChange} isLoading={connectionStatus === 'connecting'} />\n\n        {failedSources.map(source => (\n          <ManualOverridePanel\n            key={source.name}\n            adapterName={source.name}\n            attemptedUrl={source.attemptedUrl || 'URL not available'}\n          />\n        ))}\n\n        {renderContent()}\n      </div>\n\n      <StatusDetailModal\n        isOpen={isModalOpen}\n        onClose={() => setIsModalOpen(false)}\n        status={{ title: 'Connection Error', details: errorDetails || 'No specific error message was provided.' }}\n      />\n    </>\n  );\n});\n"
}