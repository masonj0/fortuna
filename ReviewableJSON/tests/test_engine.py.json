{
    "file_path": "tests/test_engine.py",
    "content": "# tests/test_engine.py\n\nfrom datetime import date\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom unittest.mock import AsyncMock\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\n\nimport fakeredis\nimport httpx\nimport pytest\nfrom python_service.adapters.base_adapter_v3 import BaseAdapterV3\nfrom tenacity import RetryError\n\nfrom python_service.core.exceptions import AdapterHttpError\nfrom python_service.engine import OddsEngine\nfrom python_service.models import Race\nfrom tests.conftest import get_test_settings\nfrom tests.utils import create_mock_race\n\n\n@pytest.mark.asyncio\nasync def test_engine_initialization():\n    \"\"\"\n    SPEC: The OddsEngine should initialize without errors and load adapters correctly.\n    \"\"\"\n    engine = OddsEngine(config=get_test_settings())\n    assert len(engine.adapters) > 0, \"Adapters should be loaded\"\n    assert \"betfair_adapter\" in [a.source_name for a in engine.adapters], \"Betfair adapter should be loaded\"\n\n\n@pytest.mark.asyncio\nasync def test_fetch_all_odds_success():\n    \"\"\"\n    SPEC: The OddsEngine should fetch data from all adapters and aggregate the results.\n    \"\"\"\n    engine = OddsEngine(config=get_test_settings())\n    mock_adapter = AsyncMock(spec=BaseAdapterV3)\n    mock_adapter.source_name = \"MockAdapter\"\n    mock_adapter.get_races.return_value = [create_mock_race(\"MockSource\", \"Race 1\", 1, datetime.now(), [])]\n    engine.adapters = [mock_adapter]\n\n    today_str = date.today().strftime(\"%Y-%m-%d\")\n    result = await engine.fetch_all_odds(today_str)\n\n    assert \"races\" in result\n    assert \"sources\" in result\n    assert len(result[\"races\"]) == 1\n    assert result[\"races\"][0][\"trackName\"] == \"Race 1\"\n\n\n@pytest.mark.asyncio\nasync def test_fetch_all_odds_resilience():\n    \"\"\"\n    SPEC: The OddsEngine should be resilient to individual adapter failures.\n          If one adapter fails, the engine should still return data from the others.\n    \"\"\"\n    # ARRANGE\n    engine = OddsEngine(config=get_test_settings())\n    successful_adapter = AsyncMock(spec=BaseAdapterV3)\n    successful_adapter.source_name = \"SuccessAdapter\"\n    successful_adapter.get_races.return_value = [\n        create_mock_race(\"SuccessSource\", \"Success Race\", 1, datetime.now(), runners=[])\n    ]\n\n    failing_adapter = AsyncMock(spec=BaseAdapterV3)\n    failing_adapter.source_name = \"FailAdapter\"\n    failing_adapter.get_races.side_effect = AdapterHttpError(\"Mock HTTP Error\", 500)\n\n    engine.adapters = [successful_adapter, failing_adapter]\n    today_str = date.today().strftime(\"%Y-%m-%d\")\n\n    # ACT\n    result = await engine.fetch_all_odds(today_str)\n\n    # ASSERT\n    assert \"races\" in result\n    assert \"sources\" in result\n    assert len(result[\"races\"]) == 1, \"Should return data from the successful adapter\"\n    assert result[\"races\"][0][\"source\"] == \"SuccessSource\"\n\n    # Check that the failed adapter's status is correctly recorded\n    adapter_statuses = engine.get_all_adapter_statuses()\n    failed_adapter_status = next((s for s in adapter_statuses if s[\"source_name\"] == \"FailAdapter\"), None)\n    assert failed_adapter_status is not None, \"Failed adapter status should be present\"\n    assert \"Mock HTTP Error\" in failed_adapter_status[\"error\"], \"Error message should be recorded\"\n\n\n@pytest.mark.asyncio\nasync def test_race_aggregation_and_deduplication():\n    \"\"\"\n    SPEC: The OddsEngine should correctly aggregate and deduplicate races from\n          multiple sources based on a unique race identifier (track, time, race number).\n    \"\"\"\n    # ARRANGE\n    engine = OddsEngine(config=get_test_settings())\n    now = datetime.now()\n\n    # Create two identical races from different sources\n    race1_source1 = create_mock_race(\"Source1\", \"Pimlico\", 1, now, [{\"number\": 1, \"name\": \"Runner A\", \"odds\": \"2.5\"}])\n    race1_source2 = create_mock_race(\"Source2\", \"Pimlico\", 1, now, [{\"number\": 1, \"name\": \"Runner A\", \"odds\": \"2.8\"}])\n\n    # Create a unique race\n    unique_race = create_mock_race(\"Source1\", \"Belmont\", 2, now, [{\"number\": 2, \"name\": \"Runner B\", \"odds\": \"5.0\"}])\n\n    adapter1 = AsyncMock(spec=BaseAdapterV3)\n    adapter1.source_name = \"Source1\"\n    adapter1.get_races.return_value = [race1_source1, unique_race]\n\n    adapter2 = AsyncMock(spec=BaseAdapterV3)\n    adapter2.source_name = \"Source2\"\n    adapter2.get_races.return_value = [race1_source2]\n\n    engine.adapters = [adapter1, adapter2]\n    today_str = date.today().strftime(\"%Y-%m-%d\")\n\n    # ACT\n    result = await engine.fetch_all_odds(today_str)\n\n    # ASSERT\n    assert len(result[\"races\"]) == 2, \"Should have two unique races after deduplication\"\n\n    # Find the aggregated race for Pimlico\n    pimlico_race_data = next((r for r in result[\"races\"] if r[\"trackName\"] == \"Pimlico\"), None)\n    assert pimlico_race_data is not None, \"Pimlico race should be in the result\"\n\n    # Convert to Pydantic model for easier validation\n    pimlico_race = Race(**pimlico_race_data)\n\n    # Check runner odds aggregation\n    runner = pimlico_race.runners[0]\n    assert len(runner.odds) == 2, \"Runner odds should be aggregated from two sources\"\n    assert runner.odds[\"Source1\"].win == Decimal(\"2.5\")\n    assert runner.odds[\"Source2\"].win == Decimal(\"2.8\")\n\n    # Check that the race's `sources` list is correct\n    assert \"Source1\" in pimlico_race.sources\n    assert \"Source2\" in pimlico_race.sources\n\n\n@pytest.mark.asyncio\nasync def test_engine_caching_logic():\n    \"\"\"\n    SPEC: The OddsEngine should cache results in Redis.\n    1. On a cache miss, it should fetch from adapters and set the cache.\n    2. On a cache hit, it should return data from the cache without fetching from adapters.\n    \"\"\"\n    # ARRANGE\n    # Use the asynchronous FakeRedis for the asynchronous CacheManager\n    with patch(\"redis.from_url\", fakeredis.aioredis.FakeRedis.from_url):\n        import redis.asyncio as redis\n\n        from python_service.cache_manager import cache_manager\n\n        # Re-initialize the client on the singleton to use the patched async version\n        cache_manager.redis_client = redis.from_url(\"redis://fake\", decode_responses=True)\n        assert cache_manager.redis_client is not None, \"Failed to patch redis_client\"\n\n        engine = OddsEngine(config=get_test_settings())\n\n        today_str = date.today().strftime(\"%Y-%m-%d\")\n        test_time = datetime(2025, 10, 9, 15, 0)\n        mock_race = create_mock_race(\n            \"TestSource\",\n            \"Cache Park\",\n            1,\n            test_time,\n            [{\"number\": 1, \"name\": \"Cachedy\", \"odds\": \"4.0\"}],\n        )\n\n        mock_adapter = AsyncMock(spec=BaseAdapterV3)\n        mock_adapter.source_name = \"TestSource\"\n        engine.adapters = [mock_adapter]  # Isolate to one mock adapter\n\n        await cache_manager.redis_client.flushdb()\n\n        # --- 1. Cache Miss ---\n        # ARRANGE\n        mock_adapter.get_races.return_value = [mock_race]\n        mock_adapter.get_races.reset_mock()  # Reset call count\n\n        # ACT\n        result_miss = await engine.fetch_all_odds(today_str)\n\n        # ASSERT\n        mock_adapter.get_races.assert_awaited_once()  # Adapter was called\n        assert len(result_miss[\"races\"]) == 1\n        assert result_miss[\"races\"][0][\"trackName\"] == \"Cache Park\"\n\n        # --- 2. Cache Hit ---\n        # ARRANGE\n        mock_adapter.get_races.reset_mock()\n\n        # ACT\n        result_hit = await engine.fetch_all_odds(today_str)\n\n        # ASSERT\n        mock_adapter.get_races.assert_not_awaited()  # Adapter was NOT called\n        assert len(result_hit[\"races\"]) == 1, \"Should return data from cache on cache hit\"\n        assert result_hit[\"races\"][0][\"trackName\"] == \"Cache Park\"\n\n\n@pytest.mark.asyncio\nasync def test_http_client_tenacity_retry():\n    \"\"\"\n    SPEC: The shared httpx client in BaseAdapterV3 should retry on transient HTTP errors.\n    \"\"\"\n    # ARRANGE\n    engine = OddsEngine(config=get_test_settings())\n    # Find a real adapter instance to test with\n    adapter_instance = next((a for a in engine.adapters if a.source_name == \"at_the_races_adapter\"), None)\n    assert adapter_instance is not None, \"Could not find a suitable adapter to test\"\n\n    # Mock the internal httpx client's request method to simulate failures\n    mock_response = MagicMock()\n    mock_response.status_code = 503  # Service Unavailable\n    mock_response.raise_for_status.side_effect = httpx.HTTPStatusError(\n        \"Service Unavailable\", request=MagicMock(), response=mock_response\n    )\n\n    # Configure the mock to fail twice, then succeed\n    adapter_instance.http_client.get = AsyncMock(\n        side_effect=[\n            mock_response,\n            mock_response,\n            AsyncMock(status_code=200, text=\"<html>Success</html>\"),\n        ]\n    )\n\n    # ACT & ASSERT\n    try:\n        # This call should succeed after two retries\n        await adapter_instance._fetch_data(\"https://any.url\")\n    except RetryError:\n        pytest.fail(\"The HTTP client did not successfully retry after transient errors\")\n\n    # ASSERT\n    assert adapter_instance.http_client.get.call_count == 3, (\n        \"The client should have been called 3 times (1 initial + 2 retries)\"\n    )\n"
}