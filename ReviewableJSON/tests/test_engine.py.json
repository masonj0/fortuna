{
    "file_path": "tests/test_engine.py",
    "content": "from datetime import date\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom unittest.mock import AsyncMock\nfrom unittest.mock import patch\n\nimport fakeredis.aioredis\nimport pytest\n\nfrom python_service.adapters.base_v3 import BaseAdapterV3\nfrom python_service.engine import OddsEngine\nfrom python_service.models import AggregatedResponse\nfrom python_service.models import OddsData\nfrom python_service.models import Race\nfrom python_service.models import Runner\nfrom tests.conftest import get_test_settings\n\n\ndef create_mock_race(\n    source: str, venue: str, race_number: int, start_time: datetime, runners_data: list\n) -> Race:\n    \"\"\"Helper function to create a Race object for testing.\"\"\"\n    runners = []\n    for r_data in runners_data:\n        odds = {\n            source: OddsData(\n                win=Decimal(r_data[\"odds\"]), source=source, last_updated=datetime.now()\n            )\n        }\n        runners.append(Runner(number=r_data[\"number\"], name=r_data[\"name\"], odds=odds))\n\n    return Race(\n        id=f\"test_{source}_{race_number}\",\n        venue=venue,\n        race_number=race_number,\n        start_time=start_time,\n        runners=runners,\n        source=source,\n    )\n\n\n@pytest.fixture\ndef mock_engine() -> OddsEngine:\n    \"\"\"Provides an OddsEngine instance with a mock config.\"\"\"\n    return OddsEngine(config=get_test_settings())\n\n\n@pytest.mark.asyncio\n@patch(\"python_service.engine.OddsEngine._time_adapter_fetch\", new_callable=AsyncMock)\nasync def test_engine_deduplicates_races_and_merges_odds(\n    mock_time_adapter_fetch, mock_engine\n):\n    \"\"\"\n    SPEC: The OddsEngine's fetch_all_odds method should identify duplicate races\n    from different sources and merge their runner data, stacking the odds.\n    \"\"\"\n    # ARRANGE\n    test_time = datetime(2025, 10, 9, 14, 30)\n\n    source_a_race = create_mock_race(\n        \"SourceA\",\n        \"Test Park\",\n        1,\n        test_time,\n        [\n            {\"number\": 1, \"name\": \"Speedy\", \"odds\": \"5.0\"},\n            {\"number\": 2, \"name\": \"Steady\", \"odds\": \"10.0\"},\n        ],\n    )\n    source_b_race = create_mock_race(\n        \"SourceB\",\n        \"Test Park\",\n        1,\n        test_time,\n        [\n            {\"number\": 1, \"name\": \"Speedy\", \"odds\": \"5.5\"},\n            {\"number\": 3, \"name\": \"Newcomer\", \"odds\": \"15.0\"},\n        ],\n    )\n    other_race = create_mock_race(\n        \"SourceC\",\n        \"Another Place\",\n        2,\n        test_time,\n        [{\"number\": 1, \"name\": \"Solo\", \"odds\": \"3.0\"}],\n    )\n\n    mock_time_adapter_fetch.side_effect = [\n        (\n            \"SourceA\",\n            {\n                \"races\": [source_a_race],\n                \"source_info\": {\n                    \"name\": \"SourceA\",\n                    \"status\": \"SUCCESS\",\n                    \"races_fetched\": 1,\n                    \"fetch_duration\": 1.0,\n                    \"attempted_url\": None,\n                    \"error_message\": None,\n                },\n            },\n            1.0,\n        ),\n        (\n            \"SourceB\",\n            {\n                \"races\": [source_b_race],\n                \"source_info\": {\n                    \"name\": \"SourceB\",\n                    \"status\": \"SUCCESS\",\n                    \"races_fetched\": 1,\n                    \"fetch_duration\": 1.0,\n                    \"attempted_url\": None,\n                    \"error_message\": None,\n                },\n            },\n            1.0,\n        ),\n        (\n            \"SourceC\",\n            {\n                \"races\": [other_race],\n                \"source_info\": {\n                    \"name\": \"SourceC\",\n                    \"status\": \"SUCCESS\",\n                    \"races_fetched\": 1,\n                    \"fetch_duration\": 1.0,\n                    \"attempted_url\": None,\n                    \"error_message\": None,\n                },\n            },\n            1.0,\n        ),\n    ]\n\n    # ACT\n    today_str = date.today().strftime(\"%Y-%m-%d\")\n    result = await mock_engine.fetch_all_odds(today_str)\n\n    # ASSERT\n    assert len(result[\"races\"]) == 2, \"Engine should have de-duplicated the races.\"\n    assert result[\"sourceInfo\"] is not None\n\n    merged_race = next((r for r in result[\"races\"] if r[\"venue\"] == \"Test Park\"), None)\n    assert merged_race is not None, \"Merged race should be present in the results.\"\n    assert (\n        len(merged_race[\"runners\"]) == 3\n    ), \"Merged race should contain all unique runners.\"\n\n    runner1 = next(\n        (r for r in merged_race[\"runners\"] if r[\"saddleClothNumber\"] == 1), None\n    )\n    assert runner1 is not None\n    assert \"SourceA\" in runner1[\"odds\"]\n    assert \"SourceB\" in runner1[\"odds\"]\n    assert runner1[\"odds\"][\"SourceA\"][\"win\"] == Decimal(\"5.0\")\n    assert runner1[\"odds\"][\"SourceB\"][\"win\"] == Decimal(\"5.5\")\n\n    runner2 = next(\n        (r for r in merged_race[\"runners\"] if r[\"saddleClothNumber\"] == 2), None\n    )\n    assert runner2 is not None\n    assert \"SourceA\" in runner2[\"odds\"] and \"SourceB\" not in runner2[\"odds\"]\n\n    runner3 = next(\n        (r for r in merged_race[\"runners\"] if r[\"saddleClothNumber\"] == 3), None\n    )\n    assert runner3 is not None\n    assert \"SourceB\" in runner3[\"odds\"] and \"SourceA\" not in runner3[\"odds\"]\n\n\n@pytest.mark.asyncio\nasync def test_engine_caching_logic():\n    \"\"\"\n    SPEC: The OddsEngine should cache results in Redis.\n    1. On a cache miss, it should fetch from adapters and set the cache.\n    2. On a cache hit, it should return data from the cache without fetching from adapters.\n    \"\"\"\n    # ARRANGE\n    # Use the synchronous FakeRedis for the synchronous CacheManager\n    with patch(\"redis.from_url\", fakeredis.FakeRedis.from_url):\n        import redis\n\n        from python_service.cache_manager import cache_manager\n\n        # Re-initialize the client on the singleton to use the patched sync version\n        cache_manager.redis_client = redis.from_url(\n            \"redis://fake\", decode_responses=True\n        )\n        assert cache_manager.redis_client is not None, \"Failed to patch redis_client\"\n\n        engine = OddsEngine(config=get_test_settings())\n\n        today_str = date.today().strftime(\"%Y-%m-%d\")\n        test_time = datetime(2025, 10, 9, 15, 0)\n        mock_race = create_mock_race(\n            \"TestSource\",\n            \"Cache Park\",\n            1,\n            test_time,\n            [{\"number\": 1, \"name\": \"Cachedy\", \"odds\": \"4.0\"}],\n        )\n\n        mock_adapter = AsyncMock(spec=BaseAdapterV3)\n        mock_adapter.source_name = \"TestSource\"\n        engine.adapters = [mock_adapter]  # Isolate to one mock adapter\n\n        cache_manager.redis_client.flushdb()\n\n        with patch.object(\n            engine, \"_time_adapter_fetch\", new_callable=AsyncMock\n        ) as mock_fetch:\n            source_info_payload = {\n                \"name\": \"TestSource\",\n                \"status\": \"SUCCESS\",\n                \"races_fetched\": 1,\n                \"error_message\": None,\n                \"fetch_duration\": 0.1,\n                \"attempted_url\": None,\n            }\n            adapter_result_payload = {\n                \"races\": [mock_race],\n                \"source_info\": source_info_payload,\n            }\n            mock_fetch.return_value = (\"TestSource\", adapter_result_payload, 0.1)\n\n            # --- ACT 1: Cache Miss ---\n            result_miss = await engine.fetch_all_odds(today_str)\n\n            # --- ASSERT 1: Cache Miss ---\n            mock_fetch.assert_called_once()\n            assert result_miss is not None\n            assert result_miss[\"races\"][0][\"venue\"] == \"Cache Park\"\n\n            # --- ACT 2: Cache Hit ---\n            result_hit = await engine.fetch_all_odds(today_str)\n\n            # --- ASSERT 2: Cache Hit ---\n            mock_fetch.assert_called_once()  # Should NOT be called again\n            assert result_hit is not None\n\n            # Compare model dumps to avoid Decimal vs. float issues after serialization\n            miss_obj = AggregatedResponse(**result_miss)\n            hit_obj = AggregatedResponse(**result_hit)\n            assert hit_obj.model_dump() == miss_obj.model_dump()\n\n    await engine.close()\n"
}