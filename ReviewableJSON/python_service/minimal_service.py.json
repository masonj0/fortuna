{
    "file_path": "python_service/minimal_service.py",
    "content": "# python_service/minimal_service.py\n# This is the minimal, sanctioned Flask backend for Checkmate Solo.\n\nimport random\nfrom datetime import datetime\nfrom datetime import timedelta\n\nfrom flask import Flask\nfrom flask import jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n# This enables CORS for all domains on all routes.\n# For a production environment, you would want to restrict this\n# to the domain of your frontend application.\nCORS(app)\n\n\ndef generate_mock_race(race_id: int):\n    \"\"\"Generates a single mock race with randomized data, mirroring the frontend's mock generator.\"\"\"\n    tracks = [\"Belmont Park\", \"Churchill Downs\", \"Santa Anita\", \"Keeneland\", \"Del Mar\"]\n    horses = [\n        \"Thunder Strike\",\n        \"Lightning Bolt\",\n        \"Swift Arrow\",\n        \"Golden Dream\",\n        \"Storm Chaser\",\n        \"Midnight Runner\",\n        \"Royal Flash\",\n        \"Desert Wind\",\n    ]\n\n    race_horses = []\n    for i in range(8):\n        betfair = round(2 + random.random() * 15, 2)\n        pointsbet = round(betfair * (0.9 + random.random() * 0.2), 2)\n        tvg = round(betfair * (0.85 + random.random() * 0.3), 2)\n\n        odds_values = {\"Betfair\": betfair, \"PointsBet\": pointsbet, \"TVG\": tvg}\n        best_source = min(odds_values, key=odds_values.get)\n        best_odds = odds_values[best_source]\n\n        avg_odds = (betfair + pointsbet + tvg) / 3\n        value_score = ((avg_odds - best_odds) / best_odds) * 100 if best_odds > 0 else 0\n\n        race_horses.append(\n            {\n                \"number\": i + 1,\n                \"name\": random.choice(horses),\n                \"odds\": {\n                    \"betfair\": f\"{betfair:.2f}\",\n                    \"pointsbet\": f\"{pointsbet:.2f}\",\n                    \"tvg\": f\"{tvg:.2f}\",\n                    \"best\": f\"{best_odds:.2f}\",\n                    \"best_source\": best_source,\n                },\n                \"value_score\": f\"{value_score:.1f}\",\n                \"trend\": random.choice([\"up\", \"down\"]),\n            }\n        )\n\n    race_horses.sort(key=lambda x: float(x[\"value_score\"]), reverse=True)\n\n    return {\n        \"id\": race_id,\n        \"track\": random.choice(tracks),\n        \"race_number\": random.randint(1, 10),\n        \"post_time\": (datetime.now() + timedelta(minutes=random.randint(5, 120))).isoformat(),\n        \"horses\": race_horses,\n    }\n\n\n@app.route(\"/api/races/live\", methods=[\"GET\"])\ndef get_live_races():\n    \"\"\"\n    This endpoint provides a list of live mock race data for the frontend.\n    It mimics the data structure the CheckmateSolo component expects.\n    \"\"\"\n    mock_races = [generate_mock_race(i) for i in range(5)]\n    return jsonify(mock_races)\n\n\nif __name__ == \"__main__\":\n    # The frontend component's TODO comment specifies port 8000.\n    print(\"Starting Checkmate Solo minimal backend service...\")\n    print(\"API available at http://localhost:8000/api/races/live\")\n    app.run(host=\"0.0.0.0\", port=8000, debug=False)\n"
}