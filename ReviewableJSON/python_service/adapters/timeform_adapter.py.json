{
    "file_path": "python_service/adapters/timeform_adapter.py",
    "content": "# python_service/adapters/timeform_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nimport httpx\nimport structlog\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom .base import BaseAdapter\n\nlog = structlog.get_logger(__name__)\n\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return \" \".join(text.strip().split()) if text else None\n\n\nclass TimeformAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"Timeform\", base_url=\"https://www.timeform.com\", config=config)\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response = await self.make_request(http_client, \"GET\", \"/horse-racing/racecards\")\n        if not response:\n            return []\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        links = {a[\"href\"] for a in soup.select(\"a.rp-racecard-off-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response = await self.make_request(http_client, \"GET\", url)\n            if not response:\n                return None\n            soup = BeautifulSoup(response.text, \"html.parser\")\n\n            track_name_tag = soup.select_one(\"h1.rp-raceTimeCourseName_name\")\n            if not track_name_tag:\n                log.warning(\"Could not find track name\", url=url)\n                return None\n            track_name = _clean_text(track_name_tag.get_text())\n\n            race_time_tag = soup.select_one(\"span.rp-raceTimeCourseName_time\")\n            if not race_time_tag:\n                log.warning(\"Could not find race time\", url=url)\n                return None\n            race_time_str = _clean_text(race_time_tag.get_text())\n\n            if not track_name or not race_time_str:\n                log.warning(\"Missing track name or race time\", url=url)\n                return None\n\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n            all_times = [_clean_text(a.get_text()) for a in soup.select(\"a.rp-racecard-off-link\")]\n            race_number = all_times.index(race_time_str) + 1 if race_time_str in all_times else 1\n\n            runner_rows = soup.select(\"div.rp-horseTable_mainRow\")\n            if not runner_rows:\n                log.warning(\"No runners found for race\", url=url)\n                return None # A race with no runners is not a race\n\n            runners = [self._parse_runner(row) for row in runner_rows]\n\n            return Race(\n                id=f\"tf_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\",\n                venue=track_name,\n                race_number=race_number,\n                start_time=start_time,\n                runners=[r for r in runners if r],\n                source=self.source_name,\n            )\n        except Exception as e:\n            log.error(\"Error parsing race from Timeform\", url=url, exc_info=e)\n            return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name_tag = row.select_one(\"a.rp-horseTable_horse-name\")\n            if not name_tag:\n                return None\n            name = _clean_text(name_tag.get_text())\n\n            num_tag = row.select_one(\"span.rp-horseTable_horse-number\")\n            if not num_tag:\n                return None\n            num_str = _clean_text(num_tag.get_text())\n            if not num_str:\n                return None\n            number_part = \"\".join(filter(str.isdigit, num_str.strip(\"()\")))\n            if not number_part:\n                return None\n            number = int(number_part)\n\n            if not name or not number:\n                return None\n\n            odds_data = {}\n            odds_tag = row.select_one(\"button.rp-bet-placer-btn__odds\")\n            if odds_tag:\n                odds_str = _clean_text(odds_tag.get_text())\n                win_odds = parse_odds_to_decimal(odds_str)\n                if win_odds and win_odds < 999:\n                    odds_data = {\n                        self.source_name: OddsData(\n                            win=win_odds,\n                            source=self.source_name,\n                            last_updated=datetime.now(),\n                        )\n                    }\n\n            return Runner(number=number, name=name, odds=odds_data)\n        except (AttributeError, ValueError, TypeError) as e:\n            log.warning(\"Failed to parse runner from Timeform\", detail=str(e), exc_info=True)\n            return None\n\n    def _format_response(\n        self, races: List[Race], start_time: datetime, is_success: bool, error_message: str = None\n    ) -> Dict[str, Any]:\n        return {\n            \"races\": races,\n            \"source_info\": {\n                \"name\": self.source_name,\n                \"status\": \"SUCCESS\" if is_success else \"FAILED\",\n                \"races_fetched\": len(races),\n                \"error_message\": error_message,\n                \"fetch_duration\": (datetime.now() - start_time).total_seconds(),\n            },\n        }\n"
}