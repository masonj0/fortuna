{
    "file_path": "python_service/adapters/equibase_adapter.py",
    "content": "# python_service/adapters/equibase_adapter.py\nfrom datetime import datetime\nfrom typing import AsyncGenerator\n\nfrom selectolax.parser import HTMLParser\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom .base import BaseAdapter\n\n\nclass EquibaseAdapter(BaseAdapter):\n    \"\"\"A production-ready adapter for scraping Equibase race entries.\"\"\"\n\n    SOURCE_NAME = \"Equibase\"\n    BASE_URL = \"https://www.equibase.com\"\n\n    def __init__(self, config=None):\n        super().__init__(self.SOURCE_NAME, self.BASE_URL)\n\n    async def fetch_races(self, date_str: str, http_client) -> AsyncGenerator[Race, None]:\n        \"\"\"\n        Fetches all US & Canadian races for a given date from equibase.com.\n        \"\"\"\n        entry_urls = await self._get_entry_urls(date_str, http_client)\n        for url in entry_urls:\n            try:\n                response = await http_client.get(url, headers=self._get_headers())\n                response.raise_for_status()\n                parser = HTMLParser(response.text)\n                race_links = parser.css(\"a.program-race-link\")\n                for link in race_links:\n                    race_url = f\"{self.BASE_URL}{link.attributes['href']}\"\n                    yield await self._parse_race(race_url, date_str, http_client)\n\n            except Exception:\n                # self.logger.error(f\"Failed to process entry page at {url}\", exc_info=True)\n                continue\n\n    async def _get_entry_urls(self, date_str: str, http_client) -> list[str]:\n        \"\"\"Gets all individual track entry page URLs for a given date.\"\"\"\n        d = datetime.strptime(date_str, \"%Y-%m-%d\").date()\n        url = f\"{self.BASE_URL}/entries/Entries.cfm?ELEC_DATE={d.month}/{d.day}/{d.year}&STYLE=EQB\"\n        response = await http_client.get(url, headers=self._get_headers())\n        parser = HTMLParser(response.text)\n        links = parser.css(\"div.track-information a\")\n        return [\n            f\"{self.BASE_URL}{link.attributes['href']}\"\n            for link in links\n            if \"race=\" not in link.attributes.get(\"href\", \"\")\n        ]\n\n    async def _parse_race(self, url: str, date_str: str, http_client) -> Race:\n        \"\"\"Parses a single race card page.\"\"\"\n        response = await http_client.get(url, headers=self._get_headers())\n        parser = HTMLParser(response.text)\n\n        venue = clean_text(parser.css_first(\"div.track-information strong\").text())\n        race_number = int(parser.css_first(\"div.race-information strong\").text().replace(\"Race\", \"\").strip())\n        post_time_str = parser.css_first(\"p.post-time span\").text().strip()\n        start_time = self._parse_post_time(date_str, post_time_str)\n\n        runners = []\n        runner_nodes = parser.css(\"table.entries-table tbody tr\")\n        for node in runner_nodes:\n            try:\n                number = int(node.css_first(\"td:nth-child(1)\").text(strip=True))\n                name = clean_text(node.css_first(\"td:nth-child(3)\").text())\n                odds_str = clean_text(node.css_first(\"td:nth-child(10)\").text())\n                scratched = \"scratched\" in node.attributes.get(\"class\", \"\").lower()\n\n                odds = {}\n                if not scratched:\n                    win_odds = parse_odds_to_decimal(odds_str)\n                    if win_odds and win_odds < 999:\n                        odds = {\n                            self.SOURCE_NAME: OddsData(\n                                win=win_odds, source=self.SOURCE_NAME, last_updated=datetime.now()\n                            )\n                        }\n\n                runners.append(Runner(number=number, name=name, odds=odds, scratched=scratched))\n            except (ValueError, AttributeError):\n                continue\n\n        return Race(\n            id=f\"eqb_{venue.lower().replace(' ', '')}_{date_str}_{race_number}\",\n            venue=venue,\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n            source=self.SOURCE_NAME,\n        )\n\n    def _parse_post_time(self, date_str: str, time_str: str) -> datetime:\n        \"\"\"Parses a time string like 'Post Time: 12:30 PM ET' into a datetime object.\"\"\"\n        time_part = time_str.split(\" \")[-2] + \" \" + time_str.split(\" \")[-1]\n        dt_str = f\"{date_str} {time_part}\"\n        return datetime.strptime(dt_str, \"%Y-%m-%d %I:%M %p\")\n\n    def _get_headers(self) -> dict:\n        return {\n            \"User-Agent\": (\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                \"Chrome/107.0.0.0 Safari/537.36\"\n            )\n        }\n"
}