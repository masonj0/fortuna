{
    ".github/actions/run-asgi-diagnostics/action.yml": "name: 'Run ASGI Import Killer Diagnostics'\ndescription: 'Runs a multi-phase diagnostic to verify Python ASGI application imports.'\n\ninputs:\n  python-version:\n    description: 'The version of Python to use.'\n    required: true\n  backend-dir:\n    description: 'The directory of the backend service to test.'\n    required: true\n  backend-module-path:\n    description: 'The Python module path for the backend service (e.g., web_service.backend).'\n    required: true\n\nruns:\n  using: \"composite\"\n  steps:\n      - name: \u2699\ufe0f Setup Python (EXACT VERSION)\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ inputs.python-version }}\n\n      - name: \ud83d\udccb Capture Python Info\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          Write-Host \"Python executable: $(which python)\" -ForegroundColor Cyan\n          python --version\n          python -m site\n          python -c \"import sys; print('Prefix:', sys.prefix); print('Base prefix:', sys.base_prefix)\"\n\n      - name: \ud83d\udce5 Install Requirements (Exactly as Backend Build)\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          python -m pip install --upgrade pip setuptools wheel --quiet\n\n          Write-Host \"Installing requirements.txt...\" -ForegroundColor Cyan\n          pip install -r (Join-Path \"${{ inputs.backend-dir }}\" \"requirements.txt\") -v 2>&1 | Tee-Object \"install-requirements.log\"\n\n          if (Test-Path (Join-Path \"${{ inputs.backend-dir }}\" \"requirements-dev.txt\")) {\n            Write-Host \"Installing requirements-dev.txt...\" -ForegroundColor Cyan\n            pip install -r (Join-Path \"${{ inputs.backend-dir }}\" \"requirements-dev.txt\") -v 2>&1 | Tee-Object -Append \"install-requirements.log\"\n          }\n\n          if ($LASTEXITCODE -ne 0) {\n            Write-Host \"\u274c pip install failed\" -ForegroundColor Red\n            exit 1\n          }\n\n          Write-Host \"\u2705 All dependencies installed\" -ForegroundColor Green\n\n      - name: \ud83d\udce6 Capture Installed Packages\n        shell: pwsh\n        run: |\n          pip list | Tee-Object \"installed-packages.txt\"\n          pip freeze | Tee-Object \"pip-freeze.txt\"\n\n      - name: \ud83d\udc0d Set PYTHONPATH\n        shell: pwsh\n        run: |\n          echo \"PYTHONPATH=${{ github.workspace }}\" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append\n          Write-Host \"PYTHONPATH set to ${{ github.workspace }}\"\n\n      - name: \ud83e\uddea PHASE 1 System Imports\n        shell: pwsh\n        run: |\n          $script = @(\n            'import sys',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 1 SYSTEM-LEVEL IMPORTS\")',\n            'print(\"=\"*80)',\n            'modules = [',\n            \"    ('os', 'filesystem'), ('sys', 'system'), ('json', 'serialization'),\",\n            \"    ('asyncio', 'async I/O'), ('pathlib', 'paths'), ('typing', 'type hints'),\",\n            \"    ('importlib', 'import utilities')\",\n            ']',\n            'failed = []',\n            'for mod_name, desc in modules:',\n            '    try:',\n            '        __import__(mod_name)',\n            '        print(f\"\u2705 {mod_name:20} [{desc}]\")',\n            '    except ImportError as e:',\n            '        print(f\"\u274c {mod_name:20} ImportError: {e}\")',\n            '        failed.append(mod_name)',\n            'if failed:',\n            '    print(f\"\\n\u274c {len(failed)} system imports failed\")',\n            '    sys.exit(1)',\n            'print(f\"\\n\u2705 Phase 1 complete\")'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n          if ($LASTEXITCODE -ne 0) { exit 1 }\n\n      - name: \ud83e\uddea PHASE 2 Web Framework Core\n        shell: pwsh\n        run: |\n          $script = @(\n            'import sys',\n            'import traceback',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 2 WEB FRAMEWORK CORE\")',\n            'print(\"=\"*80)',\n            'modules = [',\n            \"    ('fastapi', 'web framework'),\",\n            \"    ('uvicorn', 'ASGI server'),\",\n            \"    ('starlette', 'ASGI toolkit'),\",\n            \"    ('starlette.applications', 'ASGI app'),\",\n            \"    ('starlette.routing', 'routing'),\",\n            ']',\n            'failed = []',\n            'for mod_name, desc in modules:',\n            '    try:',\n            '        __import__(mod_name)',\n            '        print(f\"\u2705 {mod_name:30} [{desc}]\")',\n            '    except ImportError as e:',\n            '        print(f\"\u274c {mod_name:30} ImportError: {e}\")',\n            '        failed.append((mod_name, str(e)))',\n            '    except Exception as e:',\n            '        print(f\"\u26a0\ufe0f  {mod_name:30} {type(e).__name__}: {e}\")',\n            'if failed:',\n            '    print(f\"\\n\u274c {len(failed)} core framework imports failed\")',\n            '    for mod, err in failed:',\n            '        print(f\"  - {mod}\")',\n            '    sys.exit(1)',\n            'print(f\"\\n\u2705 Phase 2 complete\")'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n          if ($LASTEXITCODE -ne 0) { exit 1 }\n\n      - name: \ud83e\uddea PHASE 3 Pydantic & Data Validation\n        shell: pwsh\n        run: |\n          $script = @(\n            'import sys',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 3 PYDANTIC & DATA VALIDATION\")',\n            'print(\"=\"*80)',\n            'modules = [',\n            \"    ('pydantic', 'validation'),\",\n            \"    ('pydantic_core', 'core'),\",\n            \"    ('pydantic_settings', 'settings'),\",\n            ']',\n            'for mod_name, desc in modules:',\n            '    try:',\n            '        __import__(mod_name)',\n            '        print(f\"\u2705 {mod_name:30} [{desc}]\")',\n            '    except Exception as e:',\n            '        print(f\"\u274c {mod_name:30} {type(e).__name__}: {e}\")',\n            '        sys.exit(1)',\n            'print(f\"\\n\u2705 Phase 3 complete\")'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n          if ($LASTEXITCODE -ne 0) { exit 1 }\n\n      - name: \ud83e\uddea PHASE 4 Async/IO Utilities\n        shell: pwsh\n        run: |\n          $script = @(\n            'import sys',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 4 ASYNC/IO UTILITIES\")',\n            'print(\"=\"*80)',\n            'modules = [',\n            \"    ('anyio', 'async compat'),\",\n            \"    ('httpcore', 'HTTP core'),\",\n            \"    ('httpx', 'HTTP client'),\",\n            \"    ('aiosqlite', 'async DB'),\",\n            ']',\n            'for mod_name, desc in modules:',\n            '    try:',\n            '        __import__(mod_name)',\n            '        print(f\"\u2705 {mod_name:30} [{desc}]\")',\n            '    except Exception as e:',\n            '        print(f\"\u274c {mod_name:30} {type(e).__name__}: {e}\")',\n            '        sys.exit(1)',\n            'print(f\"\\n\u2705 Phase 4 complete\")'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n          if ($LASTEXITCODE -ne 0) { exit 1 }\n\n      - name: \ud83e\uddea PHASE 5 Optional Dependencies (non-critical)\n        shell: pwsh\n        continue-on-error: true\n        run: |\n          $script = @(\n            'import sys',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 5 OPTIONAL DEPENDENCIES (non-critical)\")',\n            'print(\"=\"*80)',\n            'modules = [',\n            \"    ('slowapi', 'rate limiting'),\",\n            \"    ('structlog', 'logging'),\",\n            \"    ('tenacity', 'retries'),\",\n            ']',\n            'for mod_name, desc in modules:',\n            '    try:',\n            '        __import__(mod_name)',\n            '        print(f\"\u2705 {mod_name:30} [{desc}]\")',\n            '    except Exception as e:',\n            '        print(f\"\u26a0\ufe0f  {mod_name:30} not critical: {type(e).__name__}\")',\n            'print(f\"\\n\u2705 Phase 5 complete (warnings OK)\")'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n\n      - name: \ud83e\uddea PHASE 6 Application Directory Structure\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n\n          $script = @(\n            'import os',\n            'from pathlib import Path',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 6 APPLICATION DIRECTORY STRUCTURE\")',\n            'print(\"=\"*80)',\n            'cwd = Path.cwd()',\n            'backend_dir = cwd / \"${{ inputs.backend-dir }}\"',\n            'print(f\"\\nCurrent directory: {cwd}\")',\n            'print(f\"\\nBackend directory exists: {backend_dir.exists()}\")',\n            'if backend_dir.exists():',\n            '    print(f\"  Contents:\")',\n            '    for item in backend_dir.iterdir():',\n            '        print(f\"    - {item.name}\")',\n            '    main_py = backend_dir / \"main.py\"',\n            '    api_py = backend_dir / \"api.py\"',\n            '    print(f''\\n  main.py: {main_py.stat().st_size if main_py.exists() else \"N/A\"} bytes'')',\n            '    print(f''  api.py: {api_py.stat().st_size if api_py.exists() else \"N/A\"} bytes'')'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n\n      - name: \ud83e\uddea PHASE 7 CRITICAL - Application Module Imports\n        shell: pwsh\n        run: |\n          $script = @(\n            'import sys',\n            'import traceback',\n            'import importlib',\n            'from pathlib import Path',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"PHASE 7 APPLICATION MODULE IMPORTS (CRITICAL)\")',\n            'print(\"=\"*80)',\n            'backend_module_path = \"${{ inputs.backend-module-path }}\"',\n            'print(f\"\\n[Step 1] Dynamically importing module: {backend_module_path}\")',\n            'try:',\n            '    backend_module = importlib.import_module(backend_module_path)',\n            '    print(f\"\u2705 {backend_module_path} imported successfully\")',\n            'except Exception as e:',\n            '    print(f\"\u274c FATAL: {backend_module_path} import failed\")',\n            '    print(f\"   Error: {type(e).__name__}: {e}\")',\n            '    traceback.print_exc()',\n            '    sys.exit(1)',\n            'print(''\\\\n[Step 2] Retrieving \"app\" object from the API submodule...'')',\n            'api_module_path = f\"{backend_module_path}.api\"',\n            'try:',\n            '    api_module = importlib.import_module(api_module_path)',\n            '    app = getattr(api_module, \"app\")',\n            '    print(f\"\u2705 app object retrieved from {api_module_path}\")',\n            '    print(f\"   Type: {type(app)}\")',\n            '    print(f\"   Class: {app.__class__.__name__}\")',\n            '    print(f\"   Module: {app.__class__.__module__}\")',\n            'except (ImportError, AttributeError) as e:',\n            '    print(f\"\u274c FATAL: Could not get app object from {api_module_path}\")',\n            '    print(f\"   Error: {type(e).__name__}: {e}\")',\n            '    traceback.print_exc()',\n            '    sys.exit(1)',\n            'print(\"\\n\" + \"=\"*80)',\n            'print(\"\u2705 ALL APPLICATION IMPORTS SUCCESSFUL\")',\n            'print(\"=\"*80)',\n            'print(\"\\nThe ASGI app is fully importable.\")',\n            'print(\"Uvicorn should be able to load it successfully.\")'\n          )\n          $script | Out-File -FilePath \"diag_script.py\" -Encoding utf8\n          python diag_script.py\n          if ($LASTEXITCODE -ne 0) {\n            Write-Host \"\u274c APPLICATION IMPORT TEST FAILED\" -ForegroundColor Red\n            exit 1\n          }\n\n      - name: \ud83d\udccb Generate ASGI Diagnostic Report\n        if: always()\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $report = @()\n          $report += \"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\"\n          $report += \"\u2551              ASGI IMPORT KILLER - DIAGNOSTIC REPORT                        \u2551\"\n          $report += \"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\"\n          $report += \"\"\n          $report += \"Timestamp: $(Get-Date -Format 'o')\"\n          $report += \"Python: $(python --version)\"\n          $report += \"\"\n          $report += \"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\"\n          $result = if ($LASTEXITCODE -eq 0) { 'PASS \u2705' } else { 'FAIL \u274c' }\n          $report += \"\u2502 RESULT: $result \u2502\"\n          $report += \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\"\n          $report += \"\"\n          $report += \"If this passed:\"\n          $report += \"  \u2705 All required dependencies are installed\"\n          $report += \"  \u2705 python_service.main is importable\"\n          $report += \"  \u2705 FastAPI app is accessible\"\n          $report += \"  \u2705 The executable should work\"\n          $report += \"  \u2705 Uvicorn WILL be able to load the app\"\n          $report += \"\"\n          $report += \"If this failed:\"\n          $report += \"  \u274c See error output above for the exact problem\"\n          $report += \"  \u274c Fix the import error in your code\"\n          $report += \"  \u274c Common issues:\"\n          $report += \"     - Missing dependency in requirements.txt\"\n          $report += \"     - Syntax error in api.py or main.py\"\n          $report += \"     - Circular import in api.py\"\n          $report += \"     - api.py imports a module that fails\"\n          $report += \"\"\n          $report += \"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\"\n          $report | Tee-Object \"asgi-diagnostic-report.txt\"\n\n      - name: \ud83d\udce4 Upload Diagnostic Artifacts\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: asgi-import-diagnostics-${{ github.run_id }}\n          path: |\n            install-requirements.log\n            installed-packages.txt\n            pip-freeze.txt\n            asgi-diagnostic-report.txt\n          retention-days: 30\n          if-no-files-found: warn\n",
    ".github/workflows/build-monolith-tinyfield.yml.deactivated": "name: Build Monolith (TinyField)\n\non:\n  push:\n    branches: [ main ]\n  workflow_dispatch:\n\njobs:\n  build:\n    name: 'Build Fortuna Monolith (TinyField)'\n    runs-on: windows-latest\n\n    steps:\n      - name: \ud83d\udce5 Checkout\n        uses: actions/checkout@v4\n\n      # ========== FRONTEND ==========\n      - name: \ud83c\udfa8 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - name: \ud83e\uddf9 Clean Previous Builds\n        working-directory: ./web_service/frontend\n        shell: pwsh\n        run: |\n          Remove-Item -Path \"public\" -Recurse -Force -ErrorAction SilentlyContinue\n          Remove-Item -Path \".next\" -Recurse -Force -ErrorAction SilentlyContinue\n          Write-Host \"\u2705 Cleaned\"\n\n      - name: \ud83d\udccb Check Next.js Config\n        working-directory: ./web_service/frontend\n        shell: pwsh\n        run: |\n          Write-Host \"Checking package.json...\"\n          if (Test-Path \"package.json\") {\n            $pkg = Get-Content package.json | ConvertFrom-Json\n            Write-Host \"  name: $($pkg.name)\"\n            Write-Host \"  build: $($pkg.scripts.build)\"\n          } else {\n            Write-Error \"package.json not found!\"\n            exit 1\n          }\n\n      - name: \ud83c\udfd7\ufe0f Build Frontend\n        working-directory: ./web_service/frontend\n        shell: pwsh\n        run: |\n          Write-Host \"=== BUILDING FRONTEND ===\" -ForegroundColor Cyan\n\n          # Create/verify next.config.js\n          $configLines = @(\n            \"/** @type {import('next').NextConfig} */\",\n            \"const nextConfig = {\",\n            \"  output: 'export',\",\n            \"  distDir: 'build',\",\n            \"  images: { unoptimized: true },\",\n            \"  trailingSlash: true,\",\n            \"}\",\n            \"module.exports = nextConfig\"\n          )\n          $configContent = $configLines -join [System.Environment]::NewLine\n          Set-Content -Path \"next.config.js\" -Value $configContent -Encoding UTF8\n          Write-Host \"\u2705 next.config.js set for 'build' directory output\"\n\n          Write-Host \"Installing dependencies...\"\n          npm install --legacy-peer-deps\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"npm install failed\"\n            exit 1\n          }\n\n          Write-Host \"Building...\"\n          npm run build\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"npm run build failed\"\n            exit 1\n          }\n\n          Write-Host \"Moving build artifacts to 'public'...\"\n          New-Item -ItemType Directory -Force -Path \"public\" | Out-Null\n          Move-Item -Path \"build/*\" -Destination \"public\" -Force\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"Failed to move build artifacts\"\n            exit 1\n          }\n          Write-Host \"\u2705 Artifacts moved.\"\n\n          # Verify output\n          Write-Host \"`nVerifying output...\"\n          if (-not (Test-Path \"public\")) {\n            Write-Host \"\u274c 'public' directory not found!\" -ForegroundColor Red\n            Write-Host \"Contents of current dir:\"\n            Get-ChildItem | Format-Table Name\n            exit 1\n          }\n\n          if (-not (Test-Path \"public/index.html\")) {\n            Write-Host \"\u274c public/index.html not found!\" -ForegroundColor Red\n            Write-Host \"Contents of 'public':\"\n            Get-ChildItem -Path \"public\" -Recurse | Format-Table Name\n            exit 1\n          }\n\n          $count = (Get-ChildItem -Path \"public\" -Recurse -File).Count\n          Write-Host \"\u2705 Frontend built: $count files\" -ForegroundColor Green\n\n      # ========== BACKEND ==========\n      - name: \ud83d\udc0d Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.10.11'\n\n      - name: \ud83d\udce6 Install Python Dependencies\n        shell: pwsh\n        run: |\n          pip install --upgrade pip wheel\n          pip install pyinstaller==6.6.0\n          pip install pywin32 # CRITICAL: Provides the 'win32timezone' hidden import\n          pip install -r web_service/backend/requirements.txt\n\n      - name: \ud83d\udcc2 Create Data Directories\n        shell: pwsh\n        run: |\n          New-Item -ItemType Directory -Force -Path \"web_service/backend/data\" | Out-Null\n          New-Item -ItemType Directory -Force -Path \"web_service/backend/json\" | Out-Null\n          New-Item -ItemType Directory -Force -Path \"web_service/backend/logs\" | Out-Null\n\n      # ========== BUILD ==========\n      - name: \ud83d\udd28 Build with PyInstaller\n        shell: pwsh\n        run: |\n          Write-Host \"=== BUILDING MONOLITH ===\" -ForegroundColor Cyan\n\n          # Final verification\n          if (-not (Test-Path \"web_service/frontend/public/index.html\")) {\n            Write-Error \"\u274c Frontend not ready!\"\n            Write-Host \"Frontend path check:\"\n            Test-Path \"web_service/frontend/public\"\n            Test-Path \"web_service/frontend/public/index.html\"\n            exit 1\n          }\n\n          Write-Host \"\u2705 Frontend verified\"\n          Write-Host \"Running PyInstaller...\"\n\n          pyinstaller --noconfirm --clean fortuna-desktop-tinyfield.spec 2>&1 | Tee-Object -FilePath \"build.log\"\n\n          if ($LASTEXITCODE -ne 0) {\n            Write-Host \"Last 100 lines of build.log:\" -ForegroundColor Red\n            Get-Content \"build.log\" -Tail 100\n            exit 1\n          }\n\n          $exe = \"dist/Fortuna-Desktop-TinyField/Fortuna-Desktop-TinyField.exe\"\n          if (Test-Path $exe) {\n            $mb = (Get-Item $exe).Length / 1MB\n            Write-Host \"\u2705 BUILD SUCCESS: $([math]::Round($mb, 2)) MB\" -ForegroundColor Green\n          } else {\n            Write-Error \"EXE not created!\"\n            exit 1\n          }\n\n      # ========== PACKAGE & UPLOAD ==========\n      - name: \ud83d\udce6 Package Artifact for Distribution\n        shell: pwsh\n        run: |\n          $distDir = \"dist/Fortuna-Desktop-TinyField\"\n          Write-Host \"=== PACKAGING ARTIFACT ===\" -ForegroundColor Cyan\n\n          # Create README.txt\n          $readmeLines = @(\n            'Fortuna Desktop (TinyField) - User Guide',\n            '',\n            '**HOW TO RUN**',\n            '1. Double-click \"Fortuna-Desktop-TinyField.exe\".',\n            '2. The application window will open and the dashboard will load.',\n            '',\n            '**WHAT TO EXPECT**',\n            '- To stop the application, simply close the window.'\n          )\n          $readmeLines | Out-File -FilePath \"$distDir/README.txt\" -Encoding utf8\n          Write-Host \"\u2705 Created README.txt\"\n\n          # Create ZIP archive\n          $zipFileName = \"Fortuna-Desktop-TinyField-Windows-${{ github.run_number }}.zip\"\n          Compress-Archive -Path \"$distDir/*\" -DestinationPath $zipFileName -Force\n          Write-Host \"\u2705 Created $zipFileName\" -ForegroundColor Green\n\n      - name: \ud83d\udce4 Upload Packaged Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: Fortuna-Desktop-TinyField-Windows-${{ github.run_number }}\n          path: Fortuna-Desktop-TinyField-Windows-${{ github.run_number }}.zip\n          if-no-files-found: error\n\n      # ========== TEST ==========\n      - name: Install VC++ Redistributable\n        shell: pwsh\n        run: |\n          # Download and install VC++ Runtime\n          $url = \"https://aka.ms/vs/17/release/vc_redist.x64.exe\"\n          Invoke-WebRequest -Uri $url -OutFile vc_redist.x64.exe\n          .\\vc_redist.x64.exe /install /quiet /norestart\n\n      - name: \ud83e\uddea Smoke Test\n        continue-on-error: true\n        shell: pwsh\n        timeout-minutes: 5\n        run: |\n          Write-Host \"=== SMOKE TEST ===\" -ForegroundColor Cyan\n          $distDir = \"dist/Fortuna-Desktop-TinyField\"\n          $exe = \"$distDir/Fortuna-Desktop-TinyField.exe\"\n          $outputLog = \"$distDir/smoke-test-output.log\"\n          $internalLog = \"$distDir/fortuna-desktop-tinyfield.log\" # Assumes log is named after exe\n\n          Write-Host \"--- 1. Directory Manifest ---\" -ForegroundColor Yellow\n          Get-ChildItem -Path $distDir -Recurse | Format-Table Name, Length\n          if (-not (Test-Path $exe)) {\n            Write-Error \"FATAL: Executable not found at $exe\"\n            exit 1\n          }\n\n          Write-Host \"--- 2. Network State Dump ---\" -ForegroundColor Yellow\n          netstat -ano\n          Write-Host \"--- End of Network State ---\"\n\n          Write-Host \"--- 3. Starting Executable ---\" -ForegroundColor Yellow\n          Write-Host \"Starting: $exe\"\n          cmd /c \"start /b `\"$exe`\" > `\"$outputLog`\" 2>&1\"\n          Start-Sleep -Seconds 10 # Increased wait for GUI app\n\n          $proc = Get-Process -Name \"Fortuna-Desktop-TinyField\" -ErrorAction SilentlyContinue\n          if (-not $proc) {\n              Write-Host \"\u274c Process failed to start!\" -ForegroundColor Red\n              # Failure analysis will run at the end\n              $success = $false\n          } else {\n              Write-Host \"PID: $($proc.Id). Waiting up to 45 seconds for health check...\"\n              $success = $false\n              for ($i = 1; $i -le 45; $i++) {\n                  if ($proc.HasExited) {\n                      Write-Host \"\u274c Process exited prematurely (code: $($proc.ExitCode))\" -ForegroundColor Red\n                      break\n                  }\n                  try {\n                      $response = Invoke-WebRequest -Uri \"http://127.0.0.1:8000/api/health\" -UseBasicParsing -TimeoutSec 1 -ErrorAction Stop\n                      if ($response.StatusCode -eq 200) {\n                          Write-Host \"\u2705 SMOKE TEST PASSED!\" -ForegroundColor Green\n                          $success = $true\n                          break\n                      }\n                  } catch {\n                      Write-Host \"Health check attempt $i failed. Retrying... Error: $($_.Exception.Message)\"\n                      Start-Sleep -Seconds 1\n                  }\n              }\n          }\n\n          # --- Cleanup ---\n          if ($proc -and -not $proc.HasExited) {\n              Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue\n          }\n\n          # --- Final Verdict & Diagnostics ---\n          if ($success) {\n            Write-Host \"Smoke test SUCCEEDED.\"\n            exit 0\n          } else {\n            Write-Error \"SMOKE TEST FAILED.\"\n\n            Write-Host \"--- 4. Failure Analysis ---\" -ForegroundColor Yellow\n            if (Test-Path $outputLog) {\n                Write-Host \"--- Displaying startup output log (smoke-test-output.log) ---\"\n                Get-Content $outputLog -ErrorAction SilentlyContinue\n            } else {\n                Write-Host \"--- WARNING: Startup output log not found! ($outputLog) ---\"\n            }\n\n            if (Test-Path $internalLog) {\n                Write-Host \"--- Displaying internal application log (fortuna-monolith.log) ---\"\n                Get-Content $internalLog -ErrorAction SilentlyContinue\n            } else {\n                Write-Host \"--- WARNING: Internal application log not found! ($internalLog) ---\"\n                Write-Host \"This usually means the application crashed before it could initialize its logging.\"\n            }\n            exit 1\n          }\n\n      - name: \ud83d\udccb Upload Build Log\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: build-log-${{ github.run_number }}\n          path: build.log\n          if-no-files-found: ignore\n",
    ".python-version": "3.10\n",
    "JSON_BACKUP_MANIFEST.md": "# Checkmate Ultimate Solo: JSON Backup Manifest (Total Recall Edition)\n\n**Purpose:** To provide a single, complete, and verified list of direct links to the JSON backups of all CORE and Operational files. This is the definitive entry point for external AI code review.\n\n---\n\n## 1.0 CORE Architecture (JSON Backups)\n\n### Python Backend\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/api.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/engine.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/models.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/__init__.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/base.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/utils.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/betfair_adapter.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/pointsbet_adapter.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/racing_and_sports_adapter.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/tvg_adapter.py.json\n\n### TypeScript Frontend\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/package.json.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/package-lock.json.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/next.config.mjs.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/tailwind.config.ts.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/tsconfig.json.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/src/app/page.tsx.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/src/app/layout.tsx.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/src/app/globals.css.json\n\n---\n\n## 2.0 Operational & Tooling (JSON Backups)\n\n### Project Tooling\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/.gitignore.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/convert_to_json.py.json\n\n### Environment & Setup\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/setup_windows.bat.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/.env.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/requirements.txt.json\n\n### Strategic Blueprints\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/README.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/ARCHITECTURAL_MANDATE.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/HISTORY.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/STATUS.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/WISDOM.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/PROJECT_MANIFEST.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/ROADMAP_APPENDICES.md.json",
    "README_WINDOWS.md": "# \ud83d\udc34 Fortuna Faucet - User Guide for Windows\n\nWelcome to Fortuna Faucet! This guide provides simple, step-by-step instructions to get you up and running.\n\n## Installation\n\nInstalling the application is a straightforward process using our official installer.\n\n1.  **Download the Installer:**\n    *   Go to the [**Latest Release Page**](https://github.com/masonj0/fortuna/releases/latest) on GitHub.\n    *   Download the file ending in `.msi` (e.g., `JBMason's 1st App-X.X.X.msi`).\n\n2.  **Run the Installer:**\n    *   Double-click the downloaded `.msi` file to launch the setup wizard.\n    *   Follow the on-screen instructions to complete the installation.\n\n## What to Expect After Installation\n\nOnce the setup is complete, you will find a new folder in your Start Menu named **\"JBMason's 1st App\"**.\n\n*   **Launching the App:** Inside this folder, click on the **\"JBMason's 1st App\"** shortcut to start the application.\n*   **How it Works:** The shortcut launches the main application window (the dashboard). The backend data engine starts automatically in the background and will close when you exit the application.\n\nThat's it! All previous installation methods are now obsolete. Enjoy using the application!\n",
    "USER_GUIDE.MD": "# Fortuna Faucet - User Guide\n\nThis document provides instructions for users of the Fortuna Faucet application.\n\n## Installation\n\n1.  Download the `Fortuna-Faucet-Installer.msi` file from the latest release.\n2.  Run the installer and follow the on-screen instructions.\n3.  The application will be installed to `C:\\Program Files\\Fortuna Faucet` by default.\n\n## Usage\n\n1.  Launch the application from the Start Menu or desktop shortcut.\n2.  The main window will display the live race dashboard.\n3.  Use the settings page to configure your preferences.\n",
    "check_fixes.sh": "#!/bin/bash\nfile=\"web_service/backend/adapters/base_adapter_v3.py\"\n\necho \"Checking Fix #1 (import json)...\"\nif grep -q \"^import json\" \"$file\"; then\n    echo \"  \u2705 Fix #1: PRESENT\"\nelse\n    echo \"  \u274c Fix #1: MISSING\"\nfi\n\necho \"Checking Fix #2 (init in __init__)...\"\nif grep -A 20 \"def __init__\" \"$file\" | grep -q \"self.circuit_breaker = CircuitBreaker()\"; then\n    echo \"  \u2705 Fix #2: PRESENT\"\nelse\n    echo \"  \u274c Fix #2: MISSING or in wrong location\"\nfi\n\necho \"Checking Fix #3 (await calls)...\"\ncount=$(grep -c \"await self.circuit_breaker\" \"$file\")\nif [ \"$count\" -eq 4 ]; then\n    echo \"  \u2705 Fix #3: PRESENT (found $count await calls)\"\nelif [ \"$count\" -gt 0 ]; then\n    echo \"  \u26a0\ufe0f  Fix #3: PARTIAL (found $count/4 await calls)\"\nelse\n    echo \"  \u274c Fix #3: MISSING\"\nfi\n",
    "configure_startup.py": "# configure_startup.py\nimport sys\nimport winreg\nfrom pathlib import Path\n\n\nclass StartupManager:\n    \"\"\"Manage Windows startup registry entries for the current user.\"\"\"\n\n    REGISTRY_PATH = r\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"\n    APP_NAME = \"FortunaFaucetTray\"\n\n    @classmethod\n    def is_enabled(cls) -> bool:\n        try:\n            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.REGISTRY_PATH, 0, winreg.KEY_READ)\n            winreg.QueryValueEx(key, cls.APP_NAME)\n            winreg.CloseKey(key)\n            return True\n        except FileNotFoundError:\n            return False\n\n    @classmethod\n    def enable(cls):\n        launcher_path = Path(__file__).parent / \"launcher.ps1\"\n        cmd = f'powershell.exe -WindowStyle Hidden -File \"{launcher_path}\"'\n\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.REGISTRY_PATH, 0, winreg.KEY_WRITE)\n        winreg.SetValueEx(key, cls.APP_NAME, 0, winreg.REG_SZ, cmd)\n        winreg.CloseKey(key)\n        print(\"Startup enabled.\")\n\n    @classmethod\n    def disable(cls):\n        try:\n            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.REGISTRY_PATH, 0, winreg.KEY_WRITE)\n            winreg.DeleteValue(key, cls.APP_NAME)\n            winreg.CloseKey(key)\n            print(\"Startup disabled.\")\n        except FileNotFoundError:\n            print(\"Already disabled.\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"enable\":\n            StartupManager.enable()\n        elif sys.argv[1] == \"disable\":\n            StartupManager.disable()\n        elif sys.argv[1] == \"status\":\n            print(f\"Startup is currently {'enabled' if StartupManager.is_enabled() else 'disabled'}\")\n    else:\n        print(\"Usage: python configure_startup.py [enable|disable|status]\")\n",
    "electron/electron-builder-config.yml": "appId: com.jules.fortunafaucet\nproductName: \"Fortuna Faucet\"\n\ndirectories:\n  output: dist\n  buildResources: assets\n\nfiles:\n  - \"**/*\"\n  - \"!build_wix/**/*\"\n  - \"resources/**\"\n\n\nwin:\n  target: msi\n  icon: \"assets/icon.ico\"\n\nmsi:\n  oneClick: false\n  perMachine: true\n  runAfterFinish: true\n  # Explicitly pointing to the file ensures WiX picks it up\n  shortcutName: \"Fortuna Faucet\"\n  warningsAsErrors: false\n  template: \"build_wix/Product_Electron.wxs\"\n",
    "electron/preload.js": "// electron/preload.js\n// This script runs in a privileged environment with access to Node.js APIs.\n// It's used to securely expose specific functionality to the renderer process (the web UI).\n\nconst { contextBridge, ipcRenderer } = require('electron');\n\n// Expose a safe, limited API to the frontend.\ncontextBridge.exposeInMainWorld('electronAPI', {\n /**\n * Asynchronously fetches the secure API key from the main process.\n * @returns {Promise<string|null>} A promise that resolves with the API key or null if not found.\n */\n getApiKey: () => ipcRenderer.invoke('get-api-key'),\n\n /**\n * Asynchronously generates and saves a new secure API key.\n * @returns {Promise<string>} A promise that resolves with the newly generated API key.\n */\n generateApiKey: () => ipcRenderer.invoke('generate-api-key'),\n\n /**\n * Asynchronously saves a provided API key.\n * @param {string} apiKey - The API key to save.\n * @returns {Promise<{success: boolean}>} A promise that resolves with the result of the save operation.\n */\n saveApiKey: (apiKey) => ipcRenderer.invoke('save-api-key', apiKey),\n\n /**\n * Asynchronously saves Betfair credentials.\n * @param {{username: string, apiKey: string}} credentials - The credentials to save.\n * @returns {Promise<{success: boolean}>} A promise that resolves with the result of the save operation.\n */\n saveBetfairCredentials: (credentials) => ipcRenderer.invoke('save-betfair-credentials', credentials),\n\n /**\n  * Restarts the backend service.\n  */\n restartBackend: () => ipcRenderer.send('restart-backend'),\n\n /**\n  * Stops the backend service.\n  */\n stopBackend: () => ipcRenderer.send('stop-backend'),\n\n /**\n  * Fetches the current status of the backend service.\n  * @returns {Promise<{state: string, logs: string[]}>} A promise that resolves with the backend status.\n  */\n getBackendStatus: () => ipcRenderer.invoke('get-backend-status'),\n\n /**\n  * Subscribes to backend status updates.\n  * @param {function(event, {state: string, logs: string[]})} callback - The function to call with status updates.\n  */\n onBackendStatusUpdate: (callback) => {\n    // Deliberately strip event sender from callback to avoid security risks\n    const subscription = (event, ...args) => callback(...args);\n    ipcRenderer.on('backend-status-update', subscription);\n\n    // Return a function to unsubscribe\n    return () => {\n      ipcRenderer.removeListener('backend-status-update', subscription);\n    };\n  },\n\n  /**\n   * Gets the port the backend API is running on.\n   * @returns {Promise<number>} A promise that resolves with the port number.\n   */\n  getApiPort: () => ipcRenderer.invoke('get-api-port'),\n});\n",
    "fortuna-desktop-tinyfield.spec": "# fortuna-desktop.spec\n# This spec file is for creating a windowed, GUI-based application\n# using pywebview. It is based on fortuna-monolith.spec.\n\nfrom PyInstaller.utils.hooks import collect_submodules\nfrom pathlib import Path\nimport sys\nimport os\n\nblock_cipher = None\n\n# ===== GET PROJECT ROOT =====\nspec_path = Path(SPECPATH) if 'SPECPATH' in dir() else Path(os.path.dirname(os.path.abspath(__file__)))\nproject_root = spec_path.parent if spec_path.name == 'fortuna-desktop-tinyfield.spec' else spec_path\n\n# ===== FRONTEND VALIDATION =====\nfrontend_out = project_root / 'web_service' / 'frontend' / 'public'\nif not frontend_out.exists() or not (frontend_out / 'index.html').exists():\n    print(\"[ERROR] FATAL: Frontend 'public' directory with index.html not found!\")\n    sys.exit(1)\n\n# ===== BACKEND VALIDATION =====\nbackend_root = project_root / 'web_service' / 'backend'\nmain_script = project_root / 'run_desktop_app.py'\nif not main_script.exists():\n    print(f\"[ERROR] FATAL: Main script not found at {main_script}!\")\n    sys.exit(1)\n\n# ===== DATA FILES =====\ndatas = [\n    (str(frontend_out), 'public')\n]\n\n# ===== HIDDEN IMPORTS =====\nhiddenimports = list(set(\n    collect_submodules('web_service.backend') +\n    [\n        'uvicorn', 'uvicorn.logging', 'uvicorn.loops', 'uvicorn.loops.auto',\n        'uvicorn.protocols', 'uvicorn.protocols.http', 'uvicorn.protocols.http.auto',\n        'uvicorn.protocols.http.h11_impl', 'uvicorn.lifespan', 'uvicorn.lifespan.on',\n        'fastapi', 'starlette', 'pydantic', 'anyio', 'structlog', 'tenacity',\n        'sqlalchemy', 'greenlet', 'win32timezone'\n    ]\n))\n\n# ===== ANALYSIS =====\na = Analysis(\n    [str(main_script)],\n    pathex=[str(project_root), str(backend_root)],\n    binaries=[],\n    datas=datas,\n    hiddenimports=hiddenimports,\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    cipher=block_cipher,\n    noarchive=False,\n)\n\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\n# ===== BUILD EXECUTABLE (WINDOWED) =====\nexe = EXE(\n    pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],\n    name='Fortuna-Desktop-TinyField',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    runtime_tmpdir=None,\n    console=False,  # This creates a windowed application\n    disable_windowed_traceback=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n    icon=None # Consider adding an icon here later\n)\n\ncoll = COLLECT(\n    exe, a.binaries, a.zipfiles, a.datas,\n    strip=False,\n    upx=True,\n    name='Fortuna-Desktop-TinyField'\n)\n",
    "fortuna_app.py": "import os\nimport socket\nimport subprocess\nimport sys\nimport threading\nimport time\nimport tkinter as tk\nfrom pathlib import Path\nfrom tkinter import messagebox\nfrom tkinter import scrolledtext\nfrom tkinter import ttk\n\nimport psutil\nimport requests\n\n\n# --- Control Panel Tab (from former launcher_gui.py) ---\nclass ControlPanelTab(tk.Frame):\n    def __init__(self, parent, master_app):\n        super().__init__(parent, bg=\"#1a1a2e\")\n        self.master_app = master_app\n        self.backend_proc = None\n        self.frontend_proc = None\n        self.backend_unresponsive_count = 0\n        self.frontend_unresponsive_count = 0\n        self.first_launch = not (Path(os.environ[\"USERPROFILE\"]) / \"Desktop\" / \"\ud83d\udc34 Launch Fortuna Faucet.lnk\").exists()\n        self._create_ui()\n        self.monitor_thread = threading.Thread(target=self.monitor_services, daemon=True)\n        self.monitor_thread.start()\n\n    def log_output(self, message):\n        self.log_text.config(state=tk.NORMAL)\n        self.log_text.insert(tk.END, f\"[{time.strftime('%H:%M:%S')}] {message}\\n\")\n        self.log_text.config(state=tk.DISABLED)\n        self.log_text.see(tk.END)\n\n    def smart_start(self):\n        \"\"\"On first launch, run verification, create shortcuts, and then start.\"\"\"\n        if messagebox.askokcancel(\n            \"First-Time Setup\",\n            \"Welcome to Fortuna Faucet!\\n\\nThis first launch will verify your system and create a desktop shortcut for easy access. Proceed?\",\n        ):\n            # Steal and run the logic from the System Tools Tab\n            self.master_app.notebook.select(self.master_app.system_tools_tab)\n            self.master_app.system_tools_tab.run_verification()\n            self.master_app.system_tools_tab.run_create_shortcuts()\n\n            # Once done, revert to a normal start button\n            messagebox.showinfo(\"Setup Complete\", \"Setup is complete! The main services will now start.\")\n            self.launch_btn.config(text=\"\u25b6 START FORTUNA\", bg=\"#00ff88\", command=self.launch_services)\n            self.launch_services()\n\n    def _create_ui(self):\n        title = tk.Label(\n            self,\n            text=\"\ud83d\udc34 System Control Panel\",\n            font=(\"Segoe UI\", 16, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#00ff88\",\n        )\n        title.pack(pady=20)\n\n        status_frame = tk.Frame(self, bg=\"#1a1a2e\")\n        status_frame.pack(fill=tk.X, padx=40, pady=10)\n\n        tk.Label(\n            status_frame,\n            text=\"Backend Service (API)\",\n            font=(\"Segoe UI\", 10),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        ).pack(anchor=\"w\")\n        self.backend_status_canvas = tk.Canvas(status_frame, width=300, height=40, bg=\"#0f3460\", highlightthickness=0)\n        self.backend_status_canvas.pack(fill=tk.X, pady=(0, 10))\n        self.backend_indicator = self.backend_status_canvas.create_oval(15, 10, 35, 30, fill=\"#ff4444\", outline=\"\")\n        self.backend_text = self.backend_status_canvas.create_text(\n            55, 20, text=\"Stopped\", fill=\"#ffffff\", anchor=\"w\", font=(\"Segoe UI\", 9)\n        )\n\n        tk.Label(\n            status_frame,\n            text=\"Frontend Dashboard (UI)\",\n            font=(\"Segoe UI\", 10),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        ).pack(anchor=\"w\")\n        self.frontend_status_canvas = tk.Canvas(status_frame, width=300, height=40, bg=\"#0f3460\", highlightthickness=0)\n        self.frontend_status_canvas.pack(fill=tk.X)\n        self.frontend_indicator = self.frontend_status_canvas.create_oval(15, 10, 35, 30, fill=\"#ff4444\", outline=\"\")\n        self.frontend_text = self.frontend_status_canvas.create_text(\n            55, 20, text=\"Stopped\", fill=\"#ffffff\", anchor=\"w\", font=(\"Segoe UI\", 9)\n        )\n\n        button_frame = tk.Frame(self, bg=\"#1a1a2e\")\n        button_frame.pack(fill=tk.X, padx=40, pady=20)\n\n        self.launch_btn = tk.Button(\n            button_frame,\n            text=\"\u25b6 START FORTUNA\",\n            font=(\"Segoe UI\", 14, \"bold\"),\n            bg=\"#00ff88\",\n            fg=\"#000000\",\n            height=2,\n            relief=tk.FLAT,\n        )\n        if self.first_launch:\n            self.launch_btn.config(\n                text=\"\u25b6 FIRST-TIME START & SETUP\",\n                bg=\"#ff9900\",\n                command=self.smart_start,\n            )\n        else:\n            self.launch_btn.config(command=self.launch_services)\n        self.launch_btn.pack(fill=tk.X, pady=(0, 10))\n\n        self.stop_btn = tk.Button(\n            button_frame,\n            text=\"\u23f9 STOP SERVICES\",\n            font=(\"Segoe UI\", 12),\n            bg=\"#ff4444\",\n            fg=\"#ffffff\",\n            command=self.stop_services,\n            state=tk.DISABLED,\n            height=1,\n            relief=tk.FLAT,\n        )\n        self.stop_btn.pack(fill=tk.X)\n\n        self.log_text = scrolledtext.ScrolledText(self, height=5, bg=\"#000000\", fg=\"#00ff88\", state=tk.DISABLED)\n        self.log_text.pack(pady=10, padx=40, fill=tk.X)\n\n    def check_ports(self, ports=[8000, 3000]):\n        unavailable_ports = []\n        for port in ports:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                if s.connect_ex((\"127.0.0.1\", port)) == 0:\n                    unavailable_ports.append(port)\n        return unavailable_ports\n\n    def launch_services(self):\n        unavailable = self.check_ports()\n        if unavailable:\n            messagebox.showerror(\n                \"Port Conflict\",\n                f\"Cannot launch. Port(s) {', '.join(map(str, unavailable))} are already in use by another application.\",\n            )\n            return\n\n        self.launch_btn.config(state=tk.DISABLED)\n        self.update_status(\"backend\", \"starting\", \"Launching...\")\n        self.update_status(\"frontend\", \"starting\", \"Launching...\")\n\n        try:\n            venv_python = Path(\".venv/Scripts/python.exe\")\n            self.backend_proc = subprocess.Popen(\n                [\n                    str(venv_python),\n                    \"-m\",\n                    \"uvicorn\",\n                    \"python_service.api:app\",\n                    \"--host\",\n                    \"127.0.0.1\",\n                    \"--port\",\n                    \"8000\",\n                ],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n                cwd=Path(__file__).parent,\n                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,\n            )\n        except Exception as e:\n            self.update_status(\"backend\", \"error\", f\"Launch Error: {str(e)[:40]}\")\n            self.stop_btn.config(state=tk.NORMAL)\n            return\n\n        try:\n            self.frontend_proc = subprocess.Popen(\n                [\"npm\", \"run\", \"dev\"],\n                shell=True,\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n                cwd=\"web_platform/frontend\",\n                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,\n            )\n        except Exception as e:\n            self.update_status(\"frontend\", \"error\", f\"Launch Error: {str(e)[:40]}\")\n            self.stop_btn.config(state=tk.NORMAL)\n            return\n\n        self.stop_btn.config(state=tk.NORMAL)\n\n    def stop_services(self):\n        self.stop_btn.config(state=tk.DISABLED)\n        for proc_name in [\"backend\", \"frontend\"]:\n            proc = getattr(self, f\"{proc_name}_proc\")\n            if proc and proc.poll() is None:\n                try:\n                    parent = psutil.Process(proc.pid)\n                    for child in parent.children(recursive=True):\n                        child.kill()\n                    parent.kill()\n                except psutil.NoSuchProcess:\n                    pass\n            setattr(self, f\"{proc_name}_proc\", None)\n        self.launch_btn.config(state=tk.NORMAL)\n\n    def restart_service(self, service_name: str):\n        \"\"\"Gracefully stop and restart a single failed service.\"\"\"\n        proc_attr = f\"{service_name}_proc\"\n        proc = getattr(self, proc_attr)\n\n        # Stop the specific process\n        if proc and proc.poll() is None:\n            try:\n                parent = psutil.Process(proc.pid)\n                for child in parent.children(recursive=True):\n                    child.kill()\n                parent.kill()\n            except psutil.NoSuchProcess:\n                pass\n        setattr(self, proc_attr, None)\n\n        # Wait a moment\n        time.sleep(2)\n\n        # Relaunch the specific process\n        self.update_status(service_name, \"starting\", \"Attempting auto-restart...\")\n        try:\n            if service_name == \"backend\":\n                venv_python = Path(\".venv/Scripts/python.exe\")\n                new_proc = subprocess.Popen(\n                    [\n                        str(venv_python),\n                        \"-m\",\n                        \"uvicorn\",\n                        \"python_service.api:app\",\n                        \"--host\",\n                        \"127.0.0.1\",\n                        \"--port\",\n                        \"8000\",\n                    ],\n                    stdout=subprocess.DEVNULL,\n                    stderr=subprocess.DEVNULL,\n                    cwd=Path(__file__).parent.parent,\n                    creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,\n                )\n            else:  # frontend\n                new_proc = subprocess.Popen(\n                    [\"npm\", \"run\", \"dev\"],\n                    shell=True,\n                    stdout=subprocess.DEVNULL,\n                    stderr=subprocess.DEVNULL,\n                    cwd=\"web_platform/frontend\",\n                    creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,\n                )\n            setattr(self, proc_attr, new_proc)\n        except Exception as e:\n            self.update_status(service_name, \"error\", f\"Auto-restart failed: {e}\")\n\n    def monitor_services(self):\n        while True:\n            # --- Backend Monitoring ---\n            if self.backend_proc and self.backend_proc.poll() is None:\n                try:\n                    r = requests.get(\"http://localhost:8000/health\", timeout=2)\n                    if r.status_code == 200:\n                        self.update_status(\"backend\", \"ok\", \"Healthy (200 OK)\")\n                        self.backend_unresponsive_count = 0  # Reset counter on success\n                    else:\n                        self.update_status(\"backend\", \"error\", f\"Error ({r.status_code})\")\n                except requests.RequestException:\n                    self.update_status(\"backend\", \"unresponsive\", \"Unresponsive\")\n                    self.backend_unresponsive_count += 1\n                    if self.backend_unresponsive_count >= 3:  # If unresponsive for 3 cycles (15s)\n                        self.log_output(\"Backend unresponsive. Attempting automatic restart...\")\n                        self.restart_service(\"backend\")\n                        self.backend_unresponsive_count = 0  # Reset after attempt\n            else:\n                self.update_status(\"backend\", \"stopped\", \"Stopped\")\n\n            # --- Frontend Monitoring ---\n            if self.frontend_proc and self.frontend_proc.poll() is None:\n                try:\n                    r = requests.get(\"http://localhost:3000\", timeout=2)\n                    if r.status_code == 200:\n                        self.update_status(\"frontend\", \"ok\", \"Healthy (200 OK)\")\n                        self.frontend_unresponsive_count = 0\n                    else:\n                        self.update_status(\"frontend\", \"error\", f\"Error ({r.status_code})\")\n                except requests.RequestException:\n                    self.update_status(\"frontend\", \"unresponsive\", \"Unresponsive\")\n                    self.frontend_unresponsive_count += 1\n                    if self.frontend_unresponsive_count >= 3:\n                        self.log_output(\"Frontend unresponsive. Attempting automatic restart...\")\n                        self.restart_service(\"frontend\")\n                        self.frontend_unresponsive_count = 0\n            else:\n                self.update_status(\"frontend\", \"stopped\", \"Stopped\")\n            time.sleep(5)\n\n    def update_status(self, service: str, status: str, message: str):\n        colors = {\n            \"ok\": \"#00ff88\",\n            \"unresponsive\": \"#ffcc00\",\n            \"error\": \"#ff4444\",\n            \"stopped\": \"#ff4444\",\n            \"starting\": \"#0f6cbd\",\n        }\n        canvas = getattr(self, f\"{service}_status_canvas\")\n        indicator = getattr(self, f\"{service}_indicator\")\n        text = getattr(self, f\"{service}_text\")\n\n        canvas.itemconfig(indicator, fill=colors.get(status, \"#404060\"))\n        canvas.itemconfig(text, text=message)\n\n\n# --- Setup Wizard Tab (from former setup_wizard_gui.py) ---\nclass SetupWizardTab(tk.Frame):\n    def __init__(self, parent):\n        super().__init__(parent, bg=\"#1a1a2e\")\n        self.current_step = 0\n        self.settings = {}\n        self._create_widgets()\n        self.show_step(0)\n\n    def _create_widgets(self):\n        header = tk.Label(\n            self,\n            text=\"\ud83d\udd27 First-Time Setup & Configuration\",\n            font=(\"Segoe UI\", 16, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        )\n        header.pack(pady=20)\n        self.step_label = tk.Label(\n            self,\n            text=\"Step 1 of 4: Generate API Key\",\n            font=(\"Segoe UI\", 11),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        )\n        self.step_label.pack(pady=10)\n        self.content_frame = tk.Frame(self, bg=\"#1a1a2e\")\n        self.content_frame.pack(fill=tk.BOTH, expand=True, padx=30, pady=20)\n        button_frame = tk.Frame(self, bg=\"#1a1a2e\")\n        button_frame.pack(fill=tk.X, padx=30, pady=20)\n        self.prev_btn = tk.Button(\n            button_frame,\n            text=\"< Back\",\n            command=self.previous_step,\n            state=tk.DISABLED,\n            bg=\"#404060\",\n            fg=\"#ffffff\",\n            padx=20,\n        )\n        self.prev_btn.pack(side=tk.LEFT)\n        self.next_btn = tk.Button(\n            button_frame,\n            text=\"Next >\",\n            command=self.next_step,\n            bg=\"#00ff88\",\n            fg=\"#000000\",\n            font=(\"Segoe UI\", 11, \"bold\"),\n            padx=20,\n        )\n        self.next_btn.pack(side=tk.RIGHT)\n\n    def show_step(self, step_index):\n        self._clear_content()\n        self.current_step = step_index\n        if step_index == 0:\n            self._show_step_1()\n        elif step_index == 1:\n            self._show_step_2()\n        elif step_index == 2:\n            self._show_step_3()\n        elif step_index == 3:\n            self._show_step_4()\n        self.update_buttons()\n\n    def _show_step_1(self):\n        tk.Label(\n            self.content_frame,\n            text=\"\ud83d\udd10 Secure API Key\",\n            font=(\"Segoe UI\", 12, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        ).pack(anchor=\"w\")\n        tk.Label(\n            self.content_frame,\n            text=\"A secure API key will be generated and stored.\",\n            wraplength=600,\n            justify=tk.LEFT,\n            bg=\"#1a1a2e\",\n            fg=\"#cccccc\",\n        ).pack(anchor=\"w\", pady=10)\n        # ... Add API key generation logic and display ...\n\n    def _show_step_2(self):\n        tk.Label(\n            self.content_frame,\n            text=\"\ud83c\udfc7 Betfair Exchange (Optional)\",\n            font=(\"Segoe UI\", 12, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        ).pack(anchor=\"w\")\n        # ... Add Betfair configuration form ...\n\n    def _show_step_3(self):\n        tk.Label(\n            self.content_frame,\n            text=\"\u2713 Verifying Setup\",\n            font=(\"Segoe UI\", 12, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#00ff88\",\n        ).pack(anchor=\"w\")\n        # ... Add verification checks logic ...\n\n    def _show_step_4(self):\n        tk.Label(\n            self.content_frame,\n            text=\"\ud83c\udf89 Setup Complete!\",\n            font=(\"Segoe UI\", 14, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#00ff88\",\n        ).pack(pady=20)\n        self.next_btn.config(text=\"\u2713 Finish\", command=self.finish_setup)\n\n    def next_step(self):\n        if self.current_step < 3:\n            self.show_step(self.current_step + 1)\n\n    def previous_step(self):\n        if self.current_step > 0:\n            self.show_step(self.current_step - 1)\n\n    def finish_setup(self):\n        messagebox.showinfo(\"Setup Complete\", \"Your configuration has been saved.\")\n\n    def _clear_content(self):\n        for widget in self.content_frame.winfo_children():\n            widget.destroy()\n\n    def update_buttons(self):\n        self.prev_btn.config(state=tk.NORMAL if self.current_step > 0 else tk.DISABLED)\n        if self.current_step == 3:\n            self.next_btn.config(text=\"\u2713 Finish\", command=self.finish_setup)\n        else:\n            self.next_btn.config(text=\"Next >\", command=self.next_step)\n\n\n# --- System Tools Tab ---\nclass SystemToolsTab(tk.Frame):\n    def __init__(self, parent):\n        super().__init__(parent, bg=\"#1a1a2e\")\n        self._create_ui()\n\n    def _create_ui(self):\n        title = tk.Label(\n            self,\n            text=\"\u2699\ufe0f System Tools\",\n            font=(\"Segoe UI\", 16, \"bold\"),\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        )\n        title.pack(pady=20)\n        tk.Button(\n            self,\n            text=\"Create Desktop Shortcuts\",\n            command=self.run_create_shortcuts,\n            font=(\"Segoe UI\", 12),\n        ).pack(pady=10, padx=40, fill=tk.X)\n        tk.Button(\n            self,\n            text=\"Verify Installation\",\n            command=self.run_verification,\n            font=(\"Segoe UI\", 12),\n        ).pack(pady=10, padx=40, fill=tk.X)\n        self.output_box = scrolledtext.ScrolledText(self, height=10, bg=\"#0f3460\", fg=\"#ffffff\", state=tk.DISABLED)\n        self.output_box.pack(pady=10, padx=40, fill=tk.BOTH, expand=True)\n\n    def log_output(self, message):\n        self.output_box.config(state=tk.NORMAL)\n        self.output_box.insert(tk.END, message + \"\\n\")\n        self.output_box.config(state=tk.DISABLED)\n        self.output_box.see(tk.END)\n\n    def run_create_shortcuts(self):\n        self.log_output(\"--- Creating Desktop Shortcut ---\")\n        try:\n            from win32com.client import Dispatch\n\n            desktop = Path(os.environ[\"USERPROFILE\"]) / \"Desktop\"\n            app_path = Path(__file__).resolve()\n            shortcut_path = desktop / \"\ud83d\udc34 Launch Fortuna Faucet.lnk\"\n\n            if shortcut_path.exists():\n                self.log_output(\"\ud83d\udfe1 Shortcut already exists. Overwriting.\")\n\n            shell = Dispatch(\"WScript.Shell\")\n            shortcut = shell.CreateShortCut(str(shortcut_path))\n            shortcut.TargetPath = sys.executable\n            shortcut.Arguments = f'\"{app_path}\"'\n            shortcut.WorkingDirectory = str(app_path.parent)\n\n            ico_path = app_path.parent / \"fortuna.ico\"\n            if ico_path.exists():\n                shortcut.IconLocation = str(ico_path)\n            else:\n                self.log_output(\"\ud83d\udfe1 Icon file not found, using default.\")\n\n            shortcut.save()\n            self.log_output(\"\u2705 Success: Shortcut created on Desktop.\")\n        except ImportError:\n            self.log_output(\"\u274c ERROR: 'pywin32' is not installed. Cannot create shortcuts.\")\n            self.log_output(\"  Please run: pip install pywin32\")\n        except Exception as e:\n            self.log_output(f\"\u274c ERROR: An unexpected error occurred: {e}\")\n\n    def run_verification(self):\n        self.log_output(\"\\n--- Verifying System Setup ---\")\n        verifications = [\n            (\"Python 3.11+\", lambda: sys.version_info >= (3, 11)),\n            (\n                \"Python Virtual Env (.venv)\",\n                lambda: Path(\".venv\").exists() and Path(\".venv/Scripts/python.exe\").exists(),\n            ),\n            (\n                \"Node.js (npm)\",\n                lambda: subprocess.run(\"npm -v\", shell=True, capture_output=True).returncode == 0,\n            ),\n            (\n                \"Frontend Dependencies (node_modules)\",\n                lambda: Path(\"web_platform/frontend/node_modules\").exists(),\n            ),\n        ]\n\n        all_ok = True\n        for name, check in verifications:\n            result = check()\n            self.log_output(f\"- {name}: {'\u2705 OK' if result else '\u274c FAILED'}\")\n            if not result:\n                all_ok = False\n\n        if all_ok:\n            self.log_output(\"\\n\u2705 All checks passed. System is ready.\")\n        else:\n            self.log_output(\"\\n\u274c Some checks failed. Please review the log.\")\n\n\n# --- Main Application Window ---\nclass FortunaApp(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"\ud83d\udc34 Fortuna Faucet\")\n        self.geometry(\"700x550\")\n        self.configure(bg=\"#1a1a2e\")\n\n        style = ttk.Style()\n        style.theme_use(\"clam\")\n        style.configure(\"TNotebook\", background=\"#1a1a2e\", borderwidth=0)\n        style.configure(\"TNotebook.Tab\", background=\"#404060\", foreground=\"#ffffff\", padding=[10, 5])\n        style.map(\"TNotebook.Tab\", background=[(\"selected\", \"#0f6cbd\")])\n\n        self.notebook = ttk.Notebook(self)\n\n        self.control_panel_tab = ControlPanelTab(self.notebook, self)\n        self.setup_wizard_tab = SetupWizardTab(self.notebook)\n        self.system_tools_tab = SystemToolsTab(self.notebook)\n\n        self.notebook.add(self.control_panel_tab, text=\"Control Panel\")\n        self.notebook.add(self.setup_wizard_tab, text=\"Setup & Config\")\n        self.notebook.add(self.system_tools_tab, text=\"System Tools\")\n\n        self.notebook.pack(expand=True, fill=\"both\", padx=10, pady=10)\n\n    def on_closing(self):\n        if self.control_panel_tab.backend_proc or self.control_panel_tab.frontend_proc:\n            if messagebox.askokcancel(\"Quit\", \"Services are still running. Do you want to stop them and exit?\"):\n                self.control_panel_tab.stop_services()\n                self.destroy()\n        else:\n            self.destroy()\n\n\n# --- NEW: Self-Setup UI and Logic ---\nclass SetupApp(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Fortuna Faucet - First-Time Setup\")\n        self.geometry(\"700x500\")\n        self.configure(bg=\"#1a1a2e\")\n\n        self.protocol(\"WM_DELETE_WINDOW\", self.quit)\n\n        header_font = tk.font.Font(family=\"Segoe UI\", size=16, weight=\"bold\")\n        body_font = tk.font.Font(family=\"Segoe UI\", size=10)\n        button_font = tk.font.Font(family=\"Segoe UI\", size=12, weight=\"bold\")\n\n        tk.Label(\n            self,\n            text=\"\ud83d\udce6 Welcome to Fortuna Faucet\",\n            font=header_font,\n            bg=\"#1a1a2e\",\n            fg=\"#00ff88\",\n        ).pack(pady=(20, 10))\n        tk.Label(\n            self,\n            text=\"The necessary dependencies are not installed. Click 'Start Installation' to begin.\",\n            font=body_font,\n            bg=\"#1a1a2e\",\n            fg=\"#ffffff\",\n        ).pack(pady=(0, 20))\n\n        self.install_button = tk.Button(\n            self,\n            text=\"\u25b6\ufe0f Start Installation\",\n            font=button_font,\n            bg=\"#00ff88\",\n            fg=\"#000000\",\n            command=self.start_installation,\n            relief=tk.FLAT,\n            padx=20,\n            pady=10,\n        )\n        self.install_button.pack(pady=10)\n\n        self.output_box = scrolledtext.ScrolledText(\n            self,\n            height=15,\n            bg=\"#0f3460\",\n            fg=\"#cccccc\",\n            state=tk.DISABLED,\n            relief=tk.FLAT,\n            bd=0,\n            padx=10,\n            pady=10,\n        )\n        self.output_box.pack(pady=10, padx=40, fill=tk.BOTH, expand=True)\n\n        self.status_label = tk.Label(self, text=\"Waiting to start...\", font=body_font, bg=\"#1a1a2e\", fg=\"#ffffff\")\n        self.status_label.pack(pady=10)\n\n    def log(self, message):\n        self.output_box.config(state=tk.NORMAL)\n        self.output_box.insert(tk.END, message + \"\\n\")\n        self.output_box.config(state=tk.DISABLED)\n        self.output_box.see(tk.END)\n        self.update_idletasks()\n\n    def start_installation(self):\n        self.install_button.config(state=tk.DISABLED, text=\"Installation in progress...\")\n        self.log(\"--- Starting installation ---\")\n        self.status_label.config(text=\"Installing... Please be patient, this may take several minutes.\")\n        threading.Thread(target=self.run_install_commands, daemon=True).start()\n\n    def run_command(self, command):\n        process = subprocess.Popen(\n            command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n            encoding=\"utf-8\",\n            errors=\"replace\",\n            shell=True,\n        )\n        for line in iter(process.stdout.readline, \"\"):\n            self.log(line.strip())\n        process.wait()\n        return process.returncode\n\n    def run_install_commands(self):\n        commands = [\n            (\n                \"1/3: Creating Python virtual environment...\",\n                f\"{sys.executable} -m venv .venv\",\n            ),\n            (\n                \"2/3: Installing Python dependencies...\",\n                '\"' + str(Path(\".venv/Scripts/python.exe\")) + '\" -m pip install -r requirements.txt',\n            ),\n            (\n                \"3/3: Installing Node.js dependencies...\",\n                \"npm install --prefix web_platform/frontend\",\n            ),\n        ]\n\n        for i, (msg, cmd) in enumerate(commands):\n            self.log(f\"\\\\n--- STEP {msg} ---\")\n            return_code = self.run_command(cmd)\n            if return_code != 0:\n                self.log(f\"\\\\n--- ERROR: Step {i + 1} failed with code {return_code}. ---\")\n                self.status_label.config(\n                    text=\"Installation Failed. Please see log for details.\",\n                    fg=\"#ff4444\",\n                )\n                self.install_button.config(state=tk.NORMAL, text=\"Retry Installation\")\n                return\n\n        self.log(\"\\\\n--- \u2705 INSTALLATION COMPLETE! ---\")\n        self.status_label.config(text=\"Setup successful! You can now launch the application.\", fg=\"#00ff88\")\n        self.install_button.destroy()\n        launch_button = tk.Button(\n            self,\n            text=\"\ud83d\ude80 Launch Fortuna\",\n            font=tk.font.Font(family=\"Segoe UI\", size=12, weight=\"bold\"),\n            bg=\"#00ff88\",\n            fg=\"#000000\",\n            command=self.launch_app,\n            relief=tk.FLAT,\n            padx=20,\n            pady=10,\n        )\n        launch_button.pack(pady=10)\n\n    def launch_app(self):\n        self.destroy()\n        # Relaunch the script to start the main app\n        subprocess.Popen([sys.executable, __file__])\n\n\n# --- NEW: Main Execution Block ---\nif __name__ == \"__main__\":\n    VENV_PATH = Path(__file__).parent / \".venv\"\n    if not VENV_PATH.exists() or not (VENV_PATH / \"Scripts\" / \"python.exe\").exists():\n        # If the virtual environment doesn't exist, run the setup wizard.\n        setup_app = SetupApp()\n        setup_app.mainloop()\n    else:\n        # Otherwise, run the main application.\n        app = FortunaApp()\n        app.protocol(\"WM_DELETE_WINDOW\", app.on_closing)\n        app.mainloop()\n",
    "manual_override_tool.py": "import argparse\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Manual Override Tool for Checkmate Data Warehouse.\")\n    parser.add_argument(\"--file\", required=True, help=\"Path to the CSV file for ingestion.\")\n    parser.add_argument(\"--user\", required=True, help=\"The user ID performing the override.\")\n    args = parser.parse_args()\n\n    print(f\"Executing manual override by '{args.user}' for file '{args.file}'...\")\n\n    # 1. Connect to PostgreSQL\n    # engine = create_engine('postgresql://user:password@host:port/database')\n\n    # 2. Read and validate the CSV data\n    # race_df = pd.read_csv(args.file)\n    # ... validation logic ...\n\n    # 3. Add the manual_override_by column\n    # race_df['manual_override_by'] = args.user\n\n    # 4. Insert data into the 'historical_races' table\n    # race_df.to_sql('historical_races', engine, if_exists='append', index=False)\n\n    print(\"Manual override completed successfully.\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pg_schemas/quarantined_races.sql": "-- Schema for storing race data that fails validation\nCREATE TABLE IF NOT EXISTS quarantined_races (\n    quarantine_id SERIAL PRIMARY KEY,\n    race_id VARCHAR(255),\n    source VARCHAR(50),\n    payload JSONB NOT NULL,\n    reason VARCHAR(255) NOT NULL,\n    quarantined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"paddock-parser-ng\"\nversion = \"0.1.0\"\ndescription = \"A toolkit to identify the best racecards for betting.\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\n[project.scripts]\npaddock_parser_ui = \"paddock_parser.entry_points:run_terminal_ui\"\npaddock_parser_dashboard = \"paddock_parser.entry_points:run_dashboard\"\npaddock_parser_predict = \"paddock_parser.entry_points:run_prediction_engine\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n# Configuration for the Ruff linter\n[tool.ruff]\n# Allow lines to be up to 120 characters long.\nline-length = 120\n\n[tool.ruff.lint]\n# Enable Pyflakes (F), pycodestyle (E, W), and isort (I) rules.\nselect = [\"E\", \"F\", \"W\", \"I\"]\nignore = []\n\n[tool.ruff.lint.isort]\n# Sort imports within their sections alphabetically.\nforce-single-line = true\n",
    "scripts/canary_check.py": "#!/usr/bin/env python3\n# scripts/canary_check.py\n\"\"\"\nLightweight canary check for upstream data sources.\nRuns more frequently to detect issues early.\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nimport os\nimport time\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass, asdict\n\n# Ensure imports work\nsys.path.insert(0, str(Path(__file__).parent.parent))\n\n\n@dataclass\nclass CanaryResult:\n    \"\"\"Result of a single canary check.\"\"\"\n    source: str\n    success: bool\n    latency_ms: float\n    race_count: int\n    error: Optional[str] = None\n    timestamp: str = \"\"\n    \n    def __post_init__(self):\n        if not self.timestamp:\n            self.timestamp = datetime.utcnow().isoformat()\n\n\nclass SimpleCanaryChecker:\n    \"\"\"\n    Simple canary checker that tests each data source.\n    \"\"\"\n    \n    def __init__(self):\n        self.results: List[CanaryResult] = []\n    \n    async def check_twinspires(self) -> CanaryResult:\n        \"\"\"Check TwinSpires availability.\"\"\"\n        start = time.perf_counter()\n        \n        try:\n            from python_service.adapters.twinspires_adapter import TwinSpiresAdapter\n            \n            async with TwinSpiresAdapter() as adapter:\n                today = datetime.utcnow().strftime(\"%Y-%m-%d\")\n                races = await asyncio.wait_for(\n                    adapter.get_races(today),\n                    timeout=60\n                )\n                \n                latency = (time.perf_counter() - start) * 1000\n                race_count = len(races) if races else 0\n                \n                return CanaryResult(\n                    source=\"TwinSpires\",\n                    success=True,\n                    latency_ms=latency,\n                    race_count=race_count,\n                )\n                \n        except asyncio.TimeoutError:\n            return CanaryResult(\n                source=\"TwinSpires\",\n                success=False,\n                latency_ms=(time.perf_counter() - start) * 1000,\n                race_count=0,\n                error=\"Timeout after 60s\"\n            )\n        except Exception as e:\n            return CanaryResult(\n                source=\"TwinSpires\",\n                success=False,\n                latency_ms=(time.perf_counter() - start) * 1000,\n                race_count=0,\n                error=str(e)\n            )\n    \n    async def check_httpbin(self) -> CanaryResult:\n        \"\"\"Basic connectivity check via httpbin.\"\"\"\n        start = time.perf_counter()\n        \n        try:\n            from scrapling.fetchers import StealthyFetcher\n            \n            fetcher = StealthyFetcher(headless=True)\n            response = await asyncio.wait_for(\n                asyncio.to_thread(fetcher.fetch, 'https://httpbin.org/status/200'),\n                timeout=30\n            )\n            \n            latency = (time.perf_counter() - start) * 1000\n            \n            return CanaryResult(\n                source=\"httpbin\",\n                success=response.status == 200,\n                latency_ms=latency,\n                race_count=0,\n                error=None if response.status == 200 else f\"Status: {response.status}\"\n            )\n            \n        except Exception as e:\n            return CanaryResult(\n                source=\"httpbin\",\n                success=False,\n                latency_ms=(time.perf_counter() - start) * 1000,\n                race_count=0,\n                error=str(e)\n            )\n    \n    async def run_all_checks(self) -> Dict[str, Any]:\n        \"\"\"Run all canary checks.\"\"\"\n        print(\"=\" * 60)\n        print(\"CANARY HEALTH CHECK\")\n        print(f\"Time: {datetime.utcnow().isoformat()}\")\n        print(\"=\" * 60)\n        \n        # Run checks\n        checks = [\n            (\"httpbin\", self.check_httpbin),\n            (\"twinspires\", self.check_twinspires),\n        ]\n        \n        for name, check_func in checks:\n            print(f\"\\n\u2192 Checking {name}...\")\n            try:\n                result = await check_func()\n                self.results.append(result)\n                \n                if result.success:\n                    print(f\"  \u2705 {name}: OK ({result.latency_ms:.0f}ms, {result.race_count} races)\")\n                else:\n                    print(f\"  \u274c {name}: FAILED - {result.error}\")\n            except Exception as e:\n                print(f\"  \u274c {name}: Exception - {e}\")\n                self.results.append(CanaryResult(\n                    source=name,\n                    success=False,\n                    latency_ms=0,\n                    race_count=0,\n                    error=str(e)\n                ))\n        \n        # Calculate summary\n        total = len(self.results)\n        passed = sum(1 for r in self.results if r.success)\n        success_rate = passed / total if total > 0 else 0\n        \n        # Determine status\n        if success_rate >= 0.8:\n            status = \"healthy\"\n        elif success_rate >= 0.5:\n            status = \"degraded\"\n        else:\n            status = \"unhealthy\"\n        \n        summary = {\n            \"status\": status,\n            \"success_rate\": f\"{success_rate:.0%}\",\n            \"total_checks\": total,\n            \"passed\": passed,\n            \"failed\": total - passed,\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"results\": [asdict(r) for r in self.results]\n        }\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"SUMMARY\")\n        print(\"=\" * 60)\n        print(f\"Status: {status.upper()}\")\n        print(f\"Success Rate: {success_rate:.0%}\")\n        print(f\"Passed: {passed}/{total}\")\n        \n        return summary\n\n\nasync def main():\n    \"\"\"Run canary checks.\"\"\"\n    checker = SimpleCanaryChecker()\n    \n    try:\n        summary = await checker.run_all_checks()\n        \n        # Save results\n        with open(\"canary_result.json\", \"w\") as f:\n            json.dump(summary, f, indent=2)\n        \n        print(f\"\\nResults saved to canary_result.json\")\n        \n        # Exit code based on status\n        if summary[\"status\"] == \"unhealthy\":\n            return 1\n        return 0\n        \n    except Exception as e:\n        print(f\"\\n\u274c Canary check failed: {e}\")\n        \n        # Save error result\n        error_result = {\n            \"status\": \"error\",\n            \"success_rate\": \"0%\",\n            \"error\": str(e),\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        with open(\"canary_result.json\", \"w\") as f:\n            json.dump(error_result, f, indent=2)\n        \n        return 1\n\n\nif __name__ == \"__main__\":\n    exit_code = asyncio.run(main())\n    sys.exit(exit_code)\n",
    "scripts/fortuna-quick-start-tinyfield.ps1.deactivated": "<#\n.SYNOPSIS\n    Fortuna Supreme Developer Bootstrapper (v2.0)\n    Aligns with CI/CD 'Champion' workflows for robust local development.\n\n.DESCRIPTION\n    - Auto-detects and kills blocking processes on ports 8000/3000\n    - Validates Python/Node environments\n    - Installs dependencies using fast caching strategies (npm ci)\n    - Launches Backend (FastAPI) and Frontend (Next.js) in parallel\n\n.PARAMETER Clean\n    Removes build artifacts and caches (.next, __pycache__, etc.) before starting.\n\n.PARAMETER Production\n    Builds the frontend for production instead of running in dev mode.\n\n.PARAMETER NoFrontend\n    Launches only the backend API.\n#>\n\nparam(\n    [switch]$SkipChecks,\n    [switch]$NoFrontend,\n    [switch]$Production,\n    [switch]$Clean,\n    [string]$PythonExecutable\n)\n\n$ErrorActionPreference = \"Stop\"\n\n# --- Configuration ---\n$PROJECT_ROOT = Resolve-Path \"$PSScriptRoot\\..\"\n$BACKEND_DIR  = Join-Path $PROJECT_ROOT \"web_service\\backend\"\n$FRONTEND_DIR = Join-Path $PROJECT_ROOT \"web_service\\frontend\" # CORRECTED PATH\n$PYTHON_CMD   = if ($PythonExecutable) { $PythonExecutable } else { \"py -3.11\" }\n\n# --- Helper Functions ---\nfunction Show-Step($msg) { Write-Host \"`n\ud83d\udd35 $msg\" -ForegroundColor Cyan }\nfunction Show-Success($msg) { Write-Host \"   \u2705 $msg\" -ForegroundColor Green }\nfunction Show-Warn($msg) { Write-Host \"   \u26a0\ufe0f  $msg\" -ForegroundColor Yellow }\nfunction Show-Fail($msg) { Write-Host \"   \u274c $msg\" -ForegroundColor Red; exit 1 }\n\nfunction Clear-BuildCache {\n    Show-Step \"Cleaning build caches (-Clean active)...\"\n    $paths = @(\n        (Join-Path $FRONTEND_DIR \".next\"),\n        (Join-Path $FRONTEND_DIR \"node_modules\\.cache\"),\n        (Join-Path $BACKEND_DIR \"__pycache__\"),\n        (Join-Path $BACKEND_DIR \"*.spec\")\n    )\n    foreach ($p in $paths) {\n        if (Test-Path $p) {\n            try {\n                Remove-Item -Path $p -Recurse -Force\n                Write-Host \"   Deleted: $p\" -ForegroundColor Gray\n            } catch {\n                Show-Warn \"Could not delete '$p'. It might be locked. Error: $($_.Exception.Message)\"\n            }\n        }\n    }\n    Show-Success \"Cache cleared.\"\n}\n\nfunction Check-Port($port, $name) {\n    $process = Get-NetTCPConnection -LocalPort $port -State Listen -ErrorAction SilentlyContinue | Select-Object -ExpandProperty OwningProcess -Unique\n    if ($process) {\n        Show-Warn \"Port $port ($name) is blocked by PID $process. Giving 2s grace period before termination...\"\n        Start-Sleep -Seconds 2\n        Stop-Process -Id $process -Force -ErrorAction SilentlyContinue\n        Show-Success \"Port $port freed.\"\n    }\n}\n\n# --- Main Execution ---\n\nWrite-Host \"`n\ud83d\ude80 FORTUNA SUPREME BOOTSTRAPPER (TinyField Edition)\" -ForegroundColor Magenta\nWrite-Host \"=================================================\" -ForegroundColor Gray\n\nif ($Clean) { Clear-BuildCache }\n\n# 1. Pre-flight Checks\nif (-not $SkipChecks) {\n    Show-Step \"System Health Check\"\n    Check-Port 8000 \"Backend API\"\n    Check-Port 3000 \"Frontend UI\"\n}\n\n# 2. Backend Setup\nShow-Step \"Preparing Backend (Python)...\"\nif (-not (Test-Path $BACKEND_DIR)) { Show-Fail \"Backend directory not found at: $BACKEND_DIR\" }\n\ntry {\n    & $PYTHON_CMD --version\n    Show-Success \"Python executable found.\"\n} catch {\n    Show-Fail \"Python not found in PATH or specified executable is invalid.\"\n}\n\nWrite-Host \"   Upgrading pip/wheel...\" -NoNewline\n& $PYTHON_CMD -m pip install --upgrade pip wheel --quiet\nWrite-Host \" Done.\" -ForegroundColor Green\n\nShow-Warn \"   Installing/verifying Python dependencies from requirements.txt...\"\nPush-Location $BACKEND_DIR\n& $PYTHON_CMD -m pip install -r requirements.txt\nPop-Location\n\n# 3. Frontend Setup\nif (-not $NoFrontend) {\n    Show-Step \"Preparing Frontend (Node.js)...\"\n    if (-not (Test-Path $FRONTEND_DIR)) { Show-Fail \"Frontend directory not found at: $FRONTEND_DIR\" }\n\n    Push-Location $FRONTEND_DIR\n    # With the unified architecture, we only need to ensure the assets are present.\n    # The Node.js server is no longer required for the TinyField variant.\n    Show-Success \"Frontend assets are served by the backend.\"\n    Pop-Location\n}\n\n# 4. Launch Sequence\nShow-Step \"Launching Services...\"\n\nif ($env:CI) {\n    Show-Warn \"CI environment detected. Using Start-Job for backend...\"\n    $job = Start-Job -ScriptBlock {\n        param($path, $cmd)\n        Set-Location $path\n        # In CI, we want logs to go to stdout for capture\n        & $cmd -m uvicorn main:app --port 8000 --host 0.0.0.0\n    } -ArgumentList $BACKEND_DIR, $PYTHON_CMD\n    Show-Success \"Backend job started (Job ID: $($job.Id))\"\n\n    # Health check with improved logging and standardized endpoint\n    $healthCheckUrl = \"http://localhost:8000/api/health\"\n    Write-Host \"   Pinging backend health endpoint ($healthCheckUrl)...\"\n    Start-Sleep -Seconds 2 # Initial grace period\n    $timeout = 45\n    $start = Get-Date\n    $healthy = $false\n    while ((Get-Date) -lt $start.AddSeconds($timeout)) {\n        try {\n            $response = Invoke-WebRequest -Uri $healthCheckUrl -UseBasicParsing -TimeoutSec 2\n            if ($response.StatusCode -eq 200) {\n                Show-Success \"Backend is healthy and responding.\"\n                $healthy = $true\n                break\n            }\n        } catch {\n            Write-Host \"   ... ping failed. Error: $($_.Exception.Message)\"\n        }\n        Start-Sleep -Seconds 1\n    }\n\n    if (-not $healthy) {\n        Show-Fail \"Backend did not start within the $timeout-second timeout.\"\n        Receive-Job $job # Display any output from the failed job\n        Stop-Job $job\n        exit 1\n    }\n\n} else {\n    # -- LOCAL DEVELOPMENT (Existing Logic) --\n    $backendScript = \"cd `\"$BACKEND_DIR`\"; & $PYTHON_CMD -m uvicorn main:app --reload --port 8000\"\n    Start-Process pwsh -ArgumentList \"-NoExit\", \"-Command\", $backendScript -WindowStyle Normal\n    Show-Success \"Backend launched on Port 8000\"\n}\n\nif (-not $NoFrontend) {\n    # The backend now serves the frontend, so we don't need to launch a separate server.\n    Show-Success \"Frontend is served by the backend at http://localhost:8000/\"\n}\n\nif ($env:CI) {\n    Write-Host \"`n\u2728 CI run complete. Exiting.\" -ForegroundColor Cyan\n} else {\n    Write-Host \"`n\u2728 Fortuna is running! Press Ctrl+C in the popup windows to stop.\" -ForegroundColor Cyan\n}\n",
    "scripts/generate_spec_dual.py": "# scripts/generate_spec_dual.py\n# A unified, intelligent spec generator by Jules 1221\n# This script generates distinct PyInstaller specs for different build modes.\n\nimport argparse\nimport os\nimport sys\nimport subprocess\nfrom pathlib import Path\n\n# Fix for UnicodeEncodeError on Windows runners with special characters in logs\nif sys.platform == 'win32':\n    try:\n        # This is the most reliable way to ensure UTF-8 output on Windows\n        sys.stdout.reconfigure(encoding='utf-8')\n        sys.stderr.reconfigure(encoding='utf-8')\n    except TypeError:\n        # In some environments (like older Python versions or certain terminals),\n        # reconfigure might not be available. We fall back to a less ideal but\n        # still helpful method.\n        import codecs\n        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')\n        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')\n\ndef generate_spec(mode: str):\n    \"\"\"\n    Generates a PyInstaller spec file based on the specified mode ('ui' or 'svc').\n    \"\"\"\n    print(f\"--- \ud83d\udc0d Unified Spec Generator (Mode: {mode}) ---\")\n\n    # 1. Determine configuration based on mode\n    if mode == 'ui':\n        binary_name = 'fortuna-ui-bridge'\n        entry_point_name = 'main.py'\n        is_console = True  # Electron bridge needs console for stdio\n        datas = f\"[('{frontend_dist.as_posix()}', 'frontend_dist')]\"\n        hidden_imports = \"\"\"[\n        'uvicorn',\n        'fastapi',\n        'starlette',\n        'anyio',\n        'pydantic',\n        'uvicorn.logging',\n        'uvicorn.loops.auto',\n        'uvicorn.protocols.http.auto',\n        'win32timezone'\n    ]\"\"\"\n    elif mode == 'svc':\n        binary_name = 'fortuna-core-service'\n        entry_point_name = 'service_entry.py' # Dedicated Windows Service entry\n        is_console = False # Windows Service should be a GUI app\n        datas = \"[]\" # Service does not bundle the UI\n        hidden_imports = \"\"\"[\n        'uvicorn',\n        'fastapi',\n        'starlette',\n        'anyio',\n        'pydantic',\n        'uvicorn.logging',\n        'uvicorn.loops.auto',\n        'uvicorn.protocols.http.auto',\n        'win32timezone',\n        'win32serviceutil',\n        'win32service',\n        'win32event'\n    ]\"\"\"\n    else:\n        print(f\"\u274c Invalid mode specified: {mode}. Use 'ui' or 'svc'.\")\n        sys.exit(1)\n\n    print(f\"Binary Name: {binary_name}\")\n    print(f\"Entry Point: {entry_point_name}\")\n\n    # 2. Path Validation\n    script_dir = Path(__file__).parent.resolve()\n    project_root = script_dir.parent.resolve()\n    entry_point = project_root / \"web_service\" / \"backend\" / entry_point_name\n    frontend_dist = project_root / \"web_platform\" / \"frontend\" / \"out\"\n\n    if not entry_point.exists():\n        print(f\"\u274c Entry point not found: {entry_point}\")\n        sys.exit(1)\n\n    # 3. Locate critical DLLs\n    python_home = Path(sys.base_prefix)\n    dlls_to_bundle = [\n        python_home / 'python311.dll',\n        python_home / 'vcruntime140.dll'\n    ]\n    binaries = []\n    for dll_path in dlls_to_bundle:\n        if dll_path.exists():\n            binaries.append((str(dll_path).replace('\\\\\\\\', '/'), '.'))\n            print(f\"\u2705 Found required DLL: {dll_path}\")\n        else:\n             print(f\"\u26a0\ufe0f Could not find optional DLL, skipping: {dll_path}\")\n\n    # 4. Define the spec file content\n    spec_content = f\"\"\"\n# -*- mode: python ; coding: utf-8 -*-\n# Generated by scripts/generate_spec_dual.py (Mode: {mode})\n\nblock_cipher = None\n\na = Analysis(\n    ['{entry_point.as_posix()}'],\n    pathex=['{project_root.as_posix()}'],\n    binaries={binaries},\n    datas={datas},\n    hiddenimports={hidden_imports},\n    hookspath=[],\n    runtime_hooks=[],\n    excludes=['python_service'],\n    win_no_prefer_redirects=False,\n    win_private_assemblies=False,\n    cipher=block_cipher,\n    noarchive=False,\n)\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    [],\n    exclude_binaries=True,\n    name='{binary_name}',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    console={is_console},\n    icon=None,\n)\n\ncoll = COLLECT(\n    exe,\n    a.binaries,\n    a.zipfiles,\n    a.datas,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    name='{binary_name}',\n)\n\"\"\"\n\n    # 5. Write the spec file\n    spec_path = project_root / f\"{binary_name}.spec\"\n    print(f\"--- Writing spec file to {spec_path} ---\")\n    with open(spec_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(spec_content)\n    print(f\"\u2705 Spec file created.\")\n\n    # 6. Run PyInstaller\n    print(\"--- Running PyInstaller build ---\")\n    cmd = [\n        sys.executable,\n        \"-m\", \"PyInstaller\",\n        str(spec_path),\n        \"--clean\",\n        \"--noconfirm\",\n        \"--log-level\", \"WARN\"\n    ]\n    print(f\"Executing command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8')\n        print(\"\u2705 PyInstaller build successful.\")\n        print(result.stdout)\n    except subprocess.CalledProcessError as e:\n        print(\"\u274c PyInstaller build failed!\")\n        print(\"--- STDOUT ---\")\n        print(e.stdout)\n        print(\"--- STDERR ---\")\n        print(e.stderr)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate a PyInstaller spec file for different build modes.\")\n    parser.add_argument('--mode', required=True, choices=['ui', 'svc'], help=\"The build mode: 'ui' for Electron bridge or 'svc' for Windows Service.\")\n    args = parser.parse_args()\n    generate_spec(args.mode)\n",
    "scripts/launch-monolith.ps1": "# launch-monolith.ps1 - Lightweight launcher for fortuna-monolith.exe\nparam(\n    [string]$ExePath = \"dist/fortuna-monolith/fortuna-monolith.exe\",  # Path to your PyInstaller EXE\n    [int]$Port = 8000,\n    [switch]$AutoRestart\n)\n\n# Set environment variables (equivalent to Docker env)\n$env:FORTUNA_PORT = $Port\n$env:FORTUNA_MODE = \"monolith\"  # Custom flag for your app\n\n# Pre-launch checks (lightweight health check)\nfunction Test-PortFree {\n    param([int]$Port)\n    try {\n        $tcp = New-Object System.Net.Sockets.TcpClient\n        $tcp.Connect(\"127.0.0.1\", $Port)\n        $tcp.Close()\n        return $false  # Port in use\n    } catch {\n        return $true   # Port free\n    }\n}\n\nif (!(Test-Path $ExePath)) {\n    Write-Error \"Monolith EXE not found at $ExePath. Build it first with PyInstaller.\"\n    exit 1\n}\n\nif (!(Test-PortFree $Port)) {\n    Write-Error \"Port $Port is in use. Close conflicting app or change port.\"\n    exit 1\n}\n\n# Launch the EXE (in background, with logging)\nWrite-Host \"Launching Fortuna Monolith on port $Port...\"\n$process = Start-Process -FilePath $ExePath -ArgumentList \"--host 127.0.0.1 --port $Port\" -NoNewWindow -PassThru -RedirectStandardOutput \"monolith.log\" -RedirectStandardError \"monolith-error.log\"\n\n# Optional auto-restart loop (mimics Docker restart policies)\nif ($AutoRestart) {\n    while ($true) {\n        Start-Sleep 5  # Poll every 5 seconds\n        if ($process.HasExited) {\n            Write-Warning \"Monolith crashed (exit code $($process.ExitCode)). Restarting...\"\n            $process = Start-Process -FilePath $ExePath -ArgumentList \"--host 127.0.0.1 --port $Port\" -NoNewWindow -PassThru\n        }\n    }\n} else {\n    Write-Host \"Monolith launched successfully. Waiting for server to initialize...\"\n    Start-Sleep -Seconds 3 # Give the server a moment to start up before opening the browser\n\n    $url = \"http://127.0.0.1:$Port\"\n    Write-Host \"Opening application at $url in your default browser.\"\n    Start-Process $url\n\n    Write-Host \"Application is running. Press Ctrl+C in this window to stop the server.\"\n    Wait-Process -Id $process.Id\n}\n",
    "scripts/prepare_minimal_build.py": "# scripts/prepare_minimal_build.py\nimport os\nimport shutil\n\n# This script prepares the source tree for a 'minimal' build.\n# A minimal build includes only the core application and a small, curated\n# set of essential data adapters, excluding the larger, more specialized ones.\n\nADAPTERS_TO_KEEP = [\n    \"__init__.py\",\n    \"base_adapter.py\",\n    \"handler_factory.py\",\n    # --- Essential Adapters ---\n    \"betfair_adapter.py\",\n    \"sporting_life_adapter.py\",\n    \"racing_post_adapter.py\",\n]\n\n\ndef main():\n    \"\"\"\n    Removes non-essential adapter files from the python_service/adapters\n    directory to create a minimal build artifact.\n    \"\"\"\n    adapters_dir = os.path.join(\"python_service\", \"adapters\")\n    if not os.path.isdir(adapters_dir):\n        print(f\"[ERROR] Adapters directory not found at: {adapters_dir}\")\n        exit(1)\n\n    print(f\"Scanning adapters directory: {adapters_dir}\")\n    removed_count = 0\n    for filename in os.listdir(adapters_dir):\n        if filename not in ADAPTERS_TO_KEEP:\n            file_path = os.path.join(adapters_dir, filename)\n            try:\n                if os.path.isfile(file_path):\n                    os.remove(file_path)\n                    print(f\"  - Removed file: {filename}\")\n                    removed_count += 1\n                elif os.path.isdir(file_path):\n                    shutil.rmtree(file_path)\n                    print(f\"  - Removed directory: {filename}\")\n                    removed_count += 1\n            except OSError as e:\n                print(f\"[ERROR] Failed to remove {file_path}: {e}\")\n                exit(1)\n\n    print(f\"\\nMinimal build preparation complete. Removed {removed_count} non-essential adapter(s).\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "start_podman.bat": "@echo off\nREM ============================================================\nREM Fortuna Faucet - Podman Launcher for Windows\nREM A simple, friendly way to start your racing analysis engine\nREM ============================================================\n\nsetlocal enabledelayedexpansion\n\nREM Colors and styling\ncls\necho.\necho \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\necho \u2551                                                            \u2551\necho \u2551            \ud83d\udc34  FORTUNA FAUCET LAUNCHER (Podman) \ud83d\udc34         \u2551\necho \u2551          Racing Strategy Analysis Engine                  \u2551\necho \u2551                                                            \u2551\necho \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\necho.\n\nREM ============================================================\nREM STEP 1: Check if Podman is installed\nREM ============================================================\necho [1/5] Checking for Podman installation...\npodman --version >nul 2>&1\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Podman is not installed or not in PATH\n    echo.\n    echo To use Fortuna, you need Podman Desktop:\n    echo https://podman-desktop.io/\n    echo.\n    echo After installing Podman, restart your computer and try again.\n    echo.\n    pause\n    exit /b 1\n)\n\nfor /f \"tokens=*\" %%i in ('podman --version') do set PODMAN_VERSION=%%i\necho \u2713 Found: %PODMAN_VERSION%\necho.\n\nREM ============================================================\nREM STEP 2: Check if Podman machine is running\nREM ============================================================\necho [2/5] Checking if Podman machine is running...\npodman ps >nul 2>&1\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Podman machine is not running\n    echo.\n    echo Please:\n    echo 1. Open \"Podman Desktop\" from your Start Menu\n    echo 2. Make sure your Podman machine is started\n    echo 3. Then run this launcher again\n    echo.\n    pause\n    exit /b 1\n)\necho \u2713 Podman machine is running\necho.\n\nREM ============================================================\nREM STEP 3: Pull latest image\nREM ============================================================\necho [3/5] Pulling latest Fortuna image from Docker Hub...\necho (This may take a minute on first run)\necho.\npodman pull docker.io/masonj0/fortuna-faucet:latest\nif errorlevel 1 (\n    echo.\n    echo \u26a0 Warning: Could not pull from Docker Hub\n    echo Checking for local image...\n    podman image inspect masonj0/fortuna-faucet:latest >nul 2>&1\n    if errorlevel 1 (\n        echo \u2717 ERROR: No local image found\n        echo Please check your internet connection and try again.\n        echo.\n        pause\n        exit /b 1\n    )\n    echo \u2713 Using existing local image\n)\necho \u2713 Image ready\necho.\n\nREM ============================================================\nREM STEP 4: Start container\nREM ============================================================\necho [4/5] Starting Fortuna container...\necho.\n\nREM Stop any existing container (ignore errors)\npodman stop fortuna-faucet >nul 2>&1\npodman rm fortuna-faucet >nul 2>&1\n\nREM Create data directories if they don't exist\nif not exist \"data\" mkdir data\nif not exist \"logs\" mkdir logs\n\nREM Start container with proper quoting for paths with spaces\npodman run -d ^\n  --name fortuna-faucet ^\n  -p 8000:8000 ^\n  -v \"%cd%\\data:/app/web_service/backend/data\" ^\n  -v \"%cd%\\logs:/app/web_service/backend/logs\" ^\n  docker.io/masonj0/fortuna-faucet:latest\n\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Failed to start container\n    echo.\n    echo Try these troubleshooting steps:\n    echo 1. Open Podman Desktop\n    echo 2. Make sure your Podman machine is running\n    echo 3. Open Command Prompt and run: podman ps\n    echo    (This tests if Podman is working)\n    echo 4. Run this launcher again\n    echo.\n    pause\n    exit /b 1\n)\n\necho \u2713 Container started successfully\necho.\n\nREM ============================================================\nREM STEP 5: Wait and verify startup\nREM ============================================================\necho [5/5] Waiting for application to start...\ntimeout /t 3 /nobreak\n\nREM Check if container is still running\npodman inspect fortuna-faucet >nul 2>&1\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Container exited unexpectedly\n    echo.\n    echo Showing container logs for debugging:\n    echo.\n    podman logs fortuna-faucet\n    echo.\n    pause\n    exit /b 1\n)\n\necho \u2713 Application is ready!\necho.\n\nREM ============================================================\nREM SUCCESS - Open browser and show logs\nREM ============================================================\ncls\necho.\necho \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\necho \u2551                                                            \u2551\necho \u2551            \ud83c\udf89  FORTUNA IS RUNNING! (Podman) \ud83c\udf89           \u2551\necho \u2551                                                            \u2551\necho \u2551  Your racing analysis engine is ready at:                \u2551\necho \u2551                                                            \u2551\necho \u2551          http://localhost:8000                            \u2551\necho \u2551                                                            \u2551\necho \u2551  Opening browser now...                                   \u2551\necho \u2551                                                            \u2551\necho \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\necho.\n\nREM Open browser\nstart http://localhost:8000\n\nREM Small delay to let browser open\ntimeout /t 2 /nobreak\n\nREM Show logs\necho.\necho \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\necho \u2502 Live Application Logs (Ctrl+C to stop)                    \u2502\necho \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\necho.\n\npodman logs -f fortuna-faucet\n\nREM Cleanup on exit\necho.\necho Stopping Fortuna...\npodman stop fortuna-faucet >nul 2>&1\necho \u2713 Fortuna stopped\n\nexit /b 0\n",
    "tests/__init__.py": "# This file makes the 'tests' directory a package.\n",
    "tests/adapters/test_timeform_adapter_modernized.py": "# Modernized test resurrected from attic/legacy_tests_pre_triage/adapters/test_timeform_adapter.py\nfrom decimal import Decimal\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom python_service.adapters.timeform_adapter import TimeformAdapter\n\n\n@pytest.fixture\ndef timeform_adapter():\n    mock_config = MagicMock()\n    return TimeformAdapter(config=mock_config)\n\n\ndef read_fixture(file_path):\n    with open(file_path, \"r\") as f:\n        return f.read()\n\n\n@pytest.mark.asyncio\nasync def test_timeform_adapter_parses_html_correctly(timeform_adapter):\n    \"\"\"Verify adapter correctly parses a known HTML fixture.\"\"\"\n    mock_html = read_fixture(\"tests/fixtures/timeform_modern_sample.html\")\n\n    # Directly test the parsing of runners from the correct HTML structure\n    from bs4 import BeautifulSoup\n\n    soup = BeautifulSoup(mock_html, \"html.parser\")\n    runners = [timeform_adapter._parse_runner(row) for row in soup.select(\"div.rp-horseTable_mainRow\")]\n\n    assert len(runners) == 3, \"Should parse three runners\"\n\n    braveheart = next((r for r in runners if r.name == \"Braveheart\"), None)\n    assert braveheart is not None\n    assert braveheart.odds[\"Timeform\"].win == Decimal(\"3.5\")\n\n    steady_eddy = next((r for r in runners if r.name == \"Steady Eddy\"), None)\n    assert steady_eddy is not None\n    assert steady_eddy.odds[\"Timeform\"].win == Decimal(\"2.0\")\n",
    "tests/fixtures/timeform_legacy_sample.html": "<!DOCTYPE html><html><body><div class='race-card'><div class='runner'><span class='runner-name'>Braveheart</span><span class='runner-odds'>5/2</span></div><div class='runner'><span class='runner-name'>Speedster</span><span class='runner-odds'>10/1</span></div><div class='runner'><span class='runner-name'>Steady Eddy</span><span class='runner-odds'>EVENS</span></div></div></body></html>",
    "tests/test_api/test_endpoints.py": "import pytest\nfrom fastapi.testclient import TestClient\n\nfrom python_service.api import app\n\nclient = TestClient(app)\n\n\n@pytest.mark.asyncio\nasync def test_health_check(client):\n    \"\"\"Tests the unauthenticated /health endpoint.\"\"\"\n    response = await client.get(\"/health\")\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"healthy\"\n",
    "tests/test_models.py": "# Test suite for Pydantic models, resurrected from attic/legacy_tests_pre_triage/checkmate_v7/test_models.py\nimport datetime\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom python_service.models import Race\nfrom python_service.models import Runner\n\n\ndef test_runner_model_creation():\n    \"\"\"Tests basic successful creation of the Runner model.\"\"\"\n    from datetime import datetime\n    from decimal import Decimal\n\n    from python_service.models import OddsData\n\n    odds_data = {\"TestOdds\": OddsData(win=Decimal(\"6.0\"), source=\"TestOdds\", last_updated=datetime.now())}\n    runner = Runner(number=5, name=\"Test Horse\", odds=odds_data, scratched=False)\n    assert runner.number == 5\n    assert runner.name == \"Test Horse\"\n    assert not runner.scratched\n\n\ndef test_race_model_with_valid_runners():\n    \"\"\"Tests basic successful creation of the Race model.\"\"\"\n    from datetime import datetime\n    from decimal import Decimal\n\n    from python_service.models import OddsData\n\n    odds1 = {\"TestOdds\": OddsData(win=Decimal(\"3.0\"), source=\"TestOdds\", last_updated=datetime.now())}\n    odds2 = {\"TestOdds\": OddsData(win=Decimal(\"4.0\"), source=\"TestOdds\", last_updated=datetime.now())}\n    runner1 = Runner(number=1, name=\"A\", odds=odds1, scratched=False)\n    runner2 = Runner(number=2, name=\"B\", odds=odds2, scratched=False)\n    race = Race(\n        id=\"test-race-1\",\n        venue=\"TEST\",\n        race_number=1,\n        start_time=datetime.now(),\n        runners=[runner1, runner2],\n        source=\"test\",\n    )\n    assert race.venue == \"TEST\"\n    assert len(race.runners) == 2\n\n\ndef test_model_validation_fails_on_missing_required_field():\n    \"\"\"Ensures Pydantic's validation fires for missing required fields.\"\"\"\n    with pytest.raises(ValidationError):\n        # 'name' is a required field for a Runner\n        Runner(number=3, odds=\"3/1\", scratched=False)\n\n    with pytest.raises(ValidationError):\n        # 'venue' is a required field for a Race\n        Race(\n            id=\"test-race-2\",\n            race_number=2,\n            start_time=datetime.datetime.now(),\n            runners=[],\n            source=\"test\",\n        )\n",
    "verify_dashboard.py": "\nfrom playwright.sync_api import sync_playwright\n\ndef verify_dashboard(page):\n    \"\"\"\n    Navigates to the dashboard and takes a screenshot.\n    \"\"\"\n    page.goto(\"http://localhost:3000\")\n    page.wait_for_selector(\"text=Fortuna Faucet\")\n    page.screenshot(path=\"verification.png\")\n\nif __name__ == \"__main__\":\n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=True)\n        page = browser.new_page()\n        try:\n            verify_dashboard(page)\n        finally:\n            browser.close()\n",
    "web_service/backend/adapters/at_the_races_adapter.py": "# python_service/adapters/at_the_races_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom ..utils.text import normalize_venue_name\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass AtTheRacesAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for attheraces.com, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"AtTheRaces\"\n    BASE_URL = \"https://www.attheraces.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"\n        Fetches the raw HTML for all race pages for a given date.\n        Returns a dictionary containing a list of (URL, HTML content) tuples and the date.\n        \"\"\"\n        index_url = f\"/racecards/{date}\"\n        index_response = await self.make_request(\"GET\", index_url, headers=self._get_headers())\n        if not index_response:\n            self.logger.warning(\"Failed to fetch AtTheRaces index page\", url=index_url)\n            return None\n\n        # Save the raw HTML for debugging in CI\n        try:\n            with open(\"atr_debug.html\", \"w\", encoding=\"utf-8\") as f:\n                f.write(index_response.text)\n        except Exception as e:\n            self.logger.warning(\"Failed to save debug HTML for AtTheRaces\", error=str(e))\n\n        index_soup = BeautifulSoup(index_response.text, \"html.parser\")\n        links = {a[\"href\"] for a in index_soup.select('a[href^=\"/racecard/\"]')}\n\n        async def fetch_single_html(url_path: str):\n            response = await self.make_request(\"GET\", url_path, headers=self._get_headers())\n            return (url_path, response.text) if response else (url_path, \"\")\n\n        tasks = [fetch_single_html(link) for link in links]\n        html_pages_with_urls = await asyncio.gather(*tasks)\n        return {\"pages\": html_pages_with_urls, \"date\": date}\n\n    def _get_headers(self) -> dict:\n        return {\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.9\",\n            \"Cache-Control\": \"no-cache\",\n            \"Connection\": \"keep-alive\",\n            \"Host\": \"www.attheraces.com\",\n            \"Pragma\": \"no-cache\",\n            \"sec-ch-ua\": '\"Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"115\", \"Chromium\";v=\"115\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"Sec-Fetch-Dest\": \"document\",\n            \"Sec-Fetch-Mode\": \"navigate\",\n            \"Sec-Fetch-Site\": \"none\",\n            \"Sec-Fetch-User\": \"?1\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36\",\n            \"Referer\": \"https://www.attheraces.com/racecards\",\n        }\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of (URL, raw HTML string) tuples into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"pages\"):\n            return []\n\n        try:\n            race_date = datetime.strptime(raw_data[\"date\"], \"%Y-%m-%d\").date()\n        except ValueError:\n            self.logger.error(\n                \"Invalid date format provided to AtTheRacesAdapter\",\n                date=raw_data.get(\"date\"),\n            )\n            return []\n\n        all_races = []\n        for url_path, html in raw_data[\"pages\"]:\n            if not html:\n                continue\n            try:\n                soup = BeautifulSoup(html, \"html.parser\")\n                details_container = soup.select_one(\"atr-racecard-race-header .container\")\n                if not details_container:\n                    continue\n\n                track_name_node = details_container.select_one(\"h1 a\")\n                track_name_raw = clean_text(track_name_node.get_text()) if track_name_node else \"\"\n                track_name = normalize_venue_name(track_name_raw)\n\n                race_time_node = details_container.select_one(\"h1 span\")\n                race_time_str = (\n                    clean_text(race_time_node.get_text()).replace(\" ATR\", \"\") if race_time_node else \"\"\n                )\n\n                start_time = datetime.combine(\n                    race_date, datetime.strptime(race_time_str, \"%H:%M\").time()\n                )\n\n                race_number = 1  # Defaulting to 1 as the race number is not in the URL\n\n                runners = [self._parse_runner(row) for row in soup.select(\"atr-horse-in-racecard\")]\n\n                race = Race(\n                    id=f\"atr_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\",\n                    venue=track_name,\n                    race_number=race_number,\n                    start_time=start_time,\n                    runners=[r for r in runners if r],\n                    source=self.source_name,\n                )\n                all_races.append(race)\n            except (AttributeError, ValueError):\n                self.logger.warning(\n                    \"Error parsing a race from AtTheRaces, skipping race.\",\n                    exc_info=True,\n                )\n                continue\n        return all_races\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name_node = row.select_one(\"h3\")\n            if not name_node:\n                return None\n            name = clean_text(name_node.get_text())\n\n            num_node = row.select_one(\".horse-in-racecard__saddle-cloth-number\")\n            if not num_node:\n                return None\n            num_str = clean_text(num_node.get_text())\n            number = int(\"\".join(filter(str.isdigit, num_str)))\n\n            odds_node = row.select_one(\".horse-in-racecard__odds\")\n            odds_str = clean_text(odds_node.get_text()) if odds_node else \"\"\n\n            win_odds = parse_odds_to_decimal(odds_str)\n            odds_data = (\n                {\n                    self.source_name: OddsData(\n                        win=win_odds,\n                        source=self.source_name,\n                        last_updated=datetime.now(),\n                    )\n                }\n                if win_odds and win_odds < 999\n                else {}\n            )\n            return Runner(number=number, name=name, odds=odds_data)\n        except (AttributeError, ValueError):\n            self.logger.warning(\"Failed to parse a runner on AtTheRaces, skipping runner.\")\n            return None\n",
    "web_service/backend/adapters/brisnet_adapter.py": "# python_service/adapters/brisnet_adapter.py\nfrom datetime import datetime\nfrom typing import List\nfrom typing import Optional\n\nfrom bs4 import BeautifulSoup\nfrom dateutil.parser import parse\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import normalize_venue_name\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass BrisnetAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for brisnet.com, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"Brisnet\"\n    BASE_URL = \"https://www.brisnet.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"Fetches the raw HTML from the Brisnet race page.\"\"\"\n        url = \"/cgi-bin/intoday.cgi\"\n        response = await self.make_request(\"GET\", url, headers=self._get_headers())\n        if not response or not response.text:\n            return None\n\n        # Save the raw HTML for debugging in CI\n        try:\n            with open(\"brisnet_debug.html\", \"w\", encoding=\"utf-8\") as f:\n                f.write(response.text)\n        except Exception as e:\n            self.logger.warning(\"Failed to save debug HTML for Brisnet\", error=str(e))\n\n        return {\"html\": response.text, \"date\": date}\n\n    def _get_headers(self) -> dict:\n        return {\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.9\",\n            \"Cache-Control\": \"no-cache\",\n            \"Connection\": \"keep-alive\",\n            \"Host\": \"www.brisnet.com\",\n            \"Pragma\": \"no-cache\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"125\", \"Chromium\";v=\"125\", \"Not.A/Brand\";v=\"24\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"Sec-Fetch-Dest\": \"document\",\n            \"Sec-Fetch-Mode\": \"navigate\",\n            \"Sec-Fetch-Site\": \"none\",\n            \"Sec-Fetch-User\": \"?1\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36\",\n        }\n\n    def _parse_races(self, raw_data: Optional[dict]) -> List[Race]:\n        \"\"\"Parses the raw HTML into a list of Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"html\"):\n            self.logger.warning(\"No HTML content received from Brisnet\")\n            return []\n\n        html = raw_data[\"html\"]\n        race_date = raw_data[\"date\"]\n        soup = BeautifulSoup(html, \"html.parser\")\n\n        races = []\n        for race_link in soup.select(\"a[href*='brisnet.com/cgi-bin/briswatch.cgi/public/Brad/TODAY.PM']\"):\n            try:\n                race_number_str = race_link.text.strip()\n                if not race_number_str.isdigit():\n                    continue\n                race_number = int(race_number_str)\n\n                # Venue and start time are not available on the index page, so we have to be creative\n                # This is a significant simplification and may need to be revisited\n                venue = \"Unknown\"\n                if parent_table := race_link.find_parent(\"table\"):\n                    if caption := parent_table.find(\"caption\"):\n                        venue = normalize_venue_name(caption.text.strip())\n\n                # Create a placeholder start time as it's not available on this page\n                start_time = datetime.now()\n\n                # Since we don't have runner data on this page, we create a placeholder race\n                # A more complete implementation would require fetching each race link\n                race = Race(\n                    id=f\"brisnet_{venue.replace(' ', '').lower()}_{race_date}_{race_number}\",\n                    venue=venue,\n                    race_number=race_number,\n                    start_time=start_time,\n                    runners=[],\n                    source=self.source_name,\n                )\n                races.append(race)\n            except (ValueError, IndexError, TypeError) as e:\n                self.logger.warning(\n                    \"Failed to parse a race link on Brisnet\",\n                    link=race_link.get(\"href\"),\n                    error=e,\n                    exc_info=True,\n                )\n                continue\n\n        return races\n",
    "web_service/backend/adapters/harness_adapter.py": "# python_service/adapters/harness_adapter.py\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom zoneinfo import ZoneInfo\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass HarnessAdapter(BaseAdapterV3):\n    \"\"\"Adapter for fetching US harness racing data with manual override support.\"\"\"\n\n    SOURCE_NAME = \"USTrotting\"\n    BASE_URL = \"https://data.ustrotting.com/api/racenet/racing/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetches all harness races for a given date.\"\"\"\n        response = await self.make_request(\"GET\", f\"card/{date}\")\n\n        if not response:\n            return None\n\n        card_data = response.json()\n        return {\"data\": card_data, \"date\": date}\n\n    def _parse_races(self, raw_data: Optional[Dict[str, Any]]) -> List[Race]:\n        \"\"\"Parses the raw card data into a list of Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"data\") or not raw_data.get(\"data\", {}).get(\"meetings\"):\n            self.logger.warning(\"No meetings found in harness data response.\")\n            return []\n\n        all_races = []\n        date = raw_data.get(\"date\")\n        for meeting in raw_data.get(\"data\", {}).get(\"meetings\", []):\n            track_name = meeting.get(\"track\", {}).get(\"name\")\n            for race_data in meeting.get(\"races\", []):\n                try:\n                    if race := self._parse_race(race_data, track_name, date):\n                        all_races.append(race)\n                except Exception:\n                    self.logger.warning(\n                        \"Failed to parse harness race, skipping.\",\n                        race_data=race_data,\n                        exc_info=True,\n                    )\n                    continue\n        return all_races\n\n    def _parse_race(self, race_data: dict, track_name: str, date: str) -> Optional[Race]:\n        \"\"\"Parses a single race from the USTA API into a Race object.\"\"\"\n        race_number = race_data.get(\"raceNumber\")\n        post_time_str = race_data.get(\"postTime\")\n        if not all([race_number, post_time_str]):\n            return None\n\n        start_time = self._parse_post_time(date, post_time_str)\n\n        runners = []\n        for runner_data in race_data.get(\"runners\", []):\n            if runner_data.get(\"scratched\", False):\n                continue\n\n            odds_str = runner_data.get(\"morningLineOdds\", \"\")\n            if \"/\" not in odds_str and odds_str.isdigit():\n                odds_str = f\"{odds_str}/1\"\n\n            odds = {}\n            win_odds = parse_odds_to_decimal(odds_str)\n            if win_odds and win_odds < 999:\n                odds = {\n                    self.SOURCE_NAME: OddsData(\n                        win=win_odds,\n                        source=self.SOURCE_NAME,\n                        last_updated=datetime.now(),\n                    )\n                }\n\n            runners.append(\n                Runner(\n                    number=runner_data.get(\"postPosition\", 0),\n                    name=runner_data.get(\"horse\", {}).get(\"name\", \"Unknown Horse\"),\n                    odds=odds,\n                    scratched=False,\n                )\n            )\n\n        if not runners:\n            return None\n\n        return Race(\n            id=f\"ust_{track_name.lower().replace(' ', '')}_{date}_{race_number}\",\n            venue=track_name,\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n            source=self.SOURCE_NAME,\n        )\n\n    def _parse_post_time(self, date: str, post_time: str) -> datetime:\n        \"\"\"Parses a time string like '07:00 PM' into a timezone-aware datetime object.\"\"\"\n        dt_str = f\"{date} {post_time}\"\n        naive_dt = datetime.strptime(dt_str, \"%Y-%m-%d %I:%M %p\")\n        # Assume Eastern Time for USTA data, a common standard for US racing.\n        eastern = ZoneInfo(\"America/New_York\")\n        return naive_dt.replace(tzinfo=eastern)\n",
    "web_service/backend/adapters/punters_adapter.py": "# python_service/adapters/punters_adapter.py\nfrom typing import Any\nfrom typing import List\n\nfrom ..models import Race\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass PuntersAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for punters.com.au.\n    This adapter is a non-functional stub and has not been implemented.\n    \"\"\"\n\n    SOURCE_NAME = \"Punters\"\n    BASE_URL = \"https://www.punters.com.au\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"This is a stub and does not fetch any data.\"\"\"\n        self.logger.warning(\n            f\"{self.source_name} is a non-functional stub and has not been implemented. It will not fetch any data.\"\n        )\n        return None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"This is a stub and does not parse any data.\"\"\"\n        return []\n",
    "web_service/backend/adapters/sporting_life_adapter.py": "# python_service/adapters/sporting_life_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass SportingLifeAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for sportinglife.com, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"SportingLife\"\n    BASE_URL = \"https://www.sportinglife.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"\n        Fetches the raw HTML for all race pages for a given date.\n        Returns a dictionary containing the HTML content and the date.\n        \"\"\"\n        index_url = \"/racing/racecards\"  # The dated URL is causing a 307 redirect\n        index_response = await self.make_request(\n            \"GET\",\n            index_url,\n            headers=self._get_headers(),\n            follow_redirects=True,\n        )\n        if not index_response:\n            self.logger.warning(\"Failed to fetch SportingLife index page\", url=index_url)\n            return None\n\n        # Save the raw HTML for debugging in CI\n        try:\n            with open(\"sl_debug.html\", \"w\", encoding=\"utf-8\") as f:\n                f.write(index_response.text)\n        except Exception as e:\n            self.logger.warning(\"Failed to save debug HTML for SportingLife\", error=str(e))\n\n        index_soup = BeautifulSoup(index_response.text, \"html.parser\")\n        links = {\n            a[\"href\"]\n            for a in index_soup.select('li[class^=\"MeetingSummary__LineWrapper\"] a[href*=\"/racecard/\"]')\n        }\n\n        async def fetch_single_html(url_path: str):\n            response = await self.make_request(\"GET\", url_path, headers=self._get_headers())\n            return response.text if response else \"\"\n\n        tasks = [fetch_single_html(link) for link in links]\n        html_pages = await asyncio.gather(*tasks)\n        return {\"pages\": html_pages, \"date\": date}\n\n    def _get_headers(self) -> dict:\n        return {\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.9\",\n            \"Cache-Control\": \"no-cache\",\n            \"Connection\": \"keep-alive\",\n            \"Host\": \"www.sportinglife.com\",\n            \"Pragma\": \"no-cache\",\n            \"sec-ch-ua\": '\"Not/A)Brand\";v=\"99\", \"Google Chrome\";v=\"115\", \"Chromium\";v=\"115\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"Sec-Fetch-Dest\": \"document\",\n            \"Sec-Fetch-Mode\": \"navigate\",\n            \"Sec-Fetch-Site\": \"none\",\n            \"Sec-Fetch-User\": \"?1\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36\",\n            \"Referer\": \"https://www.sportinglife.com/racing/racecards\",\n        }\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of raw HTML strings into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"pages\"):\n            return []\n\n        try:\n            race_date = datetime.strptime(raw_data[\"date\"], \"%Y-%m-%d\").date()\n        except ValueError:\n            self.logger.error(\n                \"Invalid date format provided to SportingLifeAdapter\",\n                date=raw_data.get(\"date\"),\n            )\n            return []\n\n        all_races = []\n        for html in raw_data[\"pages\"]:\n            if not html:\n                continue\n            try:\n                soup = BeautifulSoup(html, \"html.parser\")\n\n                header = soup.select_one('h1[class*=\"RaceHeader__Title\"]')\n                if not header:\n                    self.logger.warning(\"Could not find race header.\")\n                    continue\n\n                header_text = clean_text(header.get_text())\n                parts = header_text.split()\n                race_time_str = parts[0]\n                track_name = \" \".join(parts[1:])\n\n                start_time = datetime.combine(race_date, datetime.strptime(race_time_str, \"%H:%M\").time())\n\n                race_number = 1\n                nav_links = soup.select('a[class*=\"SubNavigation__Link\"]')\n                active_link = soup.select_one('a[class*=\"SubNavigation__Link--active\"]')\n                if active_link and nav_links:\n                    try:\n                        race_number = nav_links.index(active_link) + 1\n                    except ValueError:\n                        self.logger.warning(\"Active race link not found in navigation links.\")\n\n                runners = [self._parse_runner(row) for row in soup.select('div[class*=\"RunnerCard\"]')]\n\n                race = Race(\n                    id=f\"sl_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\",\n                    venue=track_name,\n                    race_number=race_number,\n                    start_time=start_time,\n                    runners=[r for r in runners if r],\n                    source=self.source_name,\n                )\n                all_races.append(race)\n            except (AttributeError, ValueError) as e:\n                self.logger.warning(\n                    \"Error parsing a race from SportingLife, skipping race.\",\n                    exc_info=True,\n                )\n                continue\n        return all_races\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name_node = row.select_one('a[href*=\"/racing/profiles/horse/\"]')\n            if not name_node:\n                return None\n            name = clean_text(name_node.get_text()).splitlines()[0].strip()\n\n            num_node = row.select_one('span[class*=\"SaddleCloth__Number\"]')\n            if not num_node:\n                return None\n            num_str = clean_text(num_node.get_text())\n            number = int(\"\".join(filter(str.isdigit, num_str)))\n\n            odds_node = row.select_one('span[class*=\"Odds__Price\"]')\n            odds_str = clean_text(odds_node.get_text()) if odds_node else \"\"\n\n            win_odds = parse_odds_to_decimal(odds_str)\n            odds_data = (\n                {\n                    self.source_name: OddsData(\n                        win=win_odds,\n                        source=self.source_name,\n                        last_updated=datetime.now(),\n                    )\n                }\n                if win_odds and win_odds < 999\n                else {}\n            )\n            return Runner(number=number, name=name, odds=odds_data)\n        except (AttributeError, ValueError):\n            self.logger.warning(\"Failed to parse a runner on SportingLife, skipping runner.\")\n            return None\n",
    "web_service/backend/adapters/tvg_adapter.py": "# python_service/adapters/tvg_adapter.py\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom ..core.exceptions import AdapterConfigError\nfrom ..core.exceptions import AdapterParsingError\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass TVGAdapter(BaseAdapterV3):\n    \"\"\"Adapter for fetching US racing data from the TVG API, migrated to BaseAdapterV3.\"\"\"\n\n    SOURCE_NAME = \"TVG\"\n    BASE_URL = \"https://api.tvg.com/v2/races/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n        if not hasattr(config, \"TVG_API_KEY\") or not config.TVG_API_KEY:\n            raise AdapterConfigError(self.source_name, \"TVG_API_KEY is not configured.\")\n        self.tvg_api_key = config.TVG_API_KEY\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"Fetches all race details for a given date by first getting tracks.\"\"\"\n        headers = {\"X-Api-Key\": self.tvg_api_key}\n        summary_url = f\"summary?date={date}&country=USA\"\n\n        tracks_response = await self.make_request(\"GET\", summary_url, headers=headers)\n        if not tracks_response:\n            return None\n        tracks_data = tracks_response.json()\n\n        race_detail_tasks = []\n        for track in tracks_data.get(\"tracks\", []):\n            track_id = track.get(\"id\")\n            for race in track.get(\"races\", []):\n                race_id = race.get(\"id\")\n                if track_id and race_id:\n                    details_url = f\"{track_id}/{race_id}\"\n                    race_detail_tasks.append(self.make_request(\"GET\", details_url, headers=headers))\n\n        race_detail_responses = await asyncio.gather(*race_detail_tasks, return_exceptions=True)\n\n        # Filter out exceptions and return only successful responses\n        return [resp.json() for resp in race_detail_responses if resp and not isinstance(resp, Exception)]\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of detailed race JSON objects into Race models.\"\"\"\n        races = []\n        if not isinstance(raw_data, list):\n            self.logger.warning(\"raw_data is not a list, cannot parse TVG races.\")\n            return races\n\n        for race_detail in raw_data:\n            try:\n                if race := self._parse_race(race_detail):\n                    races.append(race)\n            except AdapterParsingError:\n                self.logger.warning(\n                    \"Failed to parse TVG race detail, skipping.\",\n                    race_detail=race_detail,\n                    exc_info=True,\n                )\n        return races\n\n    def _parse_race(self, race_detail: dict) -> Optional[Race]:\n        \"\"\"Parses a single detailed race JSON object into a Race model.\"\"\"\n        track = race_detail.get(\"track\")\n        race_info = race_detail.get(\"race\")\n\n        if not track or not race_info:\n            raise AdapterParsingError(self.source_name, \"Missing track or race info in race detail.\")\n\n        runners = []\n        for runner_data in race_detail.get(\"runners\", []):\n            if runner_data.get(\"scratched\"):\n                continue\n\n            odds = runner_data.get(\"odds\", {})\n            current_odds = odds.get(\"currentPrice\", {})\n            odds_str = current_odds.get(\"fractional\") or odds.get(\"morningLinePrice\", {}).get(\"fractional\")\n\n            try:\n                number = int(runner_data.get(\"programNumber\", \"0\").replace(\"A\", \"\"))\n            except (ValueError, TypeError):\n                self.logger.warning(f\"Could not parse program number: {runner_data.get('programNumber')}\")\n                continue\n\n            odds_data = {}\n            if odds_str:\n                win_odds = parse_odds_to_decimal(odds_str)\n                if win_odds and win_odds < 999:\n                    odds_data[self.source_name] = OddsData(\n                        win=win_odds,\n                        source=self.source_name,\n                        last_updated=datetime.now(),\n                    )\n\n            runners.append(\n                Runner(\n                    number=number,\n                    name=clean_text(runner_data.get(\"name\")),\n                    odds=odds_data,\n                    scratched=False,\n                )\n            )\n\n        if not runners:\n            raise AdapterParsingError(self.source_name, \"No non-scratched runners found.\")\n\n        post_time = race_info.get(\"postTime\")\n        if not post_time:\n            raise AdapterParsingError(self.source_name, \"Missing post time.\")\n\n        try:\n            start_time = datetime.fromisoformat(post_time.replace(\"Z\", \"+00:00\"))\n        except (ValueError, TypeError, AttributeError) as e:\n            raise AdapterParsingError(\n                self.source_name,\n                f\"Could not parse post time: {post_time}\",\n            ) from e\n\n        return Race(\n            id=f\"tvg_{track.get('code', 'UNK')}_{race_info.get('date', 'NODATE')}_{race_info.get('number', 0)}\",\n            venue=track.get(\"name\"),\n            race_number=race_info.get(\"number\"),\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n",
    "web_service/backend/api.py": "# web_service/backend/api.py\n# Reconstructed by Jules to merge features from python_service with web_service structure.\n\nimport asyncio\nimport os\nimport sys\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\nfrom datetime import date\nfrom typing import List, Optional\n\nimport structlog\nfrom fastapi import APIRouter, Depends, FastAPI, HTTPException, Query, Request, WebSocket\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\nfrom slowapi.middleware import SlowAPIMiddleware\nfrom slowapi.util import get_remote_address\nfrom starlette.websockets import WebSocketDisconnect\n\n# Corrected imports for web_service.backend\nfrom .config import get_settings\nfrom .engine import OddsEngine\nfrom .health import router as health_router\nfrom .logging_config import configure_logging\nfrom .middleware.error_handler import UserFriendlyException, user_friendly_exception_handler, validation_exception_handler\nfrom .models import AggregatedResponse, QualifiedRacesResponse, Race\nfrom .security import verify_api_key\n\nlog = structlog.get_logger()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manages application startup and shutdown events.\"\"\"\n    configure_logging()\n    log.info(\"Lifespan: Startup sequence initiated.\")\n\n    settings = get_settings()\n    engine = OddsEngine(config=settings)\n    app.state.engine = engine\n\n    log.info(\"Lifespan: Engine initialized successfully. Startup complete.\")\n    yield\n    log.info(\"Lifespan: Shutdown sequence initiated.\")\n    if hasattr(app.state, \"engine\") and app.state.engine:\n        try:\n            # CRITICAL: Close all browser sessions\n            await app.state.engine.shutdown()\n            log.info(\"Engine shutdown complete\")\n        except Exception as e:\n            log.error(f\"Error during shutdown: {e}\", exc_info=True)\n    log.info(\"Lifespan: Shutdown sequence complete.\")\n\n# --- FastAPI App Initialization ---\nrouter = APIRouter()\nlimiter = Limiter(key_func=get_remote_address)\napp = FastAPI(\n    title=\"Fortuna Faucet Web Service API\",\n    version=\"3.0\",\n    lifespan=lifespan,\n    docs_url=\"/api/docs\",\n    redoc_url=\"/api/redoc\",\n    openapi_url=\"/api/openapi.json\",\n)\n\n# Conditionally apply rate limiting middleware, disable in CI\n# The check is now more robust, looking for any truthy value.\nis_ci = os.environ.get(\"CI\", \"false\").lower() in (\"true\", \"1\", \"yes\")\nif not is_ci:\n    app.state.limiter = limiter\n    app.add_middleware(SlowAPIMiddleware)\n    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\nelse:\n    # In CI, we don't want rate limiting, so we provide a no-op limiter.\n    # The limiter instance is still required by endpoints even if not used.\n    log.info(\"CI environment detected. Rate limiting is disabled.\")\n    app.state.limiter = Limiter(key_func=get_remote_address, enabled=False)\napp.add_exception_handler(RequestValidationError, validation_exception_handler)\napp.add_exception_handler(UserFriendlyException, user_friendly_exception_handler)\nrouter.include_router(health_router)\n\n# Add CORS middleware for frontend development\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=get_settings().ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# --- Dependency Injection ---\ndef get_engine(request: Request) -> OddsEngine:\n    if not hasattr(request.app.state, \"engine\") or request.app.state.engine is None:\n        raise HTTPException(status_code=503, detail=\"The OddsEngine is not available.\")\n    return request.app.state.engine\n\n# --- API Endpoints (Restored and Adapted) ---\n\nfrom fastapi.responses import JSONResponse\n\n@router.get(\"/races\", response_model=AggregatedResponse)\n@limiter.limit(\"30/minute\")\nasync def get_races(\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    source: Optional[str] = None,\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n):\n    \"\"\"Fetches all race data for a given date from all or a specific source.\"\"\"\n    try:\n        if race_date is None:\n            race_date = date.today().strftime(\"%Y-%m-%d\")\n        return await engine.fetch_all_odds(race_date, source)\n    except Exception as e:\n        log.error(\"Unhandled exception in get_races endpoint\", exc_info=True, error=str(e))\n        return JSONResponse(\n            status_code=500,\n            content={\n                \"races\": [],\n                \"errors\": [{\n                    \"adapter_name\": \"FortunaEngine\",\n                    \"error_message\": f\"An unexpected server error occurred: {str(e)}\",\n                    \"attempted_url\": None\n                }],\n                \"source_info\": [],\n                \"metadata\": {\n                    \"fetch_time\": datetime.now().isoformat(),\n                    \"sources_queried\": 0,\n                    \"sources_successful\": 0,\n                    \"total_races\": 0,\n                    \"total_errors\": 1,\n                    \"data_freshness\": \"error\"\n                }\n            }\n        )\n\n@router.get(\"/races/qualified/tiny_field_trifecta\", response_model=QualifiedRacesResponse)\n@limiter.limit(\"120/minute\")\nasync def get_tiny_field_trifecta_races(\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n):\n    \"\"\"Fetches all race data and runs the tiny_field_trifecta analyzer to find qualified races.\"\"\"\n    if race_date is None:\n        race_date = date.today().strftime(\"%Y-%m-%d\")\n    response = await engine.fetch_all_odds(race_date)\n    races = [Race(**r) for r in response.get(\"races\", [])]\n\n    analyzer = engine.analyzer_engine.get_analyzer(\"tiny_field_trifecta\")\n    result = analyzer.qualify_races(races)\n\n    return QualifiedRacesResponse(qualified_races=result.get(\"races\", []), analysis_metadata=result.get(\"criteria\", {}))\n\n@router.get(\"/races/qualified/{analyzer_name}\", response_model=QualifiedRacesResponse)\n@limiter.limit(\"120/minute\")\nasync def get_qualified_races(\n    analyzer_name: str,\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n    # Example query parameters for an analyzer\n    max_field_size: int = Query(10, ge=3, le=20),\n    min_odds: float = Query(2.0, ge=1.0),\n):\n    \"\"\"Fetches all race data and runs a specific analyzer to find qualified races.\"\"\"\n    response = await engine.fetch_all_odds(race_date)\n    races = [Race(**r) for r in response.get(\"races\", [])]\n\n    try:\n        analyzer = engine.analyzer_engine.get_analyzer(analyzer_name, max_field_size=max_field_size, min_odds=min_odds)\n        result = analyzer.qualify_races(races)\n        return QualifiedRacesResponse(qualified_races=result.get(\"races\", []), analysis_metadata=result.get(\"criteria\", {}))\n    except ValueError:\n        raise HTTPException(status_code=404, detail=f\"Analyzer '{analyzer_name}' not found.\")\n\n\n# Add other endpoints as needed, following the pattern above.\n\napp.include_router(router, prefix=\"/api\")\n\n# Mount static files (frontend)\n# This logic ensures that the frontend is served both in development and in the frozen executable.\nstatic_dir = None\nif getattr(sys, 'frozen', False):\n    # Running in a PyInstaller bundle\n    static_dir = Path(sys.executable).parent / \"public\"\nelse:\n    # Running in a normal Python environment\n    static_dir = Path(__file__).parent.parent.joinpath(\"frontend\", \"public\")\n\nif static_dir and static_dir.exists():\n    app.mount(\"/\", StaticFiles(directory=static_dir, html=True), name=\"static\")\n\n    @app.middleware(\"http\")\n    async def spa_middleware(request: Request, call_next):\n        \"\"\"\n        Middleware to handle SPA routing. If a request is not for an API endpoint\n        and the file is not found, it serves index.html. This is crucial for\n        letting the frontend handle routing.\n        \"\"\"\n        response = await call_next(request)\n        # If a 404 is returned for a non-API, non-file path, serve the SPA index.\n        if response.status_code == 404 and not request.url.path.startswith(\"/api/\"):\n            # A simple check to avoid redirecting file requests (e.g. for .css, .js)\n            if \".\" not in request.url.path.split(\"/\")[-1]:\n                return FileResponse(static_dir / \"index.html\")\n        return response\nelse:\n    log.warning(f\"Static frontend directory not found at '{static_dir}'. The frontend will not be served.\")\n\n\n# --- Adapter Management Endpoints (v3.0.0) ---\n\nfrom typing import Dict, Any\n\nadapter_router = APIRouter()\n\n@adapter_router.get(\"/adapters/status\", response_model=List[Dict[str, Any]])\nasync def get_adapter_status_v3(\n    request: Request,\n    engine: OddsEngine = Depends(get_engine),\n):\n    \"\"\"\n    Get status of all adapters, including whether they require API keys.\n    This version is designed to be called by the adapter-aware script.\n    \"\"\"\n    try:\n        statuses = []\n        for name, adapter in engine.adapters.items():\n            statuses.append({\n                \"name\": name,\n                \"adapter_name\": name,\n                \"status\": \"active\",\n                \"enabled\": True,\n                \"requires_api_key\": _adapter_requires_key(adapter),\n                \"api_key_required\": _adapter_requires_key(adapter),\n            })\n        return statuses\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error fetching adapter status: {str(e)}\")\n\n@adapter_router.post(\"/adapters/disable\", response_model=Dict[str, Any])\nasync def disable_adapter(\n    payload: Dict[str, str],\n    request: Request,\n    engine: OddsEngine = Depends(get_engine),\n):\n    \"\"\"\n    Disable a specific adapter at runtime.\n    \"\"\"\n    adapter_name = payload.get(\"adapter_name\")\n    if not adapter_name:\n        raise HTTPException(status_code=400, detail=\"adapter_name is required\")\n\n    if adapter_name not in engine.adapters:\n        raise HTTPException(status_code=404, detail=f\"Adapter '{adapter_name}' not found\")\n\n    if not hasattr(engine, 'disabled_adapters'):\n        engine.disabled_adapters = set()\n    engine.disabled_adapters.add(adapter_name)\n\n    return {\"success\": True, \"message\": f\"Adapter '{adapter_name}' disabled\"}\n\ndef _adapter_requires_key(adapter) -> bool:\n    \"\"\"\n    Helper to determine if an adapter requires an API key.\n    Checks for common attributes and class name patterns.\n    \"\"\"\n    if not adapter or not hasattr(adapter, '__class__'):\n        return False\n\n    for attr in ['api_key_required', 'requires_api_key', 'requires_key']:\n        if hasattr(adapter, attr) and getattr(adapter, attr):\n            return True\n\n    key_indicators = ['betfair', 'tvg', 'equibase']\n    adapter_class_name = adapter.__class__.__name__.lower()\n    if any(indicator in adapter_class_name for indicator in key_indicators):\n        return True\n\n    return False\n\n# Include the new adapter router\nrouter.include_router(adapter_router)\n\n# Export app for Uvicorn\n__all__ = [\"app\"]\n",
    "web_service/backend/cache_manager.py": "# python_service/cache_manager.py\nimport asyncio\nimport hashlib\nimport json\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import wraps\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Optional\n\nimport structlog\n\ntry:\n    import redis\n\n    REDIS_AVAILABLE = True\nexcept ImportError:\n    REDIS_AVAILABLE = False\n\nlog = structlog.get_logger(__name__)\n\n\nclass CacheManager:\n    def __init__(self):\n        self.redis_client = None\n        self.memory_cache = {}\n        self.is_configured = False\n        log.info(\"CacheManager initialized (not connected).\")\n\n    async def connect(self, redis_url: str):\n        if self.is_configured or not REDIS_AVAILABLE or not redis_url:\n            return\n\n        try:\n            log.info(\"Attempting to connect to Redis...\", url=redis_url)\n            # Use the async version of the client\n            self.redis_client = redis.asyncio.from_url(redis_url, decode_responses=True)\n            await self.redis_client.ping()  # Verify connection asynchronously\n            self.is_configured = True\n            log.info(\"Redis cache connected successfully.\")\n        except (redis.exceptions.ConnectionError, asyncio.TimeoutError) as e:\n            log.warning(\n                \"Failed to connect to Redis. Falling back to in-memory cache.\",\n                error=str(e),\n            )\n            self.redis_client = None\n            self.is_configured = False\n\n    async def disconnect(self):\n        if self.redis_client:\n            await self.redis_client.close()\n            log.info(\"Redis connection closed.\")\n\n    def _generate_key(self, prefix: str, *args, **kwargs) -> str:\n        key_data = f\"{prefix}:{args}:{sorted(kwargs.items())}\"\n        return hashlib.md5(key_data.encode()).hexdigest()\n\n    async def get(self, key: str) -> Any | None:\n        if self.redis_client:\n            try:\n                value = await self.redis_client.get(key)\n                return json.loads(value) if value else None\n            except redis.exceptions.RedisError as e:\n                log.warning(\"Redis GET failed, falling back to memory cache.\", error=e)\n\n        entry = self.memory_cache.get(key)\n        if entry and entry.get(\"expires_at\", datetime.min) > datetime.now():\n            return entry.get(\"value\")\n        return None\n\n    async def set(self, key: str, value: Any, ttl_seconds: int = 300):\n        try:\n            serialized = json.dumps(value, default=str)\n        except (TypeError, ValueError) as e:\n            log.error(\"Failed to serialize value for caching.\", value=value, error=str(e))\n            return\n\n        if self.redis_client:\n            try:\n                await self.redis_client.setex(key, ttl_seconds, serialized)\n                return\n            except redis.exceptions.RedisError as e:\n                log.warning(\"Redis SET failed, falling back to memory cache.\", error=e)\n\n        self.memory_cache[key] = {\n            \"value\": value,\n            \"expires_at\": datetime.now() + timedelta(seconds=ttl_seconds),\n        }\n\n\n# --- Singleton Instance & Decorator ---\ncache_manager = CacheManager()\n\n\ndef cache_async_result(ttl_seconds: int = 300, key_prefix: str = \"cache\"):\n    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            instance_args = args[1:] if args and hasattr(args[0], func.__name__) else args\n            cache_key = cache_manager._generate_key(f\"{key_prefix}:{func.__name__}\", *instance_args, **kwargs)\n\n            cached_result = await cache_manager.get(cache_key)\n            if cached_result is not None:\n                log.debug(\"Cache hit\", function=func.__name__)\n                return cached_result\n\n            log.debug(\"Cache miss\", function=func.__name__)\n            result = await func(*args, **kwargs)\n\n            try:\n                await cache_manager.set(cache_key, result, ttl_seconds)\n            except Exception as e:\n                log.error(\"Failed to store result in cache.\", error=str(e), key=cache_key)\n\n            return result\n\n        return wrapper\n\n    return decorator\n\n\nclass StaleDataCache:\n    \"\"\"In-memory cache for storing the last known good data for a given date.\"\"\"\n\n    def __init__(self, max_age_hours: int = 24):\n        self._cache: dict[str, dict] = {}\n        self.max_age = timedelta(hours=max_age_hours)\n        self.logger = structlog.get_logger(cache_type=\"StaleDataCache\")\n\n    async def get(self, date_key: str) -> Optional[dict]:\n        \"\"\"\n        Retrieves stale data if it exists and is within the max_age.\n        Returns a dictionary with the data and its age, or None.\n        \"\"\"\n        entry = self._cache.get(date_key)\n        if not entry:\n            self.logger.debug(\"Cache miss\", key=date_key)\n            return None\n\n        now = datetime.utcnow()\n        timestamp = entry[\"timestamp\"]\n        age = now - timestamp\n\n        if age > self.max_age:\n            self.logger.warning(\"Cache entry expired\", key=date_key, age_hours=age.total_seconds() / 3600)\n            del self._cache[date_key]\n            return None\n\n        age_hours = age.total_seconds() / 3600\n        self.logger.info(\"Cache hit\", key=date_key, age_hours=round(age_hours, 2))\n        return {\"data\": entry[\"data\"], \"age_hours\": age_hours}\n\n    async def set(self, date_key: str, data: Any):\n        \"\"\"\n        Stores the latest successful data fetch for a given date.\n        \"\"\"\n        self.logger.info(\"Updating stale cache\", key=date_key)\n        self._cache[date_key] = {\n            \"timestamp\": datetime.utcnow(),\n            \"data\": data,\n        }\n",
    "web_service/backend/credentials_manager.py": "# python_service/credentials_manager.py\ntry:\n    import keyring\n\n    # This check is crucial for cross-platform compatibility\n    import keyring.backends.windows\n\n    IS_WINDOWS = True\nexcept ImportError:\n    keyring = None\n    IS_WINDOWS = False\n\n\nclass SecureCredentialsManager:\n    \"\"\"Manages secrets in the system's native credential store.\"\"\"\n\n    SERVICE_NAME = \"Fortuna\"\n\n    @staticmethod\n    def save_credential(account: str, secret: str) -> bool:\n        \"\"\"Saves a secret for a given account (e.g., 'api_key', 'betfair_username').\"\"\"\n        if not IS_WINDOWS:\n            print(\"Credential storage is only supported on Windows.\")\n            return False\n        try:\n            keyring.set_password(SecureCredentialsManager.SERVICE_NAME, account, secret)\n            return True\n        except Exception as e:\n            print(f\"\u274c Failed to save credential for {account}: {e}\")\n            return False\n\n    @staticmethod\n    def get_credential(account: str) -> str:\n        \"\"\"Retrieves a secret for a given account.\"\"\"\n        if not IS_WINDOWS:\n            return None\n        try:\n            return keyring.get_password(SecureCredentialsManager.SERVICE_NAME, account)\n        except Exception as e:\n            print(f\"\u274c Failed to retrieve credential for {account}: {e}\")\n            return None\n\n    @staticmethod\n    def get_betfair_credentials() -> tuple[str, str]:\n        \"\"\"Convenience method to retrieve both Betfair username and password.\"\"\"\n        username = SecureCredentialsManager.get_credential(\"betfair_username\")\n        password = SecureCredentialsManager.get_credential(\"betfair_password\")\n        return username, password\n\n    @staticmethod\n    def delete_credential(account: str):\n        \"\"\"Deletes a specific credential.\"\"\"\n        if not IS_WINDOWS:\n            return\n        try:\n            keyring.delete_password(SecureCredentialsManager.SERVICE_NAME, account)\n        except Exception:\n            pass\n",
    "web_service/backend/fortuna_windows_service.py": "# fortuna_windows_service.py\n\nimport logging\nimport os\nimport sys\n\nimport servicemanager\nimport win32event\nimport win32service\nimport win32serviceutil\n\n# Ensure the script's directory is at the front of the path\nscript_dir = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, script_dir)\n\ntry:\n    from fortuna_service import FortunaBackgroundService\nexcept ImportError as e:\n    # Log a detailed error to the Windows Event Log if the import fails\n    servicemanager.LogErrorMsg(f\"FATAL: Could not import FortunaBackgroundService. Error: {e}\")\n    sys.exit(1)  # Exit with an error code\n\n\nclass FortunaWindowsService(win32serviceutil.ServiceFramework):\n    _svc_name_ = \"FortunaV8Service\"\n    _svc_display_name_ = \"Fortuna V8 Racing Analysis Service\"\n    _svc_description_ = \"Continuously fetches and analyzes horse racing data.\"\n\n    def __init__(self, args):\n        win32serviceutil.ServiceFramework.__init__(self, args)\n        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)\n        self.fortuna_service = FortunaBackgroundService()\n        # Configure logging to use the Windows Event Log\n        logging.basicConfig(\n            level=logging.INFO,\n            format=\"%(name)s - %(levelname)s - %(message)s\",\n            handlers=[servicemanager.LogHandler()],\n        )\n\n    def SvcStop(self):\n        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\n        self.fortuna_service.stop()\n        win32event.SetEvent(self.hWaitStop)\n        self.ReportServiceStatus(win32service.SERVICE_STOPPED)\n\n    def SvcDoRun(self):\n        servicemanager.LogMsg(\n            servicemanager.EVENTLOG_INFORMATION_TYPE,\n            servicemanager.PYS_SERVICE_STARTED,\n            (self._svc_name_, \"\"),\n        )\n        self.main()\n\n    def main(self):\n        self.fortuna_service.start()\n        win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) == 1:\n        servicemanager.Initialize()\n        servicemanager.PrepareToHostSingle(FortunaWindowsService)\n        servicemanager.StartServiceCtrlDispatcher()\n    else:\n        win32serviceutil.HandleCommandLine(FortunaWindowsService)\n",
    "web_service/backend/main.py": "import sys\nfrom pathlib import Path\nimport uvicorn\nimport logging\nimport traceback\n\n# CRITICAL: Set up paths and logging for PyInstaller\nif getattr(sys, 'frozen', False):\n    # Running as compiled executable\n    PROJECT_ROOT = Path(sys.executable).parent\n    LOG_FILE = PROJECT_ROOT / 'fortuna-monolith.log'\n    # Redirect stdout and stderr to the log file to capture all output\n    sys.stdout = open(LOG_FILE, 'w', encoding='utf-8')\n    sys.stderr = sys.stdout\nelse:\n    # Running as script\n    PROJECT_ROOT = Path(__file__).parent.parent.parent\n    LOG_FILE = PROJECT_ROOT / 'fortuna-monolith-dev.log'\n\n# Configure logging to write to the log file and original stdout\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(LOG_FILE),\n        logging.StreamHandler(sys.__stdout__)\n    ]\n)\nlog = logging.getLogger(__name__)\n\n# Add project root to path\nif str(PROJECT_ROOT) not in sys.path:\n    sys.path.insert(0, str(PROJECT_ROOT))\nlog.info(f\"PROJECT_ROOT added to sys.path: {PROJECT_ROOT}\")\nlog.info(f\"Full sys.path: {sys.path}\")\n\n# Now that the path is set, we can import our application modules\nfrom web_service.backend.api import app\nfrom web_service.backend.config import get_settings\nfrom web_service.backend.port_check import check_port_and_exit_if_in_use\n\n\ndef main():\n    \"\"\"Main entry point for Fortuna Monolith.\"\"\"\n    try:\n        log.info(\"=\"*70)\n        log.info(\"\ud83d\ude80 Fortuna Monolith Initializing...\")\n        log.info(f\"Python Executable: {sys.executable}\")\n        log.info(f\"Working Directory: {Path.cwd()}\")\n        log.info(\"=\"*70)\n\n        settings = get_settings()\n\n        log.info(f\"Checking port {settings.FORTUNA_PORT} on host {settings.UVICORN_HOST}\")\n        check_port_and_exit_if_in_use(settings.FORTUNA_PORT, settings.UVICORN_HOST)\n        log.info(f\"Port {settings.FORTUNA_PORT} is available.\")\n\n        log.info(f\"Host: {settings.UVICORN_HOST}\")\n        log.info(f\"Port: {settings.FORTUNA_PORT}\")\n        log.info(f\"Mode: {'Frozen (Executable)' if getattr(sys, 'frozen', False) else 'Development'}\")\n        log.info(f\"Log file: {LOG_FILE}\")\n\n        log.info(\"Starting Uvicorn server...\")\n        uvicorn.run(\n            app,\n            host=settings.UVICORN_HOST,\n            port=settings.FORTUNA_PORT,\n            log_level=\"info\",\n            access_log=True,\n        )\n        log.info(\"Uvicorn server stopped gracefully.\")\n\n    except Exception as e:\n        log.critical(\"--- !!! A FATAL ERROR OCCURRED DURING STARTUP !!! ---\")\n        log.critical(traceback.format_exc())\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    # Multiprocessing support for PyInstaller\n    from multiprocessing import freeze_support\n    freeze_support()\n    main()\n",
    "web_service/backend/models_v3.py": "# python_service/models_v3.py\n# Defines the data structures for the V3 adapter architecture.\n\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import List\n\n\n@dataclass\nclass NormalizedRunner:\n    runner_id: str\n    name: str\n    saddle_cloth: str\n    odds_decimal: float\n\n\n@dataclass\nclass NormalizedRace:\n    race_key: str\n    track_key: str\n    start_time_iso: str\n    race_name: str\n    runners: List[NormalizedRunner] = field(default_factory=list)\n    source_ids: List[str] = field(default_factory=list)\n",
    "web_service/backend/monolith.py": "\"\"\"\nFortuna Monolith - Single executable frontend + backend\nProduction-grade with enhanced error handling, user-friendly startup, and better logging\n\nIMPORTANT: Uses WinForms instead of CEF for Python 3.10 compatibility\n(CEFPython3 v66.0 doesn't support Python 3.10.11)\n\"\"\"\nimport sys\nimport os\nfrom pathlib import Path\nimport logging\nimport io\nimport threading\nimport time\nimport json\nfrom contextlib import suppress\n\n# ====================================================================\n# CONSTANTS & CONFIGURATION\n# ====================================================================\nAPP_NAME = \"Fortuna Faucet\"\nAPP_VERSION = \"1.0.0\"\nAPI_HOST = \"127.0.0.1\"\nAPI_PORT = 8000\nBACKEND_STARTUP_TIMEOUT = 10\nHEALTH_CHECK_ATTEMPTS = 10\nHEALTH_CHECK_INTERVAL = 1\n\n# ====================================================================\n# LOGGING SETUP (BEFORE ANYTHING ELSE)\n# ====================================================================\ndef _get_log_file() -> Path:\n    \"\"\"Get log file path (works in both dev and frozen modes)\"\"\"\n    if getattr(sys, \"frozen\", False):\n        log_dir = Path(os.environ.get(\"TEMP\", \".\"))\n    else:\n        log_dir = Path(\".\")\n    return log_dir / \"fortuna-monolith.log\"\n\ndef _force_utf8_stream(stream):\n    \"\"\"Ensure stream uses UTF-8 encoding\"\"\"\n    if hasattr(stream, \"reconfigure\"):\n        with suppress(Exception):\n            stream.reconfigure(encoding=\"utf-8\", errors=\"replace\")\n            return stream\n\n    buffer = getattr(stream, \"buffer\", None)\n    if buffer is None:\n        return stream\n\n    with suppress(Exception):\n        return io.TextIOWrapper(buffer, encoding=\"utf-8\", errors=\"replace\")\n\n    return stream\n\ndef setup_logging():\n    \"\"\"Configure logging to both file and console\"\"\"\n    log_file = _get_log_file()\n\n    # Force UTF-8 on stdout/stderr\n    sys.stdout = _force_utf8_stream(sys.stdout)\n    sys.stderr = _force_utf8_stream(sys.stderr)\n\n    # Logging handlers\n    file_handler = logging.FileHandler(log_file, mode=\"w\", encoding=\"utf-8\")\n    console_handler = logging.StreamHandler(sys.stdout)\n\n    # Format with timestamps\n    formatter = logging.Formatter(\n        \"[%(levelname)-8s] %(asctime)s - %(message)s\",\n        datefmt=\"%H:%M:%S\"\n    )\n    file_handler.setFormatter(formatter)\n    console_handler.setFormatter(formatter)\n\n    # Setup root logger\n    logging.basicConfig(\n        level=logging.INFO,\n        handlers=[file_handler, console_handler],\n    )\n\n    logger = logging.getLogger(\"fortuna\")\n    return logger\n\nlogger = setup_logging()\n\n# Banner\nlogger.info(\"=\" * 70)\nlogger.info(f\"{APP_NAME} v{APP_VERSION} - Starting up\")\nlogger.info(\"=\" * 70)\nlogger.info(f\"Mode: {'Frozen EXE' if getattr(sys, 'frozen', False) else 'Development'}\")\nlogger.info(f\"Python: {sys.version.split()[0]}\")\n\n# ====================================================================\n# UI HELPERS (DEFINE BEFORE IMPORTS)\n# ====================================================================\ndef show_error_dialog(title: str, message: str):\n    \"\"\"Show error dialog (fallback if no GUI available)\"\"\"\n    try:\n        import tkinter as tk\n        from tkinter import messagebox\n        root = tk.Tk()\n        root.withdraw()\n        messagebox.showerror(title, message)\n    except:\n        # If tkinter fails, just log it\n        logger.error(f\"{title}: {message}\")\n\n# ====================================================================\n# FORCE PYINSTALLER TO INCLUDE DEPENDENCIES (TOP-LEVEL IMPORTS)\n# ====================================================================\nif False:  # Never executes, but PyInstaller sees the imports\n    import fastapi\n    import uvicorn\n    import webview\n    import pydantic\n    import starlette\n    import requests\n    from fastapi import FastAPI\n    from fastapi.staticfiles import StaticFiles\n    from fastapi.middleware.cors import CORSMiddleware\n    from fastapi.responses import FileResponse, JSONResponse\n\n# ====================================================================\n# IMPORT DEPENDENCIES WITH FRIENDLY ERROR HANDLING\n# ====================================================================\ndef _import_dependencies():\n    \"\"\"Import all required modules with descriptive error messages\"\"\"\n    try:\n        global uvicorn, webview, FastAPI, StaticFiles, CORSMiddleware, FileResponse, JSONResponse, requests\n\n        import requests\n        import uvicorn\n        import webview\n        from fastapi import FastAPI\n        from fastapi.staticfiles import StaticFiles\n        from fastapi.middleware.cors import CORSMiddleware\n        from fastapi.responses import FileResponse, JSONResponse\n\n        logger.info(\"OK - All dependencies loaded successfully\")\n        return True\n    except ImportError as e:\n        logger.critical(f\"FAILED - Missing dependency: {e}\")\n        show_error_dialog(\n            \"Missing Dependencies\",\n            f\"Could not load required library:\\n{str(e)}\\n\\n\"\n            \"Ensure all packages in requirements.txt are installed:\\n\"\n            \"pip install -r web_service/backend/requirements.txt\"\n        )\n        return False\n    except Exception as e:\n        logger.critical(f\"FAILED - Unexpected import error: {e}\", exc_info=True)\n        show_error_dialog(\n            \"Startup Error\",\n            f\"Unexpected error during startup:\\n{str(e)}\\n\\n\"\n            f\"Check the log file for details:\\n{_get_log_file()}\"\n        )\n        return False\n\nif not _import_dependencies():\n    sys.exit(1)\n\n# ====================================================================\n# UTILITY FUNCTIONS\n# ====================================================================\ndef get_resource_path(relative_path: str) -> Path:\n    \"\"\"Get absolute path to bundled resources\"\"\"\n    if getattr(sys, \"frozen\", False):\n        base_path = Path(sys._MEIPASS)\n    else:\n        base_path = Path(__file__).parent.parent.parent\n\n    full_path = base_path / relative_path\n    return full_path\n\n# ====================================================================\n# API CREATION\n# ====================================================================\ndef create_backend_api():\n    \"\"\"Create FastAPI instance with fallback support\"\"\"\n    api = FastAPI(title=\"Fortuna Backend\")\n\n    @api.get(\"/health\")\n    async def health():\n        \"\"\"Health check endpoint\"\"\"\n        return {\n            \"status\": \"ok\",\n            \"service\": \"fortuna-monolith\",\n            \"version\": APP_VERSION\n        }\n\n    try:\n        logger.info(\"Attempting to load full backend API...\")\n        from web_service.backend import api as backend_api\n\n        # Copy routes from full backend\n        for route in backend_api.app.routes:\n            api.routes.append(route)\n\n        logger.info(f\"OK - Full backend API loaded ({len(api.routes)} routes)\")\n        return api\n\n    except (ImportError, AttributeError) as e:\n        logger.warning(f\"Full backend import failed: {e}\")\n        logger.info(\"Running in minimal mode (basic endpoints only)\")\n\n        # Provide stub endpoints\n        @api.get(\"/races\")\n        async def get_races():\n            return {\n                \"status\": \"error\",\n                \"message\": \"Full API not available\",\n                \"sample\": [{\"id\": 1, \"name\": \"Example Race\", \"status\": \"pending\"}]\n            }\n\n        return api\n\n    except Exception as e:\n        logger.error(f\"Unexpected error loading backend: {e}\", exc_info=True)\n        return api\n\n# ====================================================================\n# APP CREATION\n# ====================================================================\ndef create_app():\n    \"\"\"Create main FastAPI application\"\"\"\n    logger.info(\"Creating FastAPI application...\")\n    app = FastAPI(title=\"Fortuna Monolith\")\n\n    # CORS for local development\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    logger.info(\"OK - CORS middleware configured\")\n\n    # Mount backend API\n    logger.info(\"Mounting backend API at /api...\")\n    backend = create_backend_api()\n    app.mount(\"/api\", backend, name=\"backend\")\n\n    # Setup frontend serving\n    frontend_path = get_resource_path(\"frontend_dist\")\n    index_file = frontend_path / \"index.html\"\n\n    logger.info(f\"Frontend path: {frontend_path}\")\n\n    if not frontend_path.exists():\n        logger.error(\"Frontend directory not found - app will run without UI\")\n\n        @app.get(\"/\")\n        async def fallback():\n            return JSONResponse(\n                {\"message\": \"Frontend not available\", \"api\": \"/api/health\"},\n                status_code=503\n            )\n        return app\n\n    # Mount static files\n    logger.info(\"Configuring static file serving...\")\n\n    # Mount Next.js build output\n    next_dir = frontend_path / \"_next\"\n    if next_dir.exists():\n        app.mount(\"/_next\", StaticFiles(directory=str(next_dir)), name=\"next\")\n        logger.info(\"OK - Static assets mounted\")\n\n    public_dir = frontend_path / \"public\"\n    if public_dir.exists():\n        app.mount(\"/public\", StaticFiles(directory=str(public_dir)), name=\"public\")\n\n    # SPA routing - catch all unmapped routes and serve index.html\n    @app.get(\"/{full_path:path}\")\n    async def serve_spa(full_path: str):\n        # Skip API routes\n        if full_path.startswith(\"api/\"):\n            return JSONResponse({\"error\": \"Not found\"}, status_code=404)\n\n        # Try exact file\n        file_path = frontend_path / full_path\n        try:\n            if file_path.is_file() and file_path.is_relative_to(frontend_path):\n                return FileResponse(file_path)\n        except (ValueError, RuntimeError):\n            pass\n\n        # Try with .html extension\n        html_path = frontend_path / f\"{full_path}.html\"\n        try:\n            if html_path.is_file() and html_path.is_relative_to(frontend_path):\n                return FileResponse(html_path)\n        except (ValueError, RuntimeError):\n            pass\n\n        # SPA fallback to index\n        if index_file.exists():\n            return FileResponse(index_file)\n\n        return JSONResponse({\"error\": \"Not found\"}, status_code=404)\n\n    logger.info(\"OK - SPA routing configured\")\n    return app\n\n# ====================================================================\n# BACKEND SERVER\n# ====================================================================\ndef run_backend():\n    \"\"\"Run Uvicorn server\"\"\"\n    try:\n        logger.info(\"-\" * 70)\n        logger.info(\"STARTING BACKEND SERVER\")\n        logger.info(f\"API: http://{API_HOST}:{API_PORT}\")\n        logger.info(\"-\" * 70)\n\n        app = create_app()\n\n        # Run Uvicorn\n        uvicorn.run(\n            app,\n            host=API_HOST,\n            port=API_PORT,\n            log_level=\"warning\",\n            access_log=False,\n        )\n    except OSError as e:\n        logger.critical(f\"Port {API_PORT} is already in use: {e}\")\n        raise\n    except Exception as e:\n        logger.critical(f\"Backend error: {e}\", exc_info=True)\n        raise\n\n# ====================================================================\n# HEALTH CHECKS\n# ====================================================================\ndef check_backend_health(max_attempts: int = HEALTH_CHECK_ATTEMPTS) -> bool:\n    \"\"\"Check if backend is responding\"\"\"\n    logger.info(\"Testing backend health...\")\n\n    for attempt in range(1, max_attempts + 1):\n        try:\n            response = requests.get(\n                f\"http://{API_HOST}:{API_PORT}/api/health\",\n                timeout=2\n            )\n\n            if response.status_code == 200:\n                data = response.json()\n                logger.info(f\"OK - Backend responding: {data}\")\n                return True\n\n        except requests.ConnectionError:\n            if attempt < max_attempts:\n                logger.debug(f\"Attempt {attempt}/{max_attempts} - waiting...\")\n                time.sleep(HEALTH_CHECK_INTERVAL)\n        except Exception as e:\n            logger.warning(f\"Health check error: {e}\")\n\n    logger.warning(f\"Backend did not respond after {max_attempts} attempts\")\n    return False\n\n# ====================================================================\n# MAIN APPLICATION\n# ====================================================================\ndef main():\n    \"\"\"Main entry point\"\"\"\n    try:\n        logger.info(\"-\" * 70)\n        logger.info(f\"STARTING {APP_NAME}\")\n        logger.info(\"-\" * 70)\n\n        # Start backend in background\n        logger.info(\"Starting backend server...\")\n        backend_thread = threading.Thread(target=run_backend, daemon=True)\n        backend_thread.start()\n        logger.info(\"OK - Backend thread started\")\n\n        # Wait for backend to initialize\n        logger.info(f\"Waiting for backend to be ready (max {BACKEND_STARTUP_TIMEOUT}s)...\")\n        time.sleep(2)\n\n        # Health check\n        backend_ready = check_backend_health()\n\n        if not backend_ready:\n            logger.warning(\"Backend not responding - launching UI anyway\")\n\n        # Launch UI\n        logger.info(\"-\" * 70)\n        logger.info(\"LAUNCHING USER INTERFACE\")\n        logger.info(\"-\" * 70)\n\n        try:\n            # Use WinForms GUI (default on Windows, compatible with Python 3.10)\n            # CEF is not used here to avoid Python version compatibility issues\n            webview.create_window(\n                title=APP_NAME,\n                url=f\"http://{API_HOST}:{API_PORT}\",\n                width=1400,\n                height=900,\n                resizable=True,\n                min_size=(800, 600),\n                background_color=\"#1a1a1a\",\n            )\n\n            logger.info(\"Starting webview event loop...\")\n            # Don't specify gui='cef' - let pywebview auto-detect WinForms\n            webview.start(debug=False)\n\n        except Exception as e:\n            logger.error(f\"Webview error: {e}\", exc_info=True)\n            # Fall back to browser message\n            logger.info(f\"Open http://{API_HOST}:{API_PORT} in your browser\")\n            input(\"Press ENTER to exit...\")\n\n        logger.info(f\"{APP_NAME} closed normally\")\n\n    except KeyboardInterrupt:\n        logger.info(\"Application interrupted by user\")\n    except Exception as e:\n        logger.critical(f\"Fatal error: {e}\", exc_info=True)\n        show_error_dialog(\n            f\"{APP_NAME} Error\",\n            f\"Application failed to start:\\n{str(e)}\\n\\n\"\n            f\"Please check the log file at:\\n{_get_log_file()}\"\n        )\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n",
    "web_service/backend/requirements-x86-constraints.txt": "# x86 Build Constraints - MANDATORY for successful x86 builds\n# These packages MUST be installed from pre-built wheels only\n#\n# USAGE:\n#   pip install --platform win32 --only-binary=:all: -r requirements-x86-constraints.txt\n#\n# The --only-binary=:all: flag ensures all packages come from wheels, not source.\n# If a wheel is not available, the installation will FAIL LOUDLY instead of\n# attempting to compile from source (which will fail silently on x86).\n\n# Database and ORM\nsqlalchemy==2.0.28\ngreenlet==3.0.3\n\n# Data Science Stack (use older versions with guaranteed x86 wheel availability)\npandas==1.5.3\nnumpy==1.23.5\nscipy==1.10.1\n\n# Note: These versions are older than the main requirements.txt to ensure\n# pre-built x86 wheels exist. This is a necessary trade-off for x86 support.\n",
    "web_service/backend/tests/__init__.py": "",
    "web_service/backend/utils/text.py": "# python_service/utils/text.py\n# Centralized text and name normalization utilities\nimport re\nfrom typing import Optional\n\n\ndef clean_text(text: Optional[str]) -> Optional[str]:\n    \"\"\"Strips leading/trailing whitespace and collapses internal whitespace.\"\"\"\n    if not text:\n        return None\n    return \" \".join(text.strip().split())\n\n\ndef normalize_venue_name(name: Optional[str]) -> Optional[str]:\n    \"\"\"\n    Normalizes a UK or Irish racecourse name to a standard format.\n    Handles common abbreviations and variations.\n    \"\"\"\n    if not name:\n        return None\n\n    # Use a temporary variable for matching, but return the properly cased name\n    cleaned_name_upper = clean_text(name).upper()\n\n    VENUE_MAP = {\n        \"ASCOT\": \"Ascot\",\n        \"AYR\": \"Ayr\",\n        \"BANGOR-ON-DEE\": \"Bangor-on-Dee\",\n        \"CATTERICK BRIDGE\": \"Catterick\",\n        \"CHELMSFORD CITY\": \"Chelmsford\",\n        \"EPSOM DOWNS\": \"Epsom\",\n        \"FONTWELL\": \"Fontwell Park\",\n        \"HAYDOCK\": \"Haydock Park\",\n        \"KEMPTON\": \"Kempton Park\",\n        \"LINGFIELD\": \"Lingfield Park\",\n        \"NEWMARKET (ROWLEY)\": \"Newmarket\",\n        \"NEWMARKET (JULY)\": \"Newmarket\",\n        \"SANDOWN\": \"Sandown Park\",\n        \"STRATFORD\": \"Stratford-on-Avon\",\n        \"YARMOUTH\": \"Great Yarmouth\",\n        \"CURRAGH\": \"Curragh\",\n        \"DOWN ROYAL\": \"Down Royal\",\n    }\n\n    # Check primary map first\n    if cleaned_name_upper in VENUE_MAP:\n        return VENUE_MAP[cleaned_name_upper]\n\n    # Handle cases where the key is the desired output but needs to be mapped from a variation\n    # e.g. CHELMSFORD maps to Chelmsford\n    # Title case the cleaned name for a sensible default\n    title_cased_name = clean_text(name).title()\n    if title_cased_name in VENUE_MAP.values():\n        return title_cased_name\n\n    # Return the title-cased cleaned name as a fallback\n    return title_cased_name\n\n\ndef normalize_course_name(name: str) -> str:\n    if not name:\n        return \"\"\n    name = name.lower().strip()\n    name = re.sub(r\"[^a-z0-9\\s-]\", \"\", name)\n    name = re.sub(r\"[\\s-]+\", \"_\", name)\n    return name\n",
    "web_service/frontend/app/components/AdapterStatusPanel.tsx": "// web_platform/frontend/src/components/AdapterStatusPanel.tsx\n'use client';\n\nimport React from 'react';\nimport { SourceInfo } from '../types/racing';\n\ninterface AdapterStatusPanelProps {\n  adapter: SourceInfo;\n  onFetchRaces: (sourceName: string) => void;\n}\n\nexport const AdapterStatusPanel: React.FC<AdapterStatusPanelProps> = ({ adapter, onFetchRaces }) => {\n  const isConfigured = adapter.status !== 'CONFIG_ERROR';\n\n  return (\n    <div className={`p-4 rounded-lg border ${isConfigured ? 'bg-slate-800 border-slate-700' : 'bg-yellow-900/20 border-yellow-700/50'}`}>\n      <div className=\"flex justify-between items-center\">\n        <h3 className=\"font-bold text-lg text-white\">{adapter.name}</h3>\n        <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${isConfigured ? 'bg-green-500/20 text-green-300' : 'bg-yellow-500/20 text-yellow-300'}`}>\n          {isConfigured ? 'Ready' : 'Not Configured'}\n        </span>\n      </div>\n      <div className=\"mt-4 flex gap-2\">\n        <button\n          onClick={() => onFetchRaces(adapter.name)}\n          disabled={!isConfigured}\n          className=\"flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-slate-700 disabled:text-slate-400 disabled:cursor-not-allowed\"\n        >\n          Automatic Load\n        </button>\n        <button\n          disabled\n          className=\"flex-1 px-4 py-2 bg-slate-700 text-slate-400 rounded cursor-not-allowed\"\n        >\n          Manual Entry (Coming Soon)\n        </button>\n      </div>\n    </div>\n  );\n};\n",
    "web_service/frontend/app/components/ManualOverridePanel.tsx": "// web_platform/frontend/src/components/ManualOverridePanel.tsx\nimport React, { useState } from 'react';\nimport { Race } from '../types/racing';\n\ninterface ManualOverridePanelProps {\n  adapterName: string;\n  attemptedUrl: string;\n  apiKey: string | null;\n  onParseSuccess: (adapterName: string, parsedRaces: Race[]) => void;\n}\n\nconst ManualOverridePanel: React.FC<ManualOverridePanelProps> = ({\n  adapterName,\n  attemptedUrl,\n  apiKey,\n  onParseSuccess,\n}) => {\n  const [showPanel, setShowPanel] = useState(true);\n  const [htmlContent, setHtmlContent] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleSubmit = async () => {\n    if (!htmlContent.trim()) {\n      setError('HTML content cannot be empty.');\n      return;\n    }\n    if (!apiKey) {\n      setError('API key is not available. Cannot submit.');\n      return;\n    }\n\n    setIsSubmitting(true);\n    setError(null);\n\n    try {\n      const response = await fetch('/api/races/parse-manual', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': apiKey,\n        },\n        body: JSON.stringify({\n          adapter_name: adapterName,\n          html_content: htmlContent,\n        }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to parse HTML.');\n      }\n\n      const parsedRaces: Race[] = await response.json();\n      onParseSuccess(adapterName, parsedRaces);\n      setShowPanel(false); // Hide panel on success\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred.';\n      setError(errorMessage);\n      console.error('Manual parse submission failed:', err);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n\n  if (!showPanel) {\n    return null;\n  }\n\n  return (\n    <div className=\"bg-red-900 bg-opacity-50 border border-red-700 p-4 rounded-lg shadow-lg mb-4\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h3 className=\"font-bold text-red-300\">Data Fetch Failed: {adapterName}</h3>\n          <p className=\"text-sm text-red-400\">\n            The application failed to automatically retrieve data from:{' '}\n            <a href={attemptedUrl} target=\"_blank\" rel=\"noopener noreferrer\" className=\"underline hover:text-red-200\">\n              {attemptedUrl}\n            </a>\n          </p>\n        </div>\n        <button onClick={() => setShowPanel(false)} className=\"text-red-400 hover:text-red-200 text-2xl\">&times;</button>\n      </div>\n      <div className=\"mt-4\">\n        <p className=\"text-sm text-red-300 mb-2\">\n          <strong>To resolve this:</strong>\n          <ol className=\"list-decimal list-inside pl-4\">\n            <li>Click the link above to open the page in a new tab.</li>\n            <li>Right-click on the page and select \"View Page Source\".</li>\n            <li>Copy the entire HTML source code.</li>\n            <li>Paste the code into the text area below and click \"Submit Manual Data\".</li>\n          </ol>\n        </p>\n        <textarea\n          className=\"w-full h-24 p-2 bg-gray-900 border border-gray-700 rounded text-gray-300 font-mono text-xs\"\n          placeholder={`Paste HTML source for ${adapterName} here...`}\n          value={htmlContent}\n          onChange={(e) => setHtmlContent(e.target.value)}\n          disabled={isSubmitting}\n        />\n        {error && <p className=\"text-red-400 text-sm mt-2\">{error}</p>}\n        <div className=\"mt-2 flex gap-2\">\n          <button\n            onClick={handleSubmit}\n            className=\"px-3 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm disabled:bg-blue-800 disabled:cursor-not-allowed\"\n            disabled={isSubmitting}\n          >\n            {isSubmitting ? 'Submitting...' : 'Submit Manual Data'}\n          </button>\n          <button\n            onClick={() => setShowPanel(false)}\n            className=\"px-3 py-1.5 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm\"\n          >\n            Skip for Now\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ManualOverridePanel;\n",
    "web_service/frontend/app/components/SettingsPage.tsx": "// src/components/SettingsPage.tsx\n'use client';\n\nimport React, { useState, useEffect } from 'react';\n\nexport function SettingsPage() {\n  const [apiKey, setApiKey] = useState('');\n  const [betfairAppKey, setBetfairAppKey] = useState('');\n  const [betfairUsername, setBetfairUsername] = useState('');\n  const [betfairPassword, setBetfairPassword] = useState('');\n\n  useEffect(() => {\n    // Fetch the current API key when the component mounts\n    const fetchApiKey = async () => {\n      if (window.electronAPI?.getApiKey) {\n        const key = await window.electronAPI.getApiKey();\n        if (key) {\n          setApiKey(key);\n        }\n      }\n    };\n    fetchApiKey();\n  }, []);\n\n  const handleGenerateApiKey = async () => {\n    if (window.electronAPI?.generateApiKey) {\n      const newKey = await window.electronAPI.generateApiKey();\n      setApiKey(newKey);\n    }\n  };\n\n  const handleSaveSettings = async () => {\n    if (window.electronAPI?.saveApiKey && window.electronAPI?.saveBetfairCredentials) {\n      await window.electronAPI.saveApiKey(apiKey);\n      await window.electronAPI.saveBetfairCredentials({\n        appKey: betfairAppKey,\n        username: betfairUsername,\n        password: betfairPassword,\n      });\n      alert('Settings saved successfully!');\n    }\n  };\n\n  return (\n    <div className=\"bg-slate-800 p-8 rounded-lg border border-slate-700 text-white max-w-2xl mx-auto\">\n      <h2 className=\"text-3xl font-bold text-white mb-6\">Application Settings</h2>\n\n      <div className=\"space-y-8\">\n        <div>\n          <h3 className=\"text-xl font-semibold text-slate-300 mb-2\">API Key</h3>\n          <p className=\"text-sm text-slate-400 mb-3\">This key is required for the dashboard to communicate with the backend service.</p>\n          <div className=\"flex items-center space-x-2\">\n            <input\n              type=\"text\"\n              readOnly\n              value={apiKey}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 font-mono text-sm\"\n            />\n            <button\n              onClick={handleGenerateApiKey}\n              className=\"px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition-colors font-semibold\"\n            >\n              Generate New Key\n            </button>\n          </div>\n        </div>\n\n        <div>\n          <h3 className=\"text-xl font-semibold text-slate-300 mb-2\">Betfair Credentials (Optional)</h3>\n           <p className=\"text-sm text-slate-400 mb-3\">Required for adapters that use the Betfair Exchange API.</p>\n          <div className=\"space-y-3\">\n            <input\n              type=\"password\"\n              placeholder=\"App Key\"\n              value={betfairAppKey}\n              onChange={(e) => setBetfairAppKey(e.target.value)}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 placeholder-slate-500\"\n            />\n            <input\n              type=\"text\"\n              placeholder=\"Username\"\n              value={betfairUsername}\n              onChange={(e) => setBetfairUsername(e.target.value)}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 placeholder-slate-500\"\n            />\n            <input\n              type=\"password\"\n              placeholder=\"Password\"\n              value={betfairPassword}\n              onChange={(e) => setBetfairPassword(e.target.value)}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 placeholder-slate-500\"\n            />\n          </div>\n        </div>\n\n        <div className=\"flex justify-end pt-6 border-t border-slate-700\">\n          <button\n            onClick={handleSaveSettings}\n            className=\"px-8 py-3 bg-green-600 hover:bg-green-700 rounded font-bold text-lg transition-colors\"\n          >\n            Save All Settings\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
    "web_service/frontend/app/hooks/useRealTimeRaces.ts": "import { useState, useEffect } from 'react';\nimport { io, Socket } from 'socket.io-client';\nimport { Race } from '../types/racing';\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';\n\nexport function useRealTimeRaces() {\n  const [races, setRaces] = useState<Race[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n\n  useEffect(() => {\n    const socket: Socket = io(API_URL);\n\n    socket.on('connect', () => setIsConnected(true));\n    socket.on('disconnect', () => setIsConnected(false));\n\n    socket.on('races_update', (data: { races: Race[] }) => {\n      if (data && Array.isArray(data.races)) {\n        setRaces(data.races);\n      }\n    });\n\n    // Cleanup on component unmount\n    return () => {\n      socket.disconnect();\n    };\n  }, []);\n\n  return { races, isConnected };\n}",
    "web_service/frontend/app/types/electron.d.ts": "// web_platform/frontend/src/types/electron.d.ts\n\n/**\n * This declaration file extends the global Window interface to include the\n * 'electronAPI' object exposed by the preload script. This provides\n * TypeScript with type information for the functions we're using for IPC.\n */\nexport {};\n\ndeclare global {\n  interface Window {\n    electronAPI?: {\n      /**\n       * Asynchronously fetches the secure API key from the main process.\n       * @returns {Promise<string|null>} A promise that resolves with the API key or null if not found.\n       */\n      getApiKey: () => Promise<string | null>;\n      /**\n       * Registers a callback for backend status updates from the main process.\n       * @param callback The function to execute. Receives an object with state and logs.\n       * @returns A function to unsubscribe the listener.\n       */\n      onBackendStatusUpdate: (callback: (status: { state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }) => void) => () => void;\n\n      /**\n       * Sends a command to the main process to restart the backend executable.\n       */\n      restartBackend: () => void;\n\n      /**\n       * Asynchronously fetches the current backend status from the main process.\n       * @returns {Promise<{ state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }>}\n       */\n      getBackendStatus: () => Promise<{ state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }>;\n      generateApiKey: () => Promise<string>;\n      saveApiKey: (apiKey: string) => Promise<{ success: boolean }>;\n      saveBetfairCredentials: (credentials: { appKey: string; username: string; password: string }) => Promise<{ success: boolean }>;\n      getApiPort: () => Promise<number | null>;\n    };\n  }\n}\n",
    "web_service/frontend/next.config.mjs": "/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',  // Critical for static HTML export\n  distDir: 'out',\n  trailingSlash: true,\n  images: {\n    unoptimized: true  // Required for static export\n  },\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*',\n        destination: 'http://127.0.0.1:8000/api/:path*',\n      },\n    ]\n  },\n};\n\nexport default nextConfig;\n",
    "web_service/frontend/postcss.config.js": "module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};",
    "wix/product.wxs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\"\n     xmlns:util=\"http://schemas.microsoft.com/wix/UtilExtension\">\n\n  <Product\n    Id=\"*\"\n    Name=\"Fortuna Faucet - Racing Analysis Engine\"\n    Language=\"1033\"\n    Version=\"$(var.Version)\"\n    Manufacturer=\"Mason J0 Studios\"\n    UpgradeCode=\"12345678-1234-1234-1234-123456789012\">\n\n    <Package\n      InstallerVersion=\"200\"\n      Compressed=\"yes\"\n      InstallScope=\"perMachine\"\n      Platform=\"x64\"\n      Description=\"Horse racing analysis platform\"\n      Comments=\"Professional-grade installer\"/>\n\n    <Media Id=\"1\" Cabinet=\"fortuna.cab\" EmbedCab=\"yes\"/>\n\n    <!-- Directory Structure -->\n    <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n      <Directory Id=\"ProgramFiles64Folder\">\n        <Directory Id=\"INSTALLFOLDER\" Name=\"Fortuna Faucet\">\n        </Directory>\n      </Directory>\n      <Directory Id=\"ProgramMenuFolder\">\n        <Directory Id=\"ApplicationProgramsFolder\" Name=\"Fortuna Faucet\"/>\n      </Directory>\n    </Directory>\n\n    <!-- Environment Variable -->\n    <ComponentGroup Id=\"EnvironmentComponentGroup\" Directory=\"INSTALLFOLDER\">\n      <Component Id=\"FortunaPortEnvironmentVar\" Guid=\"*\">\n        <Environment Id=\"FortunaPort\" Name=\"FORTUNA_PORT\" Value=\"8000\" Permanent=\"no\" Action=\"set\" System=\"yes\" />\n        <RegistryValue Root=\"HKLM\" Key=\"Software\\Fortuna Faucet\" Name=\"Path\" Type=\"string\" Value=\"[INSTALLFOLDER]\" KeyPath=\"yes\" />\n      </Component>\n    </ComponentGroup>\n\n    <!-- Features -->\n    <!-- Service Installation -->\n    <ComponentGroup Id=\"ServiceComponentGroup\" Directory=\"INSTALLFOLDER\">\n        <Component Id=\"FortunaBackendService\" Guid=\"*\">\n            <File Id=\"fortuna-backend.exe\" Source=\"$(var.BackendPath)\" KeyPath=\"yes\" />\n            <ServiceInstall\n                Id=\"FortunaServiceInstall\"\n                Type=\"ownProcess\"\n                Name=\"Fortuna\"\n                DisplayName=\"Fortuna Faucet Backend\"\n                Description=\"Data aggregation and analysis engine for horse racing.\"\n                Start=\"auto\"\n                Account=\"LocalSystem\"\n                ErrorControl=\"normal\" />\n            <ServiceControl Id=\"StartFortunaService\" Start=\"install\" Stop=\"uninstall\" Remove=\"uninstall\" Name=\"Fortuna\" Wait=\"no\" />\n        </Component>\n    </ComponentGroup>\n\n    <Feature Id=\"ProductFeature\" Title=\"Fortuna Faucet\" Level=\"1\">\n        <ComponentGroupRef Id=\"BackendFileGroup\"/>\n        <ComponentGroupRef Id=\"FrontendFileGroup\"/>\n        <ComponentGroupRef Id=\"ShortcutsComponentGroup\"/>\n        <ComponentGroupRef Id=\"EnvironmentComponentGroup\"/>\n        <ComponentGroupRef Id=\"ServiceComponentGroup\"/>\n    </Feature>\n\n    <!-- Shortcuts -->\n    <ComponentGroup Id=\"ShortcutsComponentGroup\" Directory=\"ApplicationProgramsFolder\">\n      <Component Id=\"ApplicationShortcuts\" Guid=\"*\">\n          <util:InternetShortcut Id=\"DashboardShortcut\" Name=\"Fortuna Faucet Dashboard\" Target=\"http://localhost:3000\"/>\n          <Shortcut Id=\"UninstallShortcut\" Name=\"Uninstall Fortuna Faucet\" Description=\"Remove this application\" Target=\"[SystemFolder]msiexec.exe\" Arguments=\"/x [ProductCode]\" Advertise=\"no\"/>\n          <RemoveFolder Id=\"ApplicationProgramsFolder\" On=\"uninstall\"/>\n          <RegistryValue Root=\"HKCU\" Key=\"Software\\Fortuna Faucet\" Name=\"Installed\" Type=\"integer\" Value=\"1\" KeyPath=\"yes\"/>\n      </Component>\n    </ComponentGroup>\n\n    <!-- UI -->\n    <UI>\n      <UIRef Id=\"WixUI_CustomInstallDir\" />\n    </UI>\n    <UIRef Id=\"WixUI_Common\" />\n    <Property Id=\"WIXUI_INSTALLDIR\" Value=\"INSTALLFOLDER\" />\n    <WixVariable Id=\"WixUILicenseRtf\" Value=\"electron\\assets\\license.rtf\"/>\n    <WixVariable Id=\"WixUIBannerBmp\" Value=\"electron\\assets\\banner.bmp\"/>\n    <WixVariable Id=\"WixUIDialogBmp\" Value=\"electron\\assets\\dialog.bmp\"/>\n\n    <Condition Message=\"Windows 7 or later (64-bit) is required\">\n      <![CDATA[Installed OR (VersionNT64 >= 601)]]>\n    </Condition>\n\n  </Product>\n</Wix>\n"
}