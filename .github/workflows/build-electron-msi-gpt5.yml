# System Timestamp: 2025-12-07 15:30:00
name: ðŸ”¨ Build Electron MSI Installer (Production)

on:
  push:
    branches: ["main"]

concurrency:
  group: build-electron-msi-${{ github.ref }}
  cancel-in-progress: false

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  ELECTRON_BUILDER_CACHE: ${{ github.workspace }}/.cache/electron-builder
  BACKEND_DIR: 'python_service'
  PYTHONUTF8: '1'

jobs:
  validate-environment:
    name: âœ… Pre-flight Validation
    runs-on: windows-latest
    timeout-minutes: 5
    outputs:
      node_version: ${{ steps.versions.outputs.node }}
      python_version: ${{ steps.versions.outputs.python }}
      build_id: ${{ steps.versions.outputs.build_id }}
      semver: ${{ steps.meta.outputs.semver }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ” Verify Critical Files Exist
        shell: pwsh
        run: |
          # FIX: Removed dynamic spec file from check
          $criticalFiles = @(
            'electron/electron-builder-config.yml',
            'web_platform/frontend/package.json',
            '${{ env.BACKEND_DIR }}/requirements-dev.txt',
            'electron/package.json'
          )

          $manifest = @{
            timestamp = Get-Date -Format 'o'
            checks = @()
            errors = @()
          }

          foreach ($file in $criticalFiles) {
            if (Test-Path -LiteralPath $file) {
              $hash = (Get-FileHash -LiteralPath $file -Algorithm SHA256).Hash
              $manifest.checks += @{
                file = $file
                exists = $true
                sha256 = $hash
              }
              Write-Host "âœ“ $file ($hash.Substring(0,8)...)"
            } else {
              $manifest.errors += @{ file = $file; error = 'MISSING' }
              Write-Error "âœ— CRITICAL: $file not found"
              exit 1
            }
          }

          $manifest | ConvertTo-Json | Out-File -FilePath ".\\validation-manifest.json"
          Write-Host "Manifest saved"

      - name: ðŸ“Š Capture Version Information
        id: versions
        shell: pwsh
        run: |
          $nodeVersion = node --version
          $pythonVersion = python --version
          $buildId = "${{ github.run_id }}-${{ github.run_attempt }}"

          Write-Host "Node: $nodeVersion"
          Write-Host "Python: $pythonVersion"
          Write-Host "Build ID: $buildId"

          "node=$nodeVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "python=$pythonVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "build_id=$buildId" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: ðŸš¨ Capture Environment State
        if: always()
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path "debug-artifacts" -Force | Out-Null

          # System info
          systeminfo | Out-File "debug-artifacts/systeminfo.txt"
          Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber | Out-File "debug-artifacts/os-version.txt"

          # Disk space
          Get-Volume | Out-File "debug-artifacts/disk-space.txt"

          # File permissions - FIX: $. to $_.
          Get-ChildItem -Recurse -Include "*.yml", "*.spec", "*.json" -ErrorAction SilentlyContinue |
            ForEach-Object { "{0} {1}" -f $_.FullName, $_.Length } |
            Out-File "debug-artifacts/file-manifest.txt"

      - name: Derive Build Metadata
        id: meta
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ref = "${{ github.ref }}"
          if ($ref -like 'refs/tags/v*') {
            $semver = $ref -replace 'refs/tags/v', ''
          } else {
            $semver = "0.0.${{ github.run_number }}"
          }
          $shortSha = "${{ github.sha }}".Substring(0,7)
          "semver=$semver" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "short_sha=$shortSha" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "ðŸ”– Version: $semver ($shortSha)"

      - name: ðŸ“¤ Upload Validation Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-${{ github.run_id }}
          path: |
            validation-manifest.json
            debug-artifacts/
          retention-days: 14

  build-python-service:
    name: ðŸ Build Python Service Bundle
    runs-on: windows-latest
    timeout-minutes: 20
    needs: validate-environment
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: ðŸ“¦ Install Python Dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -r ${{ env.BACKEND_DIR }}/requirements-dev.txt
          Write-Host "âœ“ Python dependencies installed"

      - name: ðŸ§ª Run Unit Tests (TDD Integration)
        shell: pwsh
        run: |
          Write-Host "Installing Test Dependencies..."
          pip install pytest pytest-asyncio

          Write-Host "Running Test Suite..."
          # This will run all tests in the 'tests/' directory using configuration from pytest.ini
          # If this step fails, the build stops here (Shift Left).
          pytest

      - name: â˜¢ï¸ NUCLEAR FIX -- Ensure Python Package Structure & Double Injection
        shell: pwsh
        run: |
          # FIX: init.py -> __init__.py
          Set-Content -Path "python_service/__init__.py" -Value "# This file is intentionally non-empty to ensure package recognition."
          Write-Host "âœ… Ensured non-empty __init__.py files exist for package discovery."

      - name: Create Dynamic fortuna-backend-electron.spec for PyInstaller
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $entry_point = '${{ env.BACKEND_DIR }}/main.py'.Replace('\\', '/')
          $other_service = "web_service"

          # Ensure absolute paths for the init files - FIX: init.py -> __init__.py
          $backend_init = (Resolve-Path "python_service/__init__.py").Path.Replace('\\', '/')

          $specContent = @(
            "# -- mode: python ; coding: utf-8 --",
            "import os",
            "from pathlib import Path",
            "from PyInstaller.utils.hooks import collect_data_files, collect_submodules",
            "",
            "block_cipher = None",
            "project_root = Path(os.getcwd())",
            "",
            "datas = []",
            "datas += collect_data_files('uvicorn')",
            "datas += collect_data_files('slowapi')",
            "datas += collect_data_files('structlog')",
            "",
            "hiddenimports = collect_submodules('python_service')",
            "hiddenimports += [",
            " 'uvicorn.logging', 'uvicorn.loops.auto', 'uvicorn.lifespan.on',",
            " 'uvicorn.protocols.http.h11_impl', 'uvicorn.protocols.websockets.wsproto_impl',",
            " 'fastapi.routing', 'starlette.staticfiles', 'anyio._backends._asyncio',",
            " 'httpcore', 'httpx', 'slowapi', 'structlog', 'tenacity', 'aiosqlite',",
            " 'pydantic_core'",
            "]",
            "",
            "a = Analysis(",
            " ['$entry_point'],",
            " pathex=[str(project_root)],",
            " binaries=[],",
            " datas=datas,",
            " hiddenimports=hiddenimports,",
            " hookspath=[],",
            " runtime_hooks=[],",
            " excludes=['tests', 'pytest', '$other_service'],",
            " win_no_prefer_redirects=False,",
            " win_private_assemblies=False,",
            " cipher=block_cipher,",
            " noarchive=False",
            ")",
            "",
            "# â˜¢ï¸ NUCLEAR OVERRIDE: Force init files into the PYZ archive",
            "a.pure += [",
            " ('python_service', '$backend_init', 'PYMODULE')",
            "]",
            "",
            "pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)",
            "exe = EXE(",
            " pyz,",
            " a.scripts,",
            " a.binaries,",
            " a.zipfiles,",
            " a.datas,",
            " [],",
            " name='fortuna-backend',",
            " debug=False,",
            " bootloader_ignore_signals=False,",
            " strip=False,",
            " upx=True,",
            " runtime_tmpdir=None,",
            " console=True,",
            " disable_windowed_traceback=False,",
            " argv_emulation=False,",
            " target_arch=None,",
            " codesign_identity=None,",
            " entitlements_file=None",
            ")"
          )
          Set-Content -Path "fortuna-backend-electron.spec" -Value $specContent
          Write-Host "âœ… Dynamically generated 'fortuna-backend-electron.spec' with PYZ Injection."

      - name: ðŸ”¨ Build Python Service with PyInstaller
        shell: pwsh
        run: |
          $specFile = 'fortuna-backend-electron.spec'

          if (-not (Test-Path $specFile)) {
            Write-Error "Spec file not found: $specFile"
            exit 1
          }

          pyinstaller `
            --distpath ".\\dist\\service" `
            --workpath ".\\build\\service" `
            --clean `
            $specFile

          if ($LASTEXITCODE -ne 0) {
            Write-Error "PyInstaller failed with code $LASTEXITCODE"
            exit $LASTEXITCODE
          }

          $serviceExe = Get-ChildItem -Path ".\\dist\\service" -Filter "*.exe" | Select-Object -First 1
          if ($null -eq $serviceExe) {
            Write-Error "No executable generated by PyInstaller"
            exit 1
          }

          Write-Host "âœ“ Service executable: $($serviceExe.FullName) ($('{0:N0}' -f $serviceExe.Length) bytes)"

      - name: ðŸ§ª Verify Service Executable
        shell: pwsh
        run: |
          $serviceExe = Get-ChildItem -Path ".\\dist\\service" -Filter "*.exe" | Select-Object -First 1

          if ($null -eq $serviceExe) {
            Write-Error "Service executable not found"
            exit 1
          }

          # Verify it's a valid PE executable
          $bytes = [System.IO.File]::ReadAllBytes($serviceExe.FullName)
          if ($bytes[0] -ne 0x4D -or $bytes[1] -ne 0x5A) {
            Write-Error "Invalid PE executable signature"
            exit 1
          }

          Write-Host "âœ“ Service executable is valid PE binary"

      - name: ðŸ“¤ Upload Service Artifact
        uses: actions/upload-artifact@v4
        with:
          name: python-service-${{ needs.validate-environment.outputs.build_id }}
          path: dist/service/
          retention-days: 1

      - name: ðŸš¨ Upload Failure Diagnostics
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: python-build-failure-logs-${{ needs.validate-environment.outputs.build_id }}
          path: |
            build/service/
            spec-working/
          retention-days: 30

  build-frontend:
    name: ðŸŽ¨ Build Web Frontend
    runs-on: windows-latest
    timeout-minutes: 15
    needs: validate-environment
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'web_platform/frontend/package.json'

      - name: ðŸ“¥ Install Frontend Dependencies
        shell: pwsh
        working-directory: web_platform/frontend
        run: |
          npm ci --prefer-offline --no-audit
          if ($LASTEXITCODE -ne 0) {
            Write-Error "npm ci failed"
            exit 1
          }
          npm list --depth=0

      - name: ðŸ”¨ Build Frontend
        shell: pwsh
        working-directory: web_platform/frontend
        run: |
          npm run build 2>&1

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Frontend build failed"
            exit 1
          }

          $outDir = Get-Item -Path ".\\out" -ErrorAction SilentlyContinue
          if ($null -eq $outDir) {
            Write-Error "No out/ directory generated"
            exit 1
          }

          $fileCount = (Get-ChildItem -Recurse -Path ".\\out" | Measure-Object).Count
          Write-Host "âœ“ Frontend built: $fileCount files"

      - name: ðŸ“¤ Upload Frontend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist-${{ needs.validate-environment.outputs.build_id }}
          path: web_platform/frontend/out/
          retention-days: 1

      - name: ðŸš¨ Upload Failure Diagnostics
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-failure-logs-${{ needs.validate-environment.outputs.build_id }}
          path: |
            web_platform/frontend/.next/
            web_platform/frontend/npm-debug.log
          if-no-files-found: ignore
          retention-days: 30

  verify-assets:
    name: 'ðŸ–¼ï¸ Verify Critical Build Assets'
    runs-on: windows-latest
    timeout-minutes: 5
    needs: validate-environment
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ§ Forensic Asset Verification
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $asset_manifest = @(
            @{ Path = "electron/assets/icon.ico"; Purpose = "Main Application & MSI Icon" }
          )

          Write-Host "--- Asset Verification Forensics ---"
          $all_assets_found = $true

          foreach ($asset in $asset_manifest) {
            Write-Host "Checking for: $($asset.Path) ($($asset.Purpose))"
            if (Test-Path -LiteralPath $asset.Path) {
              $file_info = Get-Item -LiteralPath $asset.Path
              $hash = (Get-FileHash -LiteralPath $asset.Path -Algorithm SHA256).Hash
              Write-Host " âœ… FOUND: $($file_info.Length) bytes, SHA256: $($hash.Substring(0,12))" -ForegroundColor Green
            } else {
              Write-Host " âŒ MISSING" -ForegroundColor Red
              $all_assets_found = $false
            }
          }

          if (-not $all_assets_found) {
            Write-Error "CRITICAL: One or more required assets are missing."
            Write-Host "\\n--- Filesystem State ---"
            Write-Host "Listing contents of 'electron/assets' directory for debugging:"
            Get-ChildItem -Path "electron/assets" -Recurse | ForEach-Object {
              Write-Host " - $($_.FullName.Replace($env:GITHUB_WORKSPACE, ''))"
            }
            exit 1
          }

          Write-Host "\\nâœ… All critical assets verified." -ForegroundColor Green
  build-electron-msi:
    name: ðŸš€ Build Electron MSI Package
    runs-on: windows-latest
    timeout-minutes: 30
    needs: [validate-environment, build-python-service, build-frontend, verify-assets]
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'electron/package.json'

      - name: ðŸ“¥ Download Python Service
        uses: actions/download-artifact@v4
        with:
          name: python-service-${{ needs.validate-environment.outputs.build_id }}
          path: python-service-bin

      - name: ðŸ“¥ Download Frontend Dist
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist-${{ needs.validate-environment.outputs.build_id }}
          path: web_platform/frontend/out

      - name: ðŸšš Stage Backend for Electron Builder
        shell: pwsh
        run: |
          #FIX: Move the backend to where electron-builder expects it
          $dest = "electron/python_service-bin"
          New-Item -ItemType Directory -Path $dest -Force | Out-Null
          Move-Item -Path "python-service-bin/" -Destination $dest -Force
          Write-Host "âœ… Backend staged to $dest"

      - name: ðŸ“¥ Install Electron Dependencies
        shell: pwsh
        working-directory: electron
        run: |
          npm ci --prefer-offline --no-audit
          if ($LASTEXITCODE -ne 0) {
            Write-Error "npm ci failed"
            exit 1
          }

      - name: 'ðŸ§ Forensically Guarantee Icon Paths'
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          # Install and import the required module for YAML parsing
          Install-Module -Name powershell-yaml -Force -Scope CurrentUser -ErrorAction Stop
          Import-Module powershell-yaml

          $configPath = 'electron/electron-builder-config.yml'
          Write-Host "--- Icon Path Forensics ---"
          Write-Host "Verifying and correcting icon paths in: $configPath"

          # 1. Verify the icon file physically exists
          $iconPath = "electron/assets/icon.ico"
          if (-not (Test-Path -LiteralPath $iconPath)) {
            Write-Error "CRITICAL: The primary icon file is missing at '$iconPath'."
            exit 1
          }
          $absoluteIconPath = (Resolve-Path -LiteralPath $iconPath).Path
          Write-Host "âœ… Primary icon found at: $absoluteIconPath"

          # 2. Read and parse the YAML configuration
          $config = Get-Content $configPath | ConvertFrom-Yaml

          # 3. Normalize the icon path for YAML
          $normalizedIconPath = $absoluteIconPath.Replace('\\', '/')

          # 4. Update the icon paths in the configuration object
          $config.win.icon = $normalizedIconPath

          # The installerIcon and uninstallerIcon properties are not valid for the MSI target.
          # electron-builder automatically uses the main application icon for the installer.
          # We unconditionally remove them here to prevent schema validation errors, catching the error if they don't exist.
          try {
            $config.msi.PSObject.Properties.Remove('installerIcon')
            Write-Host " -> Removed 'msi.installerIcon' property." -ForegroundColor Yellow
          } catch {
            Write-Host " -> 'msi.installerIcon' property did not exist, no action needed."
          }
          try {
            $config.msi.PSObject.Properties.Remove('uninstallerIcon')
            Write-Host " -> Removed 'msi.uninstallerIcon' property." -ForegroundColor Yellow
          } catch {
            Write-Host " -> 'msi.uninstallerIcon' property did not exist, no action needed."
          }

          Write-Host " -> Set win.icon to '$normalizedIconPath'" -ForegroundColor Green

          # 5. Convert back to YAML and write to a NEW temporary config file
          $tempConfigPath = 'electron/temp-builder-config.yml'
          $config | ConvertTo-Yaml | Set-Content -Path $tempConfigPath
          Write-Host "âœ… Successfully created temporary config '$tempConfigPath' with corrected icon paths."

          # 6. Display final config for verification
          Write-Host "\\n--- Final Config ---"
          Get-Content $tempConfigPath | Write-Host
          Write-Host "--------------------"

      - name: ðŸ” Verify electron-builder Config
        shell: pwsh
        run: |
          $configPath = 'electron/temp-builder-config.yml'

          if (-not (Test-Path $configPath)) {
            Write-Error "electron-builder config not found: $configPath"
            exit 1
          }

          # Basic YAML syntax check (non-exhaustive)
          $content = Get-Content $configPath -Raw
          if ($content -notmatch 'appId:') {
            Write-Error "Invalid electron-builder config: missing appId"
            exit 1
          }

          Write-Host "âœ“ electron-builder config valid"

      - name: ðŸ“„ Ensure WiX License Exists for electron-builder
        shell: pwsh
        run: |
          if (-not (Test-Path 'build_wix')) { New-Item -ItemType Directory -Path 'build_wix' | Out-Null }
          $licensePath = 'build_wix/license.rtf'
          if (-not (Test-Path $licensePath)) {
            Write-Host 'âš ï¸ License file missing. Generating placeholder...'
            # FIX: Use Base64 decoding to avoid RTF escape sequence issues in PowerShell/YAML
            $rtfContent = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("e1xydGYxXGFuc2lcZGVmZjB7XGZvbnR0Ymx7XGYwIEFyaWFsO319XGYwXGZzMjQgRU5EIFVTRVIgTElDRU5TRSBBR1JFRU1FTlRccGFyXHBhciBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgbGljZW5zZSBmb3IgRm9ydHVuYSBGYXVjZXQuIFBsZWFzZSByZXBsYWNlIHdpdGggYWN0dWFsIHRlcm1zLn0="))
            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii
            Write-Host 'âœ… Placeholder license.rtf created.'
          } else {
            Write-Host 'âœ… Existing license.rtf found.'
          }
      - name: ðŸ”¨ Build Electron Application
        shell: pwsh
        working-directory: electron
        run: |
          # Set code signing to false for CI (unless you have signing certificates)
          $env:CSC_IDENTITY_AUTO_DISCOVERY = 'false'

          npm run build -- --config temp-builder-config.yml --publish never 2>&1

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Electron build failed"
            exit 1
          }

          Write-Host "âœ“ Electron build completed"

      - name: ðŸ—ï¸ Build MSI with electron-builder
        shell: pwsh
        working-directory: electron
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: 'false'
        run: |
          $semver = "${{ needs.validate-environment.outputs.semver }}"
          $shortSha = "${{ needs.validate-environment.outputs.short_sha }}"
          $artifactName = "Fortuna-Electron-${semver}-${shortSha}.msi"
          npm run dist -- --win msi --config temp-builder-config.yml --publish never --config.artifactName=$artifactName 2>&1

          if ($LASTEXITCODE -ne 0) {
            Write-Error "electron-builder MSI creation failed"
            exit 1
          }

          Write-Host "âœ“ MSI build completed"

      - name: ðŸ” Verify MSI Output
        shell: pwsh
        run: |
          $msiFiles = Get-ChildItem -Recurse -Filter "*.msi" -ErrorAction SilentlyContinue

          if ($msiFiles.Count -eq 0) {
            Write-Error "No MSI files generated"
            exit 1
          }

          foreach ($msi in $msiFiles) {
            $sizeGB = $msi.Length / 1GB
            $sizeMB = $msi.Length / 1MB

            if ($msi.Length -lt 10MB) {
              Write-Warning "MSI suspiciously small: $($msi.Name) ($('{0:N1}' -f $sizeMB) MB)"
            }

            Write-Host "âœ“ MSI: $($msi.FullName) ($('{0:N1}' -f $sizeMB) MB)"

            # Generate checksum
            $hash = (Get-FileHash -LiteralPath $msi.FullName -Algorithm SHA256).Hash
            Write-Host " SHA256: $hash"
            $hash | Out-File -FilePath "$($msi.FullName).sha256"
          }

      - name: ðŸ“Š Generate Build Report
        if: always()
        shell: pwsh
        run: |
          $report = @{
            build_id = '${{ needs.validate-environment.outputs.build_id }}'
            timestamp = Get-Date -Format 'o'
            status = if ($LASTEXITCODE -eq 0) { 'SUCCESS' } else { 'FAILED' }
            node_version = '${{ needs.validate-environment.outputs.node_version }}'
            python_version = '${{ needs.validate-environment.outputs.python_version }}'
            msi_files = @()
          }

          Get-ChildItem -Filter "*.msi" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
            $report.msi_files += @{
              path = $_.FullName
              size_mb = [math]::Round($_.Length / 1MB, 2)
              hash = (Get-FileHash -LiteralPath $_.FullName -Algorithm SHA256).Hash
            }
          }

          $report | ConvertTo-Json | Out-File -FilePath "build-report.json"
          Get-Content "build-report.json" | Out-Host

      - name: ðŸ“¦ Stage Artifacts (Self-Discovery)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $destDir = "release-artifacts"
          New-Item -ItemType Directory -Path $destDir -Force | Out-Null
          $destAbsolutePath = (Resolve-Path $destDir).Path

          Write-Host "Staging Destination: $destAbsolutePath"

          # Find all MSIs, excluding any inside the destination folder.
          $msiFiles = Get-ChildItem -Path "." -Recurse -Filter "*.msi" |
            Where-Object { $_.FullName -notlike "$destAbsolutePath" }

          if ($msiFiles.Count -eq 0) {
            Write-Error "No MSI files found to stage!"
            exit 1
          }

          foreach ($msi in $msiFiles) {
            Write-Host "Moving: $($msi.FullName)"
            Move-Item $msi.FullName $destAbsolutePath -Force

            # Handle the checksum file if it exists
            $shaPath = "$($msi.FullName).sha256"
            if (Test-Path $shaPath) {
              Move-Item -LiteralPath $shaPath -Destination $destAbsolutePath -Force
            }
          }

          Write-Host "âœ… Staging complete. Contents of $($destDir):"
          Get-ChildItem $destAbsolutePath | Select-Object Name, Length

      - name: ðŸ“¤ Upload Release Artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}
          path: |
            release-artifacts/
            build-report.json
          retention-days: 90

      - name: ðŸš¨ Upload Failure Diagnostics
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-failure-logs-${{ needs.validate-environment.outputs.build_id }}
          path: |
            electron/dist/
            python-service-bin/
            web_platform/frontend/out/
            build-report.json
          retention-days: 30

  smoke-test:
    name: 'ðŸ”¬ Smoke Test (Robust)'
    runs-on: windows-latest
    timeout-minutes: 15
    needs: [validate-environment, build-electron-msi]
    steps:
      - name: ðŸ“¥ Download MSI Installer
        uses: actions/download-artifact@v4
        with:
          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}
          path: msi-installer

      - name: ðŸ“‹ Inspect Artifact
        shell: pwsh
        run: |
          Write-Host "=== Artifact Contents ==="
          Get-ChildItem -Path "msi-installer" -Recurse | ForEach-Object {
            Write-Host " $($_.FullName)"
          }

      - name: ðŸ¤« Install MSI & Verify
        shell: pwsh
        run: |
          # EXOTIC INGREDIENT #1: Find MSI with recursion
          $msi = Get-ChildItem -Path "msi-installer" -Filter "*.msi" -Recurse -ErrorAction SilentlyContinue |
            Select-Object -First 1

          if (-not $msi) {
            Write-Error "âŒ FATAL: No MSI file found in artifact"
            exit 1
          }

          Write-Host "Installing: $($msi.Name)"

          # EXOTIC INGREDIENT #2: Logging with /L*v
          $proc = Start-Process msiexec.exe
            -ArgumentList "/i `"$($msi.FullName)`" /qn /L*v msi-install.log"
            -Wait
            -PassThru

          if ($proc.ExitCode -ne 0) {
            Write-Error "âŒ MSI Install Failed with exit code $($proc.ExitCode)"
            if (Test-Path msi-install.log) {
              Get-Content msi-install.log | Select-Object -Last 50
            }
            exit 1
          }

          Write-Host "âœ… MSI installation succeeded"

      - name: ðŸ•µï¸ Find Installed Executable
        shell: pwsh
        run: |
          # EXOTIC INGREDIENT #3: Don't assume the path. Find it dynamically.
          # Searches for the main executable, skipping uninstallers

          $root = "C:\\Program Files\\Fortuna Faucet"
          if (-not (Test-Path $root)) {
            Write-Error "âŒ Install directory not found: $root"
            Get-ChildItem "C:\\Program Files" | Write-Host
            exit 1
          }

          $exe = Get-ChildItem -Path $root
            -Filter "*.exe"
            -Recurse
            -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notmatch 'uninstall' } |
            Select-Object -First 1

          if (-not $exe) {
            Write-Error "âŒ No main executable found in $root"
            Get-ChildItem -Path $root -Recurse | Write-Host
            exit 1
          }

          Write-Host "âœ… Found Executable: $($exe.FullName)"
          $exe.FullName | Out-File "installed_exe.txt" -Encoding utf8

      - name: ðŸš€ Launch Application & Wait for Processes
        shell: pwsh
        run: |
          $exePath = Get-Content "installed_exe.txt"
          $exeName = Split-Path -Leaf $exePath

          Write-Host "Launching: $exePath"
          Start-Process -FilePath $exePath

          Write-Host "Waiting for child processes to spawn (up to 60 seconds)..."

          # EXOTIC INGREDIENT #4: Poll for BOTH processes with a timeout
          $deadline = (Get-Date).AddSeconds(60)
          $electronFound = $false
          $backendFound = $false

          while ((Get-Date) -lt $deadline) {
            # Check for Electron process
            $electronProc = Get-Process -Name "Fortuna Faucet" -ErrorAction SilentlyContinue | Select-Object -First 1

            # Check for Python backend
            $backendProc = Get-Process -Name "fortuna-backend" -ErrorAction SilentlyContinue | Select-Object -First 1

            if ($electronProc) {
              Write-Host "âœ… Electron process running (PID: $($electronProc.Id))"
              $electronFound = $true
            }

            if ($backendProc) {
              Write-Host "âœ… Backend process running (PID: $($backendProc.Id))"
              $backendFound = $true
            }

            # FIX: Require BOTH processes
            if ($electronFound -and $backendFound) {
              Write-Host "âœ… SUCCESS: Main application AND Backend are running."
              exit 0
            }

            Start-Sleep -Milliseconds 500
          }

          Write-Error "âŒ TIMEOUT: One or both processes failed to stabilize."
          Get-Process | Where-Object { $_.Name -like "*Fortuna*" } | Format-Table
          exit 1

      - name: ðŸ“¤ Upload Logs on Failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: electron-smoke-test-logs-${{ github.run_id }}
          path: |
            msi-install.log
          retention-days: 7

      - name: ðŸ§¹ Cleanup
        if: always()
        shell: pwsh
        run: |
          Stop-Process -Name "Fortuna Faucet" -Force -ErrorAction SilentlyContinue
          Stop-Process -Name "fortuna-backend" -Force -ErrorAction SilentlyContinue
          Write-Host "âœ… Cleanup complete"

  diagnose-asgi-imports:
    name: 'ðŸ” ASGI Import Killer Pre-Smoke Diagnostic'
    runs-on: windows-latest
    timeout-minutes: 15
    needs: build-python-service
    continue-on-error: true
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      - name: 'Run ASGI Diagnostics'
        uses: ./.github/actions/run-asgi-diagnostics
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          backend-dir: 'python_service'
          backend-module-path: 'python_service'

  stage-release-artifacts:
    name: 'ðŸ“¦ Stage Release Artifacts'
    runs-on: windows-latest
    timeout-minutes: 5
    needs:
      - build-electron-msi
      - validate-environment
    steps:
      - name: ðŸ“¥ Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}
          path: staging-area

      - name: ðŸšš Stage Final Artifact
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $sourceDir = "staging-area"
          $destDir = "final-release-artifact"
          New-Item -ItemType Directory -Path $destDir -Force | Out-Null

          # FIX: $. -> $_.
          Get-ChildItem -Path $sourceDir -Recurse | ForEach-Object {
            $destPath = Join-Path $destDir $_.Name
            Move-Item -Path $_.FullName -Destination $destPath -Force
          }

          Write-Host "âœ… Artifacts staged to $destDir"

      - name: ðŸ“¤ Upload Final MSI Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Final-MSI-Artifact
          path: final-release-artifact/
          retention-days: 90
