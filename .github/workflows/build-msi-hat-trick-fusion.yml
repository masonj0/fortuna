# System Timestamp: 2025-12-07 14:00:00
name: HatTrick Fusion (Perfected)
on:
  workflow_dispatch:
  push:
    branches: ["main"]

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.12'
  DOTNET_VERSION: '8.0.x'
  WIX_VERSION: '4.0.5'
  SERVICE_PORT: '8102'
  FRONTEND_PORT: '3000'
  MSI_NAME: 'HatTrickFusion.msi'
  FIREWALL_RULE: 'HatTrickFusion-Port'
  UPGRADE_CODE: 'FA689549-366B-4C5C-A482-1132F9A34B10'
  # Mock API keys for service startup
  API_KEY: mock_key
  TVG_API_KEY: mock
  GREYHOUND_API_URL: http://mock
  FORTUNA_ENV: smoke-test

jobs:
  # 1. Build Frontend First (so Backend can bundle it)
  build-frontend:
    name: Build Frontend
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
      - name: Install and Build
        run: |
          cd web_platform/frontend
          npm ci --prefer-offline --no-audit --no-fund
          npm run build
      - name: Upload Frontend
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: web_platform/frontend/out

  # 2. Build Backend (Downloads Frontend to bundle it)
  build-backend:
    name: Build Backend Binary
    runs-on: windows-latest
    needs: build-frontend
    timeout-minutes: 30
    outputs:
      semver: ${{ steps.meta.outputs.semver }}
      backend-dir: ${{ steps.meta.outputs.backend_dir }}
    steps:
      - uses: actions/checkout@v4

      # Download Frontend for bundling
      - uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: web_platform/frontend/out

      - id: meta
        shell: pwsh
        run: |
          $ver = if ("${{ github.ref }}" -match 'refs/tags/v(.*)') { $Matches[1] } else { "0.0.${{ github.run_number }}" }
          $backendDir = if (Test-Path 'web_service/backend/main.py') { 'web_service/backend' } else { 'python_service' }
          $modulePath = if (Test-Path 'web_service/backend/main.py') { 'web_service.backend' } else { 'python_service' }
          "semver=$ver" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "backend_dir=$backendDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "module_path=$modulePath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip

      - name: Install Dependencies
        run: |
          pip install -r ${{ steps.meta.outputs.backend_dir }}/requirements.txt
          pip install pyinstaller==6.6.0

      - name: Generate Spec & Build
        shell: python
        env:
          BACKEND_DIR: ${{ steps.meta.outputs.backend_dir }}
          MODULE_PATH: ${{ env.module_path }}
          FRONTEND_OUT: web_platform/frontend/out
        run: |
          import os
          from pathlib import Path

          bk_dir = os.environ['BACKEND_DIR']
          mod_path = os.environ['MODULE_PATH']
          # CHANGE: Point to the new service wrapper
          entry = f"{bk_dir}/main.py"
          frontend_out = os.environ['FRONTEND_OUT']

          # FIX: Fixed quoting in datas list to avoid syntax error
          spec = f"""
          # -- mode: python ; coding: utf-8 --
          from PyInstaller.utils.hooks import collect_data_files, collect_submodules

          block_cipher = None

          a = Analysis(
              ['{entry}'],
              pathex=[],
              binaries=[],
              datas=collect_data_files('uvicorn') + collect_data_files('slowapi') + [('{frontend_out}', 'ui')],
              # CHANGE: Add win32timezone to hidden imports (critical for pywin32)
              hiddenimports=collect_submodules('{mod_path}') + ['win32timezone'],
              hookspath=[],
              runtime_hooks=[],
              excludes=['tests', 'pytest'],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
          exe = EXE(
              pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],
              name='fortuna-backend', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=False
          )
          """
          with open("hat-trick.spec", "w") as f: f.write(spec)
          os.system("pyinstaller hat-trick.spec --clean --noconfirm")

      - name: Upload Backend
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist
          path: dist/fortuna-backend.exe

  package-msi:
    name: Package MSI
    runs-on: windows-latest
    needs: build-backend
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: backend-dist
          path: staging/backend

      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: üìÑ Ensure WiX License Exists
        shell: pwsh
        run: |
          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }
          $licensePath = 'build_wix/license.rtf'
          if (-not (Test-Path $licensePath)) {
            Write-Host '‚ö†Ô∏è License file missing. Generating placeholder...'
            # FIX: Use Base64 decoding to avoid RTF escape sequence issues in PowerShell/YAML
            $rtfContent = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("e1xydGYxXGFuc2lcZGVmZjB7XGZvbnR0Ymx7XGYwIEFyaWFsO319XGYwXGZzMjQgRU5EIFVTRVIgTElDRU5TRSBBR1JFRU1FTlRccGFyXHBhciBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgbGljZW5zZSBmb3IgRm9ydHVuYSBGYXVjZXQuIFBsZWFzZSByZXBsYWNlIHdpdGggYWN0dWFsIHRlcm1zLn0="))
            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii
            Write-Host '‚úÖ Placeholder license.rtf created.'
          } else {
            Write-Host '‚úÖ Existing license.rtf found.'
          }
      - name: Prepare WiX
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }

          # Copy template
          Copy-Item build_wix/Product_WithService.wxs build_wix/Product.wxs -Force

          # Stage Executable
          if (Test-Path staging/backend/fortuna-backend.exe) {
            Move-Item staging/backend/fortuna-backend.exe staging/backend/fortuna-webservice.exe -Force
          }

          # FIX: Generate Valid .wixproj with Extensions
          $proj = @(
            '<Project Sdk="WixToolset.Sdk/${{ env.WIX_VERSION }}">',
            '  <PropertyGroup>',
            '    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>',
            '    <OutputType>Package</OutputType>',
            '    <Platforms>x64</Platforms>',
            '  </PropertyGroup>',
            '  <ItemGroup>',
            '    <PackageReference Include="WixToolset.UI.wixext" Version="${{ env.WIX_VERSION }}" />',
            '    <PackageReference Include="WixToolset.Firewall.wixext" Version="${{ env.WIX_VERSION }}" />',
            '    <PackageReference Include="WixToolset.Util.wixext" Version="${{ env.WIX_VERSION }}" />',
            '  </ItemGroup>',
            '  <ItemGroup>',
            '    <Compile Include="Product.wxs" />',
            '  </ItemGroup>',
            '</Project>'
          )
          Set-Content build_wix/Fortuna.wixproj ($proj -join "`r`n") -Encoding utf8

      - name: Build MSI
        working-directory: build_wix
        run: dotnet build Fortuna.wixproj -c Release -p:Platform=x64 -p:DefineConstants="Version=${{ needs.build-backend.outputs.semver }};SourceDir=../staging/backend;ServicePort=${{ env.SERVICE_PORT }}"

      - name: 'üê§ The Canary (Malware Pre-Flight)'
        shell: pwsh
        continue-on-error: true
        run: |
          $msi = Get-ChildItem -Recurse -Filter "*.msi" | Select-Object -First 1
          if (!$msi) { Write-Warning "No MSI found to scan."; exit 0 }

          Write-Host "üîç Scanning $($msi.Name) with Windows Defender..."
          $defender = "C:\Program Files\Windows Defender\MpCmdRun.exe"

          if (-not (Test-Path $defender)) {
              Write-Warning "Windows Defender CLI not found at expected path."
              exit 0
          }

          # ScanType 3 = File/Custom Scan
          $proc = Start-Process -FilePath $defender -ArgumentList "-Scan -ScanType 3 -File `"$($msi.FullName)`"" -Wait -PassThru -NoNewWindow

          if ($proc.ExitCode -eq 0) {
              Write-Host "‚úÖ CLEAN: Windows Defender found no threats." -ForegroundColor Green
          } elseif ($proc.ExitCode -eq 2) {
              Write-Error "üö® THREAT DETECTED: Windows Defender flagged this installer!"
              exit 1
          } else {
              Write-Warning "‚ö†Ô∏è Scan completed with inconclusive exit code: $($proc.ExitCode)"
          }

      - name: Upload MSI
        uses: actions/upload-artifact@v4
        with:
          name: hat-trick-msi
          path: build_wix/bin/x64/Release/

  smoke-test:
    name: HatTrick Fusion Smoke Test
    runs-on: windows-latest
    needs: package-msi
    timeout-minutes: 30
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: hat-trick-msi
          path: installer

      - name: üõ°Ô∏è Firewall Rule
        shell: pwsh
        run: |
          New-NetFirewallRule -DisplayName "HatTrick-Test" -Direction Inbound -LocalPort ${{ env.SERVICE_PORT }} -Protocol TCP -Action Allow

      - name: ü§´ Install MSI (With Logging)
        shell: pwsh
        run: |
          if (Get-Service -Name FortunaWebService -ErrorAction SilentlyContinue) {
            sc.exe stop FortunaWebService 2>&1 | Out-Null
            sc.exe delete FortunaWebService 2>&1 | Out-Null
          }

          # FIX: Filter \"*.msi\"
          $msi = Get-ChildItem -Path "installer" -Filter "*.msi" -Recurse | Select-Object -First 1
          if (-not $msi) {
            Write-Error "‚ùå FATAL: No MSI found in artifact"
            Get-ChildItem -Path "installer" -Recurse
            exit 1
          }

          Write-Host "Installing: $($msi.FullName)"

          $msiPath = $msi.FullName
          # FIX: Quote escaping
          $args = "/i `"$msiPath`" /qn /L*v installation.log"
          $proc = Start-Process msiexec.exe -ArgumentList $args -Wait -NoNewWindow -PassThru

          if ($proc.ExitCode -ne 0) {
            Write-Error "‚ùå MSI Install Failed with exit code $($proc.ExitCode)"
            Get-Content installation.log -Tail 60 | ForEach-Object { Write-Error $_ }
            throw "Installation failed"
          }

          Write-Host "‚úÖ MSI installation succeeded (Exit Code: 0)"

      - name: Emit MSI log tail
        if: always()
        shell: pwsh
        run: |
          if (Test-Path installation.log) {
            Write-Host "`n=== installation.log (last 200 lines) ==="
            Get-Content installation.log -Tail 200
          } else {
            Write-Host "No installation.log found"
          }

      - name: Health and Process Validation
        shell: python
        env:
          PORT: ${{ env.SERVICE_PORT }}
        run: |
          import os, socket, time, urllib.request, urllib.error, subprocess, sys
          port = int(os.environ["PORT"])

          # Start Service
          subprocess.run(["sc.exe", "start", "FortunaWebService"], check=False)

          # Wait for Port
          for _ in range(30):
            try:
              with socket.create_connection(("127.0.0.1", port), timeout=1):
                break
            except Exception:
              time.sleep(1)
          else:
            print("‚ùå Port bind timeout")
            subprocess.run(["sc.exe", "query", "FortunaWebService"])
            sys.exit(1)

          # Health Check
          for _ in range(6):
            try:
              req = urllib.request.Request(f"http://127.0.0.1:{port}/health")
              req.add_header("User-Agent", "HatTrickFusion/1.0")
              with urllib.request.urlopen(req, timeout=5) as resp:
                if resp.status == 200:
                  print("‚úÖ Health Check Passed")
                  sys.exit(0)
            except urllib.error.HTTPError as err:
              if err.code in (401, 403):
                print("‚úÖ Service Up (Auth Required")
                sys.exit(0)
            except Exception:
              time.sleep(2)
          sys.exit(1)

      - name: Verify UI is Served from Backend
        shell: pwsh
        run: |
          $uri = "http://127.0.0.1:${{ env.SERVICE_PORT }}/index.html"
          Write-Host "Checking for frontend at $uri"
          for ($i = 0; $i -lt 12; $i++) {
            try {
              $resp = Invoke-WebRequest -Uri $uri -TimeoutSec 3 -UseBasicParsing -ErrorAction Stop
              if ($resp.StatusCode -eq 200) {
                Write-Host "‚úÖ UI is being served correctly."
                exit 0
              }
            } catch {
              Start-Sleep -Seconds 2
            }
          }
          Write-Error "UI was not served from the backend."
          exit 1

      - name: 'üì∏ The Paparazzi (Visual Proof)'
        shell: pwsh
        run: |
          Write-Host "Installing Playwright for visual verification..."
          python -m pip install playwright
          python -m playwright install chromium

          # Default to 8102 if SERVICE_PORT is not set
          $port = "${{ env.SERVICE_PORT }}"
          if ([string]::IsNullOrWhiteSpace($port)) { $port = "8102" }

          Write-Host "Taking screenshot of http://localhost:$port..."
          python -c "
          from playwright.sync_api import sync_playwright
          import sys

          try:
              with sync_playwright() as p:
                  browser = p.chromium.launch()
                  page = browser.new_page()
                  # Try index.html, fall back to root if needed
                  url = f'http://localhost:{sys.argv[1]}/index.html'
                  print(f'Navigating to {url}...')
                  page.goto(url)
                  # Wait a moment for React/Next.js hydration if needed
                  page.wait_for_timeout(2000)
                  page.screenshot(path='proof-of-life.png', full_page=True)
                  browser.close()
              print('‚úÖ Screenshot captured.')
          except Exception as e:
              print(f'‚ùå Screenshot failed: {e}')
              # We do not fail the build for this; it is a bonus artifact.
              sys.exit(0)
          " $port

      - name: üì§ Upload Visual Proof
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-proof-${{ github.run_id }}
          path: proof-of-life.png
          retention-days: 7

      - name: Gather diagnostics
        if: failure()
        shell: pwsh
        run: |
          $diag = Join-Path $PWD "installer-diag"
          Remove-Item $diag -Recurse -Force -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $diag | Out-Null
          Copy-Item -Path installation.log -Destination $diag -Force
          Copy-Item -Path "C:\\ProgramData\\Fortuna\\logs\\*.log" -Destination $diag -Force -ErrorAction SilentlyContinue
          Copy-Item -Path "C:\\Program Files\\Fortuna Faucet\\" -Destination $diag -Recurse -Force -ErrorAction SilentlyContinue
      - name: Upload Logs on Failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: hat-trick-fusion-logs-${{ github.run_id }}
          path: installer-diag