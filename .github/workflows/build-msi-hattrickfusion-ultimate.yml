# System Timestamp: 2025-12-21 14:04:35
name: üé© HatTrick Fusion (Ultimate)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'
  DOTNET_VERSION: '8.0.x'
  WIX_VERSION: '4.0.5'
  SERVICE_PORT: '8102'
  API_KEY: mock_key
  TVG_API_KEY: mock
  GREYHOUND_API_URL: http://mock
  FORTUNA_ENV: smoke-test
  FRONTEND_DIR: 'web_service/frontend'
  BACKEND_DIR: 'web_service/backend'
  WIX_DIR: 'build_wix'

jobs:
  build-frontend:
    name: 'üé® Build Frontend'
    runs-on: windows-2022
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'
      - name: Install & Build
        run: |
          cd ${{ env.FRONTEND_DIR }}
          npm ci --prefer-offline --no-audit
          npm run build
      - uses: actions/upload-artifact@v4
        with:
          name: frontend-dist-${{ github.run_id }}
          path: ${{ env.FRONTEND_DIR }}/out

  backend-quality:
    name: 'üßØ Backend Quality Gates'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build-frontend
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup
      - name: Install Dependencies
        run: |
          pip install -r web_service/backend/requirements-dev.txt
      - name: Run Pytest
        run: |
          pytest web_service/backend/tests
  build-backend:
    name: 'üêç Build Backend (${{ matrix.arch }})'
    runs-on: windows-2022
    needs: [build-frontend, backend-quality]
    strategy:
      matrix:
        arch: [x64, x86]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: frontend-dist-${{ github.run_id }}
          path: staging/ui
      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          architecture: '${{ matrix.arch }}'
          cache: 'pip'
      - name: üßæ Create Architecture Constraints
        id: constraints
        shell: pwsh
        run: |
          $file = "constraints.txt"
          if ('${{ matrix.arch }}' -eq 'x86') {
            "numpy==1.23.5`r`npandas==1.5.3`r`n--only-binary=:all:" | Set-Content $file
          } else {
            New-Item $file -ItemType File -Force
          }
          "file=$file" | Out-File $env:GITHUB_OUTPUT -Append
      - name: üì¶ Install Dependencies & Build
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install uv
          uv pip install --system -r ${{ env.BACKEND_DIR }}/requirements.txt -c ${{ steps.constraints.outputs.file }}
          uv pip install --system pyinstaller==6.6.0 pywin32
          pyinstaller --noconfirm --clean --log-level INFO fortuna-unified.spec
      - uses: actions/upload-artifact@v4
        with:
          name: backend-dist-${{ matrix.arch }}-${{ github.run_id }}
          path: dist/fortuna-webservice/

  derive-version:
    name: 'üè∑Ô∏è Derive Version'
    runs-on: windows-2022
    outputs:
      semver: ${{ steps.git_version.outputs.semver }}
    steps:
      - uses: actions/checkout@v4
      - name: 'üè∑Ô∏è Derive SemVer'
        id: git_version
        shell: pwsh
        run: |
          $semver = "0.0.${{ github.run_number }}"
          "semver=$semver" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append

  package-msi:
    name: 'üíø Package MSI (${{ matrix.arch }})'
    runs-on: windows-2022
    needs: [build-backend, derive-version]
    strategy:
      matrix:
        arch: [x64, x86]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: backend-dist-${{ matrix.arch }}-${{ github.run_id }}
          path: staging/backend
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
      - name: Prepare WiX Project
        shell: pwsh
        run: |
          if (-not (Test-Path 'build_wix/license.rtf')) {
             Set-Content -Path 'build_wix/license.rtf' -Value '{\rtf1\ansi Placeholder License}' -Encoding Ascii
          }
          Copy-Item "build_wix/Product_WebService.wxs" "build_wix/Product.wxs" -Force
          $proj = @(
            '<Project Sdk="WixToolset.Sdk/${{ env.WIX_VERSION }}">',
            '  <PropertyGroup>',
            '    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>',
            '    <OutputType>Package</OutputType>',
            '    <Platforms>x64;x86</Platforms>',
            '    <DefineConstants>Version=$(Version);SourceDir=$(SourceDir);ServicePort=$(ServicePort);Platform=$(Platform)</DefineConstants>',
            '  </PropertyGroup>',
            '  <ItemGroup>',
            '    <PackageReference Include="WixToolset.UI.wixext" Version="${{ env.WIX_VERSION }}" />',
            '    <PackageReference Include="WixToolset.Firewall.wixext" Version="${{ env.WIX_VERSION }}" />',
            '    <PackageReference Include="WixToolset.Util.wixext" Version="${{ env.WIX_VERSION }}" />',
            '  </ItemGroup>',
            '  <ItemGroup>',
            '    <Compile Include="Product.wxs" />',
            '  </ItemGroup>',
            '</Project>'
          )
          Set-Content "${{ env.WIX_DIR }}/Fortuna.wixproj" -Value ($proj -join "`r`n") -Encoding utf8
      - name: Build MSI
        working-directory: ${{ env.WIX_DIR }}
        run: dotnet build Fortuna.wixproj -c Release -p:Platform=${{ matrix.arch }} -p:Version="${{ needs.derive-version.outputs.semver }}" -p:SourceDir="../staging/backend" -p:ServicePort="${{ env.FORTUNA_PORT }}"
      - name: Rename & Hash
        run: |
          $releaseDir = "${{ env.WIX_DIR }}/bin/${{ matrix.arch }}/Release"
          $msi = Get-ChildItem -Path $releaseDir -Filter "*.msi" | Select -First 1
          $target = "Ultimate-${{ matrix.arch }}-${{ needs.derive-version.outputs.semver }}.msi"
          Move-Item $msi.FullName -Destination "$releaseDir/$target" -Force
          $hash = (Get-FileHash "$releaseDir/$target" -Algorithm SHA256).Hash
          Set-Content -Path "$releaseDir/$target.sha256" -Value $hash
      - name: 'ü¶ú The Canary (Malware Scan)'
        shell: pwsh
        run: |
          $msi = "Ultimate-${{ matrix.arch }}-${{ needs.derive-version.outputs.semver }}.msi"
          $path = "${{ env.WIX_DIR }}/bin/${{ matrix.arch }}/Release/$msi"
          if (Test-Path "C:\\Program Files\\Windows Defender\\MpCmdRun.exe") {
            Write-Host "üõ°Ô∏è Scanning $msi with Windows Defender..."
            & "C:\\Program Files\\Windows Defender\\MpCmdRun.exe" -Scan -ScanType 3 -File "$path"
            if ($LASTEXITCODE -ne 0) { throw "ü¶† MALWARE DETECTED in MSI!" }
          }
      - uses: actions/upload-artifact@v4
        with:
          name: msi-${{ matrix.arch }}-${{ github.run_id }}
          path: |
            ${{ env.WIX_DIR }}/bin/${{ matrix.arch }}/Release/*.msi
            ${{ env.WIX_DIR }}/bin/${{ matrix.arch }}/Release/*.sha256

  smoke-test:
    name: 'üö¨ Smoke Test (${{ matrix.arch }})'
    runs-on: windows-latest
    needs: package-msi
    strategy:
      matrix:
        arch: [x64, x86]
    steps:
      - name: 'üì• Download MSI Artifact'
        uses: actions/download-artifact@v4
        with:
          name: msi-${{ matrix.arch }}-${{ github.run_id }}
          path: msi-installer

      - name: 'üõ°Ô∏è Triple-Loop Synthesis Smoke Test'
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $msiPath = (Get-ChildItem -Path "msi-installer" -Filter "*.msi" -Recurse | Select-Object -First 1).FullName
          if (-not $msiPath) {
              throw "MSI file not found in downloaded artifact."
          }

          # --- 1. Pre-Install Cleanup ---
          Write-Host "--- üßπ Pre-Install Cleanup ---"
          sc.exe delete "FortunaWebService" *>$null
          Start-Sleep -Seconds 3

          # --- 2. Installation ---
          Write-Host "--- üíø Installing MSI ---"
          $logFile = "install.log"
          Start-Process msiexec.exe -ArgumentList "/i `"$msiPath`" /qn /L*v `"$logFile`"" -Wait

          # --- Loop 1: Verify File Installation ---
          Write-Host "--- üîç Loop 1: Verifying File Installation ---"
          $progFiles = if ('${{ matrix.arch }}' -eq 'x86') { ${env:ProgramFiles(x86)} } else { $env:ProgramFiles }
          $installRoot = Join-Path $progFiles "Fortuna Faucet Service"
          $exePath = Join-Path $installRoot "fortuna-webservice.exe"
          $loop1Success = $false
          for ($i = 0; $i -lt 10; $i++) {
              if (Test-Path $exePath) {
                  Write-Host "‚úÖ File installation confirmed at $exePath"
                  $loop1Success = $true
                  break
              }
              Write-Host "... waiting for file installation ($($i+1)/10)"
              Start-Sleep -Seconds 2
          }
          if (-not $loop1Success) { throw "File installation verification failed." }

          # Create runtime directories
          New-Item -Path "$installRoot\data", "$installRoot\json", "$installRoot\logs" -ItemType Directory -Force | Out-Null

          # --- Loop 2: Verify Service Registration ---
          Write-Host "--- üîç Loop 2: Verifying Service Registration ---"
          $serviceName = "FortunaWebService"
          $loop2Success = $false
          for ($i = 0; $i -lt 10; $i++) {
              $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
              if ($service) {
                  Write-Host "‚úÖ Service '$($serviceName)' is registered."
                  $loop2Success = $true
                  break
              }
              Write-Host "... waiting for service registration ($($i+1)/10)"
              Start-Sleep -Seconds 2
          }
          if (-not $loop2Success) { throw "Service registration verification failed." }

          # --- 3. Start Service & Health Check ---
          Write-Host "--- üöÄ Starting Service & Initiating Health Check ---"
          Start-Service -Name $serviceName
          Start-Sleep -Seconds 5 # Give it a moment to start

          # --- Loop 3: Verify Health Endpoint ---
          $healthUrl = "http://localhost:${{ env.SERVICE_PORT }}/health"
          $loop3Success = $false
          for ($i = 0; $i -lt 30; $i++) { # 30 retries * 3s = 90s timeout
              try {
                  $response = Invoke-WebRequest -Uri $healthUrl -UseBasicParsing -TimeoutSec 2
                  if ($response.StatusCode -eq 200) {
                      $health = $response.Content | ConvertFrom-Json
                      if ($health.status -eq 'ok') {
                        Write-Host "‚úÖ Health check PASSED on attempt $($i+1) with status 'ok'."
                        $loop3Success = $true
                        break
                      } else {
                        Write-Warning "Health check returned status '$($health.status)'..."
                      }
                  }
              } catch {
                  if ($_.Exception.Response -and $_.Exception.Response.StatusCode.value__ -eq 503) {
                      Write-Host "... service is starting up (503), waiting ($($i+1)/30)"
                  } else {
                      Write-Host "... waiting for health endpoint ($($i+1)/30)"
                  }
                  Start-Sleep -Seconds 3
              }
          }
          if (-not $loop3Success) { throw "Service health check failed after multiple attempts." }

          Write-Host "üéâ Smoke Test Fully Passed!"

      - name: 'üïµÔ∏è CSI: Windows Post-Mortem (On Failure)'
        if: failure()
        shell: pwsh
        run: |
          Write-Host "--- üïµÔ∏è Emergency Diagnostics ---"
          Get-Process | Where-Object { $_.ProcessName -match "fortuna" } | Format-Table
          Get-EventLog -LogName Application -Newest 50 -EntryType Error,Warning | Format-List
          if (Test-Path "install.log") {
            Write-Host "--- Installation Log (Last 100 lines) ---"
            Get-Content install.log -Tail 100
          }
          netstat -anob

      - name: 'üì§ Upload Diagnostic Artifacts'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-diagnostics-${{ matrix.arch }}
          path: |
            install.log
          if-no-files-found: ignore

  release:
    name: 'üöÄ Create Release'
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    needs: [package-msi]
    timeout-minutes: 30
    permissions:
      contents: write
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: msi-*
          path: assets
          merge-multiple: true
      - name: Generate Checksums
        run: |
          $msi = Get-ChildItem -Path "msi-installer" -Filter "*.msi" -Recurse | Select-Object -First 1
          if (-not $msi) { throw "MSI not found in msi-installer directory!" }
          Start-Process msiexec.exe -ArgumentList "/i `"$($msi.FullName)`" /quiet /norestart /L*v install.log" -Wait
          Start-Sleep 10

      - name: üîç Dynamic Path Verification
        shell: pwsh
        run: |
          $progFiles = if ('${{ matrix.arch }}' -eq 'x86') { ${env:ProgramFiles(x86)} } else { $env:ProgramFiles }
          $installRoot = Join-Path $progFiles "Fortuna Faucet Service"
          if (-not (Test-Path $installRoot)) { throw "‚ùå Install dir not found at $installRoot" }
          Write-Host "‚úÖ Found install at $installRoot"
          New-Item -Path "$installRoot\data", "$installRoot\json", "$installRoot\logs" -ItemType Directory -Force | Out-Null
          Start-Service "FortunaWebService"
          Start-Sleep 10

      - name: 'üì¶ Install Playwright'
        shell: pwsh
        continue-on-error: true
        run: |
          npm install playwright
          npx playwright install chromium --with-deps

      - name: 'üî¨ Verify Backend Health'
        shell: pwsh
        run: |
          Start-Sleep -Seconds 5
          $healthUrl = "http://localhost:${{ env.SERVICE_PORT }}/health"
          $maxRetries = 5
          $delay = 2
          for ($i=1; $i -le $maxRetries; $i++) {
            try {
              $response = Invoke-WebRequest -Uri $healthUrl -UseBasicParsing -TimeoutSec 5
              if ($response.StatusCode -eq 200) {
                Write-Host "‚úÖ Health check PASSED on attempt $i."
                return
              }
            } catch {
              Write-Warning "Attempt $i: Health check failed."
            }
            if ($i -lt $maxRetries) {
              $currentDelay = [math]::Pow($delay, $i)
              Write-Host "Waiting for $currentDelay seconds..."
              Start-Sleep -Seconds $currentDelay
            }
          }
          throw "‚ùå Service health check failed after $maxRetries attempts."

      - name: 'üì∏ Capture Screenshot'
        shell: pwsh
        continue-on-error: true
        run: |
          $docsUrl = "http://127.0.0.1:${{ env.SERVICE_PORT }}/docs"
          Write-Host "üì∏ Taking screenshot of $docsUrl..."
          node -e "const { chromium } = require('playwright'); (async () => { const browser = await chromium.launch(); const page = await browser.newPage(); try { await page.goto('$docsUrl', {timeout: 15000}); await page.screenshot({ path: 'proof.png' }); console.log('‚úÖ Screenshot saved.'); } catch(e) { console.error(e); process.exit(1); } await browser.close(); })();"

      - name: 'üïµÔ∏è CSI: Windows Post-Mortem (On Failure)'
        if: failure()
        shell: pwsh
        run: |
          Get-Process | Where-Object { $_.ProcessName -match "fortuna" }
          Get-EventLog -LogName Application -Newest 50 -EntryType Error,Warning
          if (Test-Path install.log) {
            Write-Host "--- Installation Log ---"
            Get-Content install.log -Tail 50
          }

      - name: üì§ Upload Proof & Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: smoke-proof-${{ matrix.arch }}
          path: |
            proof.png
            install.log
