# System Timestamp: 2025-12-04 14:04:28.986665
name: Unified MSI Builder (Jules's Gold Standard)

on:
  push:
    branches:
      - main

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.12'
  DOTNET_VERSION: '8.0.x'
  WIX_VERSION: '4.0.5'
  FRONTEND_DIR: 'web_platform/frontend'
  WIX_DIR: 'build_wix'
  SERVICE_PORT: '8102'
  UPGRADE_CODE: 'FA689549-366B-4C5C-A482-1132F9A34B10'
  # Mock API keys for service startup
  API_KEY: mock_key
  TVG_API_KEY: mock
  GREYHOUND_API_URL: http://mock
  FORTUNA_ENV: smoke-test

jobs:
  quality-gate:
    name: '‚úÖ Quality Gate'
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: |
            web_service/backend/requirements.txt
            web_service/backend/requirements-dev.txt

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          if (Test-Path "web_service/backend/requirements-dev.txt") {
            pip install -r web_service/backend/requirements-dev.txt
          } else {
            # Fallback to standard requirements if -dev is not found
            pip install -r web_service/backend/requirements.txt
          }

      - name: Run Pytest
        shell: pwsh
        run: |
          # Check if pytest is installed before trying to run it
          $pytest_exists = Get-Command pytest -ErrorAction SilentlyContinue
          if (-not $pytest_exists) {
            Write-Host "‚ÑπÔ∏è pytest not found in dependencies, skipping tests."
            exit 0
          }

          python -m pytest web_service/backend

          # Exit code 5 means no tests were found, which is not a failure in this context.
          if ($LASTEXITCODE -eq 5) {
            Write-Host "‚úÖ Pytest returned exit code 5 (No tests found), which is acceptable."
            exit 0
          } elseif ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Pytest failed with exit code $LASTEXITCODE."
            exit $LASTEXITCODE
          }
          Write-Host "‚úÖ Pytest suite passed."

  build-executable:
    name: 'üõ†Ô∏è Build Executable'
    runs-on: windows-latest
    needs: [quality-gate]
    timeout-minutes: 30
    env:
      BACKEND_DIR: 'web_service/backend'
      BACKEND_MODULE_PATH: 'web_service.backend'
    outputs:
      build_id: ${{ steps.vars.outputs.build_id }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set Build ID
        id: vars
        run: echo "build_id=${{ github.run_id }}-${{ github.run_attempt }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'

      - name: Install Frontend Dependencies & Build
        shell: pwsh
        run: |
          cd "${{ env.FRONTEND_DIR }}"
          npm ci --prefer-offline
          npm run build
          cd ../..

      - name: Generate Artifact Manifest
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $outDir = Resolve-Path "${{ env.FRONTEND_DIR }}/out"
          # Fallback for different env var names in different workflows
          if (-not (Test-Path $outDir)) { $outDir = Resolve-Path "${{ env.FRONTEND_BUILD_DIR }}" }

          if (-not (Test-Path $outDir)) { Write-Error "‚ùå Build failed: 'out' dir missing"; exit 1 }

          $manifestPath = "frontend-manifest.tsv"
          "RelativePath`tSizeBytes`tSHA256" | Out-File $manifestPath -Encoding utf8

          $files = Get-ChildItem -Path $outDir -Recurse -File
          if ($files.Count -eq 0) { Write-Error "‚ùå Build failed: 'out' dir empty"; exit 1 }

          Write-Host "‚úÖ Frontend built: $($files.Count) files."

          foreach ($f in $files) {
            # FIX: Changed TrimStart('\\\\', '/') to TrimStart('\\', '/') to prevent char conversion error
            $rel = $f.FullName.Substring($outDir.Path.Length).TrimStart('\','/')
            $hash = (Get-FileHash $f.FullName -Algorithm SHA256).Hash.Substring(0,16)
            "$rel`t$($f.Length)`t$hash" | Out-File $manifestPath -Encoding utf8 -Append
          }

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: '${{ env.BACKEND_DIR }}/requirements.txt'

      - name: Install Backend Dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r ${{ env.BACKEND_DIR }}/requirements.txt
          pip install pyinstaller==6.6.0

      - name: Generate Spec & Build
        shell: python
        env:
          BACKEND_DIR: ${{ env.BACKEND_DIR }}
          MODULE_PATH: ${{ env.BACKEND_MODULE_PATH }}
          FRONTEND_OUT: ${{ env.FRONTEND_DIR }}/out
        run: |
          import os
          from pathlib import Path

          bk_dir = os.environ['BACKEND_DIR'].replace('\\', '/')
          mod_path = os.environ['MODULE_PATH']
          frontend_out = os.environ['FRONTEND_OUT'].replace('\\', '/')

          entry = f"{bk_dir}/main.py"

          spec = f"""
          # -- mode: python ; coding: utf-8 --
          from PyInstaller.utils.hooks import collect_data_files, collect_submodules

          block_cipher = None

          a = Analysis(
              ['{entry}'],
              pathex=[],
              binaries=[],
              datas=collect_data_files('uvicorn') + collect_data_files('slowapi') + [('{frontend_out}', 'ui')],
              hiddenimports=collect_submodules('{mod_path}') + ['win32timezone'],
              hookspath=[],
              runtime_hooks=[],
              excludes=['tests', 'pytest'],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
          exe = EXE(
              pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],
              name='fortuna-backend', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=False
          )
          """
          with open("unified.spec", "w") as f: f.write(spec)
          os.system("pyinstaller unified.spec --clean --noconfirm")

      - name: Upload Backend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist-${{ steps.vars.outputs.build_id }}
          path: dist/fortuna-backend.exe
          retention-days: 1

      - name: üì§ Upload Executable on Failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: failed-executable-${{ steps.vars.outputs.build_id }}
          path: dist/
          retention-days: 5

  package-msi:
    name: 'üíø Package MSI'
    runs-on: windows-latest
    needs: [build-executable]
    timeout-minutes: 30
    outputs:
      build_id: ${{ needs.build-executable.outputs.build_id }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Backend Artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-dist-${{ needs.build-executable.outputs.build_id }}
          path: staging/backend

      - name: Rename Executable for WiX
        shell: pwsh
        run: |
          if (Test-Path staging/backend/fortuna-backend.exe) {
            Rename-Item -Path staging/backend/fortuna-backend.exe -NewName fortuna-webservice.exe -Force
            Write-Host "‚úÖ Renamed executable to fortuna-webservice.exe"
          } else {
            Write-Error "‚ùå Executable not found in staging directory!"
            exit 1
          }

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: üìÑ Ensure WiX License Exists
        shell: pwsh
        run: |
          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }
          $licensePath = 'build_wix/license.rtf'
          if (-not (Test-Path $licensePath)) {
            Write-Host '‚ö†Ô∏è License file missing. Generating placeholder...'
            $rtfContent = '{\rtf1\ansi\deff0{\fonttbl{\f0 Arial;}}\f0\fs24 END USER LICENSE AGREEMENT\par\par This is a placeholder license for Fortuna Faucet. Please replace with actual terms.}'
            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii
            Write-Host '‚úÖ Placeholder license.rtf created.'
          } else {
            Write-Host '‚úÖ Existing license.rtf found.'
          }
      - name: Prepare WiX Project
        shell: pwsh
        run: |
          # 1. Copy the template
          Copy-Item "${{ env.WIX_DIR }}/Product_WithService.wxs" "${{ env.WIX_DIR }}/Product.wxs" -Force

          # 2. Dynamically remove the problematic Start="install" attribute to prevent timeouts
          $wxsPath = "${{ env.WIX_DIR }}/Product.wxs"
          [xml]$wxsContent = Get-Content $wxsPath
          $serviceControl = $wxsContent.SelectSingleNode("//*[local-name()='ServiceControl']")
          if ($serviceControl -and $serviceControl.HasAttribute("Start")) {
              $serviceControl.RemoveAttribute("Start")
              $wxsContent.Save($wxsPath)
              Write-Host "‚úÖ Dynamically removed 'Start=install' attribute from WiX template."
          }

          # 3. Generate Project with CAB embedding enabled
          $proj = @(
            '<Project Sdk="WixToolset.Sdk/${{ env.WIX_VERSION }}">',
            '  <PropertyGroup>',
            '    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>',
            '    <OutputType>Package</OutputType>',
            '    <Platforms>x64</Platforms>',
            '  </PropertyGroup>',
            '  <ItemGroup>',
            '    <PackageReference Include="WixToolset.UI.wixext" Version="${{ env.WIX_VERSION }}" />',
            '    <PackageReference Include="WixToolset.Firewall.wixext" Version="${{ env.WIX_VERSION }}" />',
            '    <PackageReference Include="WixToolset.Util.wixext" Version="${{ env.WIX_VERSION }}" />',
            '  </ItemGroup>',
            '  <ItemGroup>',
            '    <Compile Include="Product.wxs" />',
            '  </ItemGroup>',
            '</Project>'
          )
          Set-Content "${{ env.WIX_DIR }}/Fortuna.wixproj" -Value ($proj -join "`r`n") -Encoding utf8

      - name: Build MSI
        working-directory: ${{ env.WIX_DIR }}
        run: |
          dotnet build Fortuna.wixproj -c Release -p:Platform=x64 -p:DefineConstants="Version=0.0.${{ github.run_number }};SourceDir=../staging/backend;ServicePort=${{ env.SERVICE_PORT }}"

      - name: 'üê§ The Canary (Malware Pre-Flight)'
        shell: pwsh
        continue-on-error: true
        run: |
          $msi = Get-ChildItem -Recurse -Filter "*.msi" | Select-Object -First 1
          if (!$msi) { Write-Warning "No MSI found to scan."; exit 0 }

          Write-Host "üîç Scanning $($msi.Name) with Windows Defender..."
          $defender = "C:\Program Files\Windows Defender\MpCmdRun.exe"

          if (-not (Test-Path $defender)) {
              Write-Warning "Windows Defender CLI not found at expected path."
              exit 0
          }

          # ScanType 3 = File/Custom Scan
          $proc = Start-Process -FilePath $defender -ArgumentList "-Scan -ScanType 3 -File `"$($msi.FullName)`"" -Wait -PassThru -NoNewWindow

          if ($proc.ExitCode -eq 0) {
              Write-Host "‚úÖ CLEAN: Windows Defender found no threats." -ForegroundColor Green
          } elseif ($proc.ExitCode -eq 2) {
              Write-Error "üö® THREAT DETECTED: Windows Defender flagged this installer!"
              exit 1
          } else {
              Write-Warning "‚ö†Ô∏è Scan completed with inconclusive exit code: $($proc.ExitCode)"
          }

      - name: Upload MSI Artifact
        uses: actions/upload-artifact@v4
        with:
          name: msi-installer-${{ needs.build-executable.outputs.build_id }}
          path: ${{ env.WIX_DIR }}/bin/x64/Release/*
          retention-days: 1

  smoke-test:
    name: 'üî¨ Smoke Test (Unified)'
    runs-on: windows-latest
    needs: package-msi
    steps:
      - name: Download MSI Installer
        uses: actions/download-artifact@v4
        with:
          name: msi-installer-${{ needs.package-msi.outputs.build_id }}
          path: msi-installer

      - name: üõ°Ô∏è Configure Firewall
        shell: pwsh
        run: |
          New-NetFirewallRule `
            -DisplayName "FortunaWebService" `
            -Direction Inbound `
            -LocalPort 8102 `
            -Protocol TCP `
            -Action Allow `
            -ErrorAction SilentlyContinue
          Write-Host "‚úÖ Firewall rule added for port 8102"

      - name: ü§´ Install MSI (With Logging)
        shell: pwsh
        run: |
          if (Get-Service -Name FortunaWebService -ErrorAction SilentlyContinue) {
            sc.exe stop FortunaWebService 2>&1 | Out-Null
            sc.exe delete FortunaWebService 2>&1 | Out-Null
          }

          $msi = Get-ChildItem -Path "msi-installer" -Filter "*.msi" -Recurse | Select-Object -First 1
          if (-not $msi) {
            Write-Error "‚ùå FATAL: No MSI found in artifact"
            Get-ChildItem -Path "msi-installer" -Recurse
            exit 1
          }

          Write-Host "Installing: $($msi.FullName)"

          $proc = Start-Process msiexec.exe `
            -ArgumentList "/i `"$($msi.FullName)`" /qn /L*v msi-install.log" `
            -Wait `
            -NoNewWindow `
            -PassThru

          if ($proc.ExitCode -ne 0) {
            Write-Error "‚ùå MSI Install Failed with exit code $($proc.ExitCode)"
            exit 1
          }

          Write-Host "‚úÖ MSI installation succeeded"

      - name: Emit MSI log tail
        if: always()
        shell: pwsh
        run: |
          if (Test-Path msi-install.log) {
            Write-Host "`n=== msi-install.log (last 200 lines) ==="
            Get-Content msi-install.log -Tail 200
          } else {
            Write-Host "No msi-install.log found"
          }

      - name: ‚è≥ Wait for Service Registration
        shell: pwsh
        run: |
          $regPath = "HKLM:\SYSTEM\CurrentControlSet\Services\FortunaWebService"
          Write-Host "Waiting for service to be registered in registry..."

          for ($i = 0; $i -lt 30; $i++) {
            if (Test-Path $regPath) {
              Write-Host "‚úÖ Service registered (took $i seconds)"
              $svc = Get-Service -Name "FortunaWebService" -ErrorAction SilentlyContinue
              Write-Host "   DisplayName: $($svc.DisplayName)"
              Write-Host "   Status: $($svc.Status)"
              exit 0
            }
            Write-Host "  Waiting... ($i/30 seconds)"
            Start-Sleep -Seconds 1
          }

          Write-Error "‚ùå Service was not registered in HKLM after 30 seconds"
          exit 1

      - name: üöÄ Launch & Verify Health
        shell: python
        env:
          SERVICE_PORT: '8102'
        run: |
          import os, sys, subprocess, socket, time, urllib.request, urllib.error

          PORT = int(os.getenv("SERVICE_PORT", 8102))

          print("--- Starting Service via SC.EXE ---")
          result = subprocess.run(
            ["sc.exe", "start", "FortunaWebService"],
            capture_output=True,
            text=True
          )
          print(f"sc.exe output: {result.stdout}")
          if result.stderr:
            print(f"sc.exe stderr: {result.stderr}")

          print(f"\n--- Waiting for Port {PORT} (up to 60 seconds) ---")
          start_time = time.time()
          socket_bound = False

          while time.time() - start_time < 60:
            try:
              with socket.create_connection(("127.0.0.1", PORT), timeout=1):
                elapsed = time.time() - start_time
                print(f"‚úÖ Socket bound after {elapsed:.1f} seconds.")
                socket_bound = True
                break
            except Exception as e:
              elapsed = time.time() - start_time
              print(f"  Waiting... {elapsed:.1f}s", end="\r")
              time.sleep(2)

          if not socket_bound:
            print(f"\n‚ùå FATAL: Service did not bind port 8102 within 60 seconds")
            print("Dumping service status for debugging:")
            subprocess.run(["sc.exe", "query", "FortunaWebService"])
            sys.exit(1)

          time.sleep(2)

          print("\n--- HTTP Health Check ---")
          for attempt in range(5):
            try:
              req = urllib.request.Request(f"http://127.0.0.1:{PORT}/health")
              req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)')

              with urllib.request.urlopen(req, timeout=5) as response:
                if response.status == 200:
                  print(f"‚úÖ Health Check PASSED (HTTP 200).")
                  sys.exit(0)
                else:
                  print(f"‚ö†Ô∏è  Unexpected status {response.status}")

            except urllib.error.HTTPError as e:
              if e.code in [401, 403]:
                print(f"‚ö†Ô∏è  Got HTTP {e.code} ‚Äî service is responding!")
                sys.exit(0)
              print(f"Attempt {attempt + 1}: HTTP {e.code}")

            except Exception as e:
              print(f"Attempt {attempt + 1}: {type(e).__name__}: {e}")

            if attempt < 4:
              time.sleep(2)

          print("‚ùå Health Check FAILED after 5 attempts")
          sys.exit(1)

      - name: 'üì∏ The Paparazzi (Visual Proof)'
        shell: pwsh
        run: |
          Write-Host "Installing Playwright for visual verification..."
          python -m pip install playwright
          python -m playwright install chromium

          # Default to 8102 if SERVICE_PORT is not set
          $port = "${{ env.SERVICE_PORT }}"
          if ([string]::IsNullOrWhiteSpace($port)) { $port = "8102" }

          Write-Host "Taking screenshot of http://localhost:$port..."
          python -c "
          from playwright.sync_api import sync_playwright
          import sys

          try:
              with sync_playwright() as p:
                  browser = p.chromium.launch()
                  page = browser.new_page()
                  # Try index.html, fall back to root if needed
                  url = f'http://localhost:{sys.argv[1]}/index.html'
                  print(f'Navigating to {url}...')
                  page.goto(url)
                  # Wait a moment for React/Next.js hydration if needed
                  page.wait_for_timeout(2000)
                  page.screenshot(path='proof-of-life.png', full_page=True)
                  browser.close()
              print('‚úÖ Screenshot captured.')
          except Exception as e:
              print(f'‚ùå Screenshot failed: {e}')
              # We do not fail the build for this; it is a bonus artifact.
              sys.exit(0)
          " $port

      - name: üì§ Upload Visual Proof
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-proof-${{ github.run_id }}
          path: proof-of-life.png
          retention-days: 7

      - name: Gather diagnostics
        if: failure()
        shell: pwsh
        run: |
          $diag = Join-Path $PWD "installer-diag"
          Remove-Item $diag -Recurse -Force -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $diag | Out-Null
          Copy-Item -Path msi-install.log -Destination $diag -Force
          Copy-Item -Path "C:\ProgramData\Fortuna\logs\*.log" -Destination $diag -Force -ErrorAction SilentlyContinue
          Copy-Item -Path "C:\Program Files\Fortuna Faucet\*" -Destination $diag -Recurse -Force -ErrorAction SilentlyContinue
      - name: üì§ Upload Logs on Failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: unified-smoke-test-logs-${{ github.run_id }}
          path: installer-diag
          retention-days: 7

      - name: üßπ Cleanup
        if: always()
        shell: pwsh
        run: |
          sc.exe stop FortunaWebService 2>&1 | Out-Null
          sc.exe delete FortunaWebService 2>&1 | Out-Null
          Remove-NetFirewallRule -DisplayName "FortunaWebService" -ErrorAction SilentlyContinue
          Write-Host "‚úÖ Cleanup complete"
