name: Unified MSI Builder (Jules's Gold Standard)

on:
  push:
    branches:
      - main

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.12'
  DOTNET_VERSION: '8.0.x'
  WIX_VERSION: '4.0.5'
  FRONTEND_DIR: 'web_platform/frontend'
  WIX_DIR: 'build_wix'

jobs:
  path-finder:
    name: 'üîé Path Finder - Dynamic Backend Detection'
    runs-on: windows-latest
    outputs:
      backend_dir: ${{ steps.find-path.outputs.backend_dir }}
      backend_module_path: ${{ steps.find-path.outputs.backend_module_path }}
      semver: ${{ steps.meta.outputs.semver }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Detect Backend Path
        id: find-path
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $web_service_path = "web_service/backend"
          $python_service_path = "python_service"
          if (Test-Path (Join-Path $web_service_path "main.py")) {
              $backend_dir = $web_service_path
              $backend_module_path = "web_service.backend"
              Write-Host "‚úÖ Verdict: Detected 'web_service/backend' as the target."
          } elseif (Test-Path (Join-Path $python_service_path "main.py")) {
              $backend_dir = $python_service_path
              $backend_module_path = "python_service"
              Write-Host "‚úÖ Verdict: Detected 'python_service' as the target."
          } else {
              Write-Error "‚ùå FATAL: Could not determine a valid backend directory."
              exit 1
          }
          "backend_dir=$backend_dir" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "backend_module_path=$backend_module_path" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Derive Build Metadata
        id: meta
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ref = "${{ github.ref }}"
          if ($ref -like 'refs/tags/v*') {
            $semver = $ref -replace 'refs/tags/v', ''
          } else {
            $semver = "0.0.${{ github.run_number }}"
          }
          "semver=$semver" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "üîñ Version: $semver"

  quality-gate:
    name: '‚úÖ Quality Gate'
    runs-on: windows-latest
    needs: path-finder
    env:
      BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: |
            ${{ env.BACKEND_DIR }}/requirements.txt
            ${{ env.BACKEND_DIR }}/requirements-dev.txt

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          if (Test-Path "${{ env.BACKEND_DIR }}/requirements-dev.txt") {
            pip install -r ${{ env.BACKEND_DIR }}/requirements-dev.txt
          } else {
            # Fallback to standard requirements if -dev is not found
            pip install -r ${{ env.BACKEND_DIR }}/requirements.txt
          }

      - name: Run Pytest
        shell: pwsh
        run: |
          # Check if pytest is installed before trying to run it
          $pytest_exists = Get-Command pytest -ErrorAction SilentlyContinue
          if (-not $pytest_exists) {
            Write-Host "‚ÑπÔ∏è pytest not found in dependencies, skipping tests."
            exit 0
          }

          python -m pytest ${{ env.BACKEND_DIR }}

          # Exit code 5 means no tests were found, which is not a failure in this context.
          if ($LASTEXITCODE -eq 5) {
            Write-Host "‚úÖ Pytest returned exit code 5 (No tests found), which is acceptable."
            exit 0
          } elseif ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Pytest failed with exit code $LASTEXITCODE."
            exit $LASTEXITCODE
          }
          Write-Host "‚úÖ Pytest suite passed."

  build-executable:
    name: 'üõ†Ô∏è Build Executable'
    runs-on: windows-latest
    needs: [path-finder, quality-gate]
    env:
      BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}
      BACKEND_MODULE_PATH: ${{ needs.path-finder.outputs.backend_module_path }}
    outputs:
      build_id: ${{ steps.vars.outputs.build_id }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set Build ID
        id: vars
        run: echo "build_id=${{ github.run_id }}-${{ github.run_attempt }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'

      - name: Install Frontend Dependencies & Build
        shell: pwsh
        run: |
          cd "${{ env.FRONTEND_DIR }}"
          npm ci --prefer-offline
          npm run build
          cd ../..

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: '${{ env.BACKEND_DIR }}/requirements.txt'

      - name: Install Backend Dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r ${{ env.BACKEND_DIR }}/requirements.txt
          pip install pyinstaller==6.6.0

      - name: Create Dynamic Spec for PyInstaller
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $entry_point = (Join-Path $env:BACKEND_DIR "main.py").Replace('\', '/')
          $submodules = "collect_submodules('{0}')" -f $env:BACKEND_MODULE_PATH
          $main_import = "'{0}.main'" -f $env:BACKEND_MODULE_PATH
          $staging_ui_path = (Resolve-Path "web_platform/frontend/out").Path.Replace('\', '/')
          $other_service = if ("${{ env.BACKEND_DIR }}" -eq "web_service/backend") { "python_service" } else { "web_service" }
          $backend_init = (Resolve-Path "web_service/backend/__init__.py").Path.Replace('\', '/')
          $parent_init = (Resolve-Path "web_service/__init__.py").Path.Replace('\', '/')
          $python_service_init = (Resolve-Path "python_service/__init__.py").Path.Replace('\', '/')

          # Ensure __init__.py files exist and are not empty to guarantee package recognition
          Set-Content -Path "web_service/__init__.py" -Value "# UNIFIED" -Force
          Set-Content -Path "web_service/backend/__init__.py" -Value "# UNIFIED" -Force
          Set-Content -Path "python_service/__init__.py" -Value "# UNIFIED" -Force

          $specContent = @(
            '# -*- mode: python ; coding: utf-8 -*-',
            '# DYNAMICALLY GENERATED SPEC - DO NOT EDIT MANUALLY',
            'import os',
            'from pathlib import Path',
            'from PyInstaller.utils.hooks import collect_data_files, collect_submodules',
            '',
            'block_cipher = None',
            'project_root = Path(os.getcwd())',
            '',
            '# Standard Data Collection (UI, package data, etc.)',
            'datas = [',
            "    ('$staging_ui_path', 'ui')",
            ']',
            "datas += collect_data_files('uvicorn')",
            "datas += collect_data_files('slowapi')",
            "datas += collect_data_files('structlog')",
            "datas += collect_data_files('certifi')",
            '',
            'hiddenimports = set()',
            'hiddenimports.update($submodules)',
            'hiddenimports.update([',
            "    'uvicorn.logging', 'uvicorn.loops.auto', 'uvicorn.lifespan.on',",
            "    'uvicorn.protocols.http.h11_impl', 'uvicorn.protocols.websockets.wsproto_impl',",
            "    'fastapi.routing', 'starlette.staticfiles', 'anyio._backends._asyncio',",
            "    'httpcore', 'httpx', 'slowapi', 'structlog', 'tenacity', 'aiosqlite',",
            "    'pydantic_core', 'pydantic_settings.sources', $main_import",
            '])',
            '',
            'a = Analysis(',
            "    ['$entry_point'],",
            '    pathex=[str(project_root)],',
            '    binaries=[],',
            '    datas=datas,',
            '    hiddenimports=sorted(hiddenimports),',
            '    hookspath=[],',
            '    runtime_hooks=[],',
            "    excludes=['tests', 'pytest', '$other_service'], # CRITICAL: Exclude the other service",
            '    win_no_prefer_redirects=False,',
            '    win_private_assemblies=False,',
            '    cipher=block_cipher,',
            '    noarchive=False',
            ')',
            '',
            "# ‚ò¢Ô∏è PYZ INJECTION: Force __init__ files into the PYZ archive as modules",
            "a.pure += [",
            "    ('web_service', '$parent_init', 'PYMODULE'),",
            "    ('web_service.backend', '$backend_init', 'PYMODULE'),",
            "    ('python_service', '$python_service_init', 'PYMODULE')",
            "]",
            '',
            'pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)',
            'exe = EXE(',
            '    pyz,',
            '    a.scripts,',
            '    a.binaries,',
            '    a.zipfiles,',
            '    a.datas,',
            '    [],',
            "    name='fortuna-backend',",
            '    debug=False,',
            '    bootloader_ignore_signals=False,',
            '    strip=False,',
            '    upx=True,',
            '    runtime_tmpdir=None,',
            '    console=False,',
            '    disable_windowed_traceback=False,',
            '    argv_emulation=False,',
            '    target_arch=None,',
            '    codesign_identity=None,',
            '    entitlements_file=None',
            ')'
          )
          # The pragmatic workflow uses a different spec file name, so we need to reflect that
          Set-Content -Path "pragmatic.spec" -Value ($specContent -join "`n")
          Write-Host "‚úÖ Dynamically generated 'pragmatic.spec' (unified logic) created."

      - name: Build with PyInstaller
        run: pyinstaller pragmatic.spec --clean --noconfirm

      - name: Upload Backend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist-${{ steps.vars.outputs.build_id }}
          path: dist/fortuna-backend.exe
          retention-days: 1

  package-msi:
    name: 'üíø Package MSI'
    runs-on: windows-latest
    needs: [path-finder, build-executable]
    outputs:
      build_id: ${{ needs.build-executable.outputs.build_id }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Backend Artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-dist-${{ needs.build-executable.outputs.build_id }}
          path: staging

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Prepare WiX Project
        shell: pwsh
        run: |
          Copy-Item "${{ env.WIX_DIR }}/Product_WithService.wxs" "${{ env.WIX_DIR }}/Product.wxs" -Force
          $wixProj = @(
            '<Project Sdk="WixToolset.Sdk/${{ env.WIX_VERSION }}">'
            '  <PropertyGroup>'
            '    <OutputName>Fortuna-WebService-Pragmatic</OutputName>'
            '    <OutputType>Package</OutputType>'
            '    <DefineConstants>SourceDir=../staging;Version=${{ needs.path-finder.outputs.semver }}</DefineConstants>'
            '  </PropertyGroup>'
            '  <ItemGroup>'
            '    <PackageReference Include="WixToolset.Util.wixext" Version="${{ env.WIX_VERSION }}" />'
            '  </ItemGroup>'
            '  <ItemGroup>'
            '    <Compile Include="Product.wxs" />'
            '  </ItemGroup>'
            '</Project>'
          )
          Set-Content "${{ env.WIX_DIR }}/Fortuna.wixproj" -Value ($wixProj -join "`n")

      - name: Build MSI
        working-directory: ${{ env.WIX_DIR }}
        run: dotnet build Fortuna.wixproj -c Release -p:Platform=x64

      - name: Upload MSI Artifact
        uses: actions/upload-artifact@v4
        with:
          name: msi-installer-${{ needs.build-executable.outputs.build_id }}
          path: ${{ env.WIX_DIR }}/bin/x64/Release/*.msi
          retention-days: 1

  smoke-test:
    name: 'üî¨ Smoke Test'
    runs-on: windows-latest
    needs: package-msi
    steps:
      - name: Download MSI Installer
        uses: actions/download-artifact@v4
        with:
          name: msi-installer-${{ needs.package-msi.outputs.build_id }}
          path: msi-installer

      - name: Install MSI
        shell: pwsh
        run: |
          $msi = Get-ChildItem -Path "msi-installer" -Filter "*.msi" -Recurse | Select-Object -First 1
          if (-not $msi) { Write-Error "MSI file not found"; exit 1 }
          Start-Process msiexec.exe -ArgumentList "/i `"$($msi.FullName)`" /qn" -Wait

      - name: Create Runtime Directories
        shell: pwsh
        run: |
          $installDir = "C:\Program Files\Fortuna Faucet"
          if (-not (Test-Path $installDir)) {
            Write-Error "Application was not installed correctly at $installDir"
            exit 1
          }
          New-Item -ItemType Directory -Path "$installDir\data" -Force | Out-Null
          New-Item -ItemType Directory -Path "$installDir\json" -Force | Out-Null
          New-Item -ItemType Directory -Path "$installDir\logs" -Force | Out-Null
          Write-Host "‚úÖ Created runtime directories in $installDir"

      - name: Launch Service & Verify Health
        env:
          SERVICE_PORT: '8102'
        shell: python
        run: |
          import os, sys, subprocess, socket, time, urllib.request
          from contextlib import closing

          HOST, PORT, TIMEOUT = "127.0.0.1", int(os.getenv("SERVICE_PORT", 8102)), 90
          HEALTH_ENDPOINT = "/health"

          def check_socket(h, p):
              with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
                  sock.settimeout(1)
                  return sock.connect_ex((h, p)) == 0

          print("--- Starting Smoke Test ---")
          try:
              print("Attempting to start the 'FortunaFaucetService'...")
              # Use CREATE_NO_WINDOW to prevent sc.exe from sometimes hanging in CI
              proc = subprocess.run(
                  ["sc.exe", "start", "FortunaFaucetService"],
                  capture_output=True, text=True, timeout=30,
                  creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0
              )
              print(f"SC.EXE STDOUT: {proc.stdout}")
              print(f"SC.EXE STDERR: {proc.stderr}")
              # SC start can return non-zero if service is already running, which is ok
              if proc.returncode != 0 and "already been started" not in proc.stderr:
                  print(f"WARNING: sc.exe exited with code {proc.returncode}")
          except Exception as e:
              print(f"Failed to start service (this might be okay): {e}")

          print(f"\n--- Waiting for service on {HOST}:{PORT} for up to {TIMEOUT}s ---")
          start_time = time.time()
          socket_bound = False
          while time.time() - start_time < TIMEOUT:
              if check_socket(HOST, PORT):
                  print(f"\n‚úÖ Socket is now bound! (Took {time.time() - start_time:.2f}s)")
                  socket_bound = True
                  break
              print(f"... waiting for socket ({time.time() - start_time:.1f}s)", end="\r")
              time.sleep(0.5)

          if not socket_bound:
              print(f"\n‚ùå FATAL: Timed out after {TIMEOUT}s waiting for port {PORT} to be bound.")
              sys.exit(1)

          time.sleep(2) # Give the service a moment to be ready for requests

          print("\n--- Performing HTTP Health Check ---")
          try:
              url = f"http://{HOST}:{PORT}{HEALTH_ENDPOINT}"
              print(f"Requesting {url}...")
              with urllib.request.urlopen(url, timeout=10) as response:
                  if response.status == 200:
                      print(f"‚úÖ Health check PASSED with status {response.status}.")
                      print("Smoke test successful!")
                      sys.exit(0)
                  else:
                      print(f"‚ùå Health check FAILED with status {response.status}.")
                      print(f"Response body: {response.read().decode('utf-8', 'ignore')}")
                      sys.exit(1)
          except Exception as e:
              print(f"‚ùå Health check FAILED with exception: {e}")
              sys.exit(1)

      - name: üì§ Upload Service Logs on Failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-logs-${{ needs.package-msi.outputs.build_id }}
          path: C:\Program Files\Fortuna Faucet\logs\
          retention-days: 7
          if-no-files-found: ignore

      - name: Cleanup
        if: always()
        run: |
          sc.exe stop FortunaFaucetService
          sc.exe delete FortunaFaucetService
