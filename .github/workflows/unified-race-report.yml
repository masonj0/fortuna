# unified-race-report.yml
name: 'Unified Race Report'

on:
  workflow_dispatch:
    inputs:
      force_refresh:
        description: 'Force refresh all data (ignore cache)'
        required: false
        default: 'false'
        type: boolean
      analyzer_type:
        description: 'Analyzer to use'
        required: false
        default: 'tiny_field_trifecta'
        type: choice
        options:
          - tiny_field_trifecta
          - value_bet
          - longshot_finder
  push:
    branches:
      - main
    paths:
      - 'scripts/**'
      - 'web_service/backend/**'
      - '.github/workflows/unified-race-report.yml'
  schedule:
    - cron: '0 6,12,18 * * *'

concurrency:
  group: race-report-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: '3.11'
  REPORT_RETENTION_DAYS: 14
  MAX_RETRIES: 3
  REQUEST_TIMEOUT: 30

jobs:
  generate-unified-report:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    permissions:
      contents: read
      actions: write

    outputs:
      race_count: ${{ steps.run-reporter.outputs.race_count }}
      status: ${{ steps.run-reporter.outputs.status }}

    steps:
      - name: 'ğŸ“¥ Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 'ğŸ Setup Python'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: 'web_service/backend/requirements.txt'

      - name: 'ğŸ–¥ï¸ Install System Dependencies'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            xvfb \
            libnss3 \
            libnspr4 \
            libatk1.0-0 \
            libatk-bridge2.0-0 \
            libcups2 \
            libdrm2 \
            libxkbcommon0 \
            libxcomposite1 \
            libxdamage1 \
            libxfixes3 \
            libxrandr2 \
            libgbm1 \
            libasound2 \
            libpango-1.0-0 \
            libcairo2 \
            libatspi2.0-0 \
            libgtk-3-0 \
            libdbus-glib-1-2 \
            libxt6 \
            libx11-xcb1

      - name: 'ğŸ“¦ Install Python Dependencies'
        run: |
          python -m pip install --upgrade pip wheel setuptools
          pip install -r web_service/backend/requirements.txt

      - name: 'ğŸ¦Š Install Scrapling Browsers'
        run: |
          # Install Camoufox browser (used by StealthyFetcher/StealthySession)
          echo "Installing Camoufox browser for Scrapling..."
          python -m camoufox fetch

          # Verify camoufox installation
          python -c "import camoufox; print(f'âœ… Camoufox installed: {camoufox.__file__}')"

          # Also install Playwright browsers as fallback (if using PlayWrightFetcher)
          echo "Installing Playwright browsers as fallback..."
          playwright install chromium --with-deps || true

      - name: 'ğŸ–¥ï¸ Start Virtual Display'
        run: |
          # Start Xvfb in background
          sudo Xvfb :99 -screen 0 1920x1080x24 -ac +extension GLX +render -noreset &
          echo "DISPLAY=:99" >> $GITHUB_ENV
          sleep 3
          # Verify display is running
          if xdpyinfo -display :99 >/dev/null 2>&1; then
            echo "âœ… Virtual display :99 is running"
          else
            echo "âš ï¸ Virtual display may not be fully ready, continuing anyway..."
          fi

      - name: 'ğŸ§ª Verify Browser Installation'
        id: verify-browser
        run: |
          python - <<'PYTHON_SCRIPT'
          import asyncio
          import sys
          import traceback

          async def test_stealthy_browser():
              """Test Scrapling's StealthyFetcher with Camoufox."""
              print("=" * 60)
              print("Testing Scrapling StealthyFetcher (Camoufox)")
              print("=" * 60)

              try:
                  from scrapling.fetchers import StealthyFetcher
                  print("âœ“ Imported StealthyFetcher")

                  # Create fetcher instance
                  fetcher = StealthyFetcher(
                      headless=True,
                      network_idle=True,
                  )
                  print("âœ“ Created StealthyFetcher instance")

                  # Fetch a test page
                  print("â†’ Fetching https://httpbin.org/headers ...")
                  response = await fetcher.async_fetch('https://httpbin.org/headers')

                  print(f"âœ“ Response received")
                  print(f"  - Status: {response.status}")
                  print(f"  - Content length: {len(response.text)} chars")

                  if response.status == 200 and len(response.text) > 0:
                      print("\nâœ… StealthyFetcher verification PASSED!")
                      return True
                  else:
                      print(f"\nâŒ Unexpected response: status={response.status}")
                      return False

              except Exception as e:
                  print(f"\nâŒ StealthyFetcher failed: {e}")
                  traceback.print_exc()
                  return False

          async def test_playwright_browser():
              """Test Scrapling's PlayWrightFetcher as fallback."""
              print("\n" + "=" * 60)
              print("Testing Scrapling PlayWrightFetcher (Playwright/Chromium)")
              print("=" * 60)

              try:
                  from scrapling.fetchers import PlayWrightFetcher
                  print("âœ“ Imported PlayWrightFetcher")

                  fetcher = PlayWrightFetcher(
                      headless=True,
                      network_idle=True,
                  )
                  print("âœ“ Created PlayWrightFetcher instance")

                  print("â†’ Fetching https://httpbin.org/headers ...")
                  response = await fetcher.async_fetch('https://httpbin.org/headers')

                  print(f"âœ“ Response received")
                  print(f"  - Status: {response.status}")
                  print(f"  - Content length: {len(response.text)} chars")

                  if response.status == 200:
                      print("\nâœ… PlayWrightFetcher verification PASSED!")
                      return True
                  return False

              except Exception as e:
                  print(f"\nâŒ PlayWrightFetcher failed: {e}")
                  traceback.print_exc()
                  return False

          async def main():
              # Test StealthyFetcher first (primary)
              stealthy_ok = await test_stealthy_browser()

              # Test PlayWrightFetcher as fallback
              playwright_ok = await test_playwright_browser()

              print("\n" + "=" * 60)
              print("VERIFICATION SUMMARY")
              print("=" * 60)
              print(f"  StealthyFetcher (Camoufox):  {'âœ… PASS' if stealthy_ok else 'âŒ FAIL'}")
              print(f"  PlayWrightFetcher (Chromium): {'âœ… PASS' if playwright_ok else 'âŒ FAIL'}")

              # Pass if at least one works
              if stealthy_ok or playwright_ok:
                  print("\nğŸ‰ At least one browser backend is working!")
                  return 0
              else:
                  print("\nğŸ’¥ All browser backends failed!")
                  return 1

          sys.exit(asyncio.run(main()))
          PYTHON_SCRIPT

      - name: 'ğŸ“‚ Create Runtime Directories'
        run: |
          mkdir -p web_service/backend/{data,json,logs}
          mkdir -p reports/archive

      - name: 'ğŸ”„ Restore Data Cache'
        if: inputs.force_refresh != 'true'
        uses: actions/cache@v4
        with:
          path: |
            web_service/backend/data/*.cache
            web_service/backend/json/*.cache
          key: race-data-${{ runner.os }}-${{ github.run_number }}
          restore-keys: |
            race-data-${{ runner.os }}-

      - name: 'ğŸš€ Run Unified Reporter'
        id: run-reporter
        env:
          ANALYZER_TYPE: ${{ inputs.analyzer_type || 'tiny_field_trifecta' }}
          FORCE_REFRESH: ${{ inputs.force_refresh || 'false' }}
          MAX_RETRIES: ${{ env.MAX_RETRIES }}
          REQUEST_TIMEOUT: ${{ env.REQUEST_TIMEOUT }}
          CI: 'true'
        run: |
          set -o pipefail
          python scripts/fortuna_reporter.py 2>&1 | tee reporter_output.log

          if [ -f "qualified_races.json" ]; then
            RACE_COUNT=$(python scripts/get_race_count.py)
            echo "race_count=${RACE_COUNT}" >> $GITHUB_OUTPUT
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "race_count=0" >> $GITHUB_OUTPUT
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: 'ğŸ“Š Upload Report Artifacts'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: race-reports-${{ github.run_number }}-${{ github.run_attempt }}
          path: |
            race-report.html
            qualified_races.json
            raw_race_data.json
            reporter_output.log
            atr_debug.html
            sl_debug.html
            brisnet_debug.html
            equibase_debug.html
            oddschecker_debug.html
            racingpost_debug.html
            timeform_debug.html
            twinspires_debug.html
          retention-days: ${{ env.REPORT_RETENTION_DAYS }}
          if-no-files-found: warn
          compression-level: 9

      - name: 'ğŸ“ Post Summary to GitHub Actions'
        if: always()
        run: |
          {
            echo "## ğŸ´ Fortuna Race Report Summary"
            echo ""
            echo "**Run:** #${{ github.run_number }} | **Status:** ${{ steps.run-reporter.outputs.status || 'unknown' }}"
            echo "**Analyzer:** ${{ inputs.analyzer_type || 'tiny_field_trifecta' }}"
            echo ""

            if [ -f "github_summary.md" ]; then
              cat github_summary.md
            else
              echo "### âš ï¸ Detailed summary not available"
              echo ""
              echo "Check the artifacts for the full report."
            fi

            echo ""
            echo "---"
            echo "*Generated at $(date -u '+%Y-%m-%d %H:%M:%S UTC')*"
          } >> $GITHUB_STEP_SUMMARY

      - name: 'Install bs4 for HTML Analysis'
        if: failure()
        run: pip install beautifulsoup4

      - name: 'Analyze HTML on Failure'
        if: failure()
        run: |
          mkdir -p debug-analysis
          for html_file in sl_debug.html atr_debug.html brisnet_debug.html equibase_debug.html oddschecker_debug.html racingpost_debug.html timeform_debug.html twinspires_debug.html; do
            if [ -f "$html_file" ]; then
              base_name="${html_file%.html}"
              python scripts/debug_html_parser.py "$html_file" "debug-analysis/${base_name}_analysis.json" || true
            fi
          done

      - name: 'Upload Debug Analysis Artifact'
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: debug-analysis-${{ github.run_number }}
          path: debug-analysis/
          retention-days: ${{ env.REPORT_RETENTION_DAYS }}

      - name: 'ğŸ§¹ Cleanup on Failure'
        if: failure()
        run: |
          echo "::warning::Report generation failed. Check logs for details."
          if ls *.json 1> /dev/null 2>&1; then
            tar -czf debug-data.tar.gz *.json *.log 2>/dev/null || true
          fi

      - name: 'â¬†ï¸ Upload Browser Logs on Failure'
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: browser-debug-logs-${{ github.run_number }}
          path: |
            ~/.cache/ms-playwright
            ~/.cache/camoufox
          retention-days: ${{ env.REPORT_RETENTION_DAYS }}
          if-no-files-found: 'warn'

  notify-on-failure:
    needs: generate-unified-report
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'schedule'
    steps:
      - name: 'ğŸš¨ Create Failure Issue'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `ğŸš¨ Scheduled Race Report Failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## Automated Report Failure

            The scheduled race report generation failed.

            **Run ID:** ${{ github.run_id }}
            **Run Number:** ${{ github.run_number }}
            **Workflow:** ${{ github.workflow }}

            [View Run Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated-failure'
            });

            const existingIssue = issues.find(i => i.title.startsWith('ğŸš¨ Scheduled Race Report Failed'));

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['automated-failure', 'bug']
              });
            }
