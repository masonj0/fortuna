name: 'Run 4-Step Diagnostic Smoke Test'
description: 'Installs an MSI, then runs a 4-step diagnostic to verify file installation, service status, port binding, and API health, finishing with a Paparazzi screenshot.'

inputs:
  msi-artifact-name:
    description: 'The name of the MSI artifact to download.'
    required: true
  service-name:
    description: 'The name of the Windows Service to verify (e.g., FortunaWebService).'
    required: true
  executable-path:
    description: 'The full, absolute path to the installed service executable to verify.'
    required: true
  port:
    description: 'The port to check for a listener.'
    required: true
  firewall-rule-name:
    description: 'The name of the firewall rule to create.'
    required: true

runs:
  using: "composite"
  steps:
    - name: ðŸ“¥ Download MSI Artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.msi-artifact-name }}
        path: installer

    - name: ðŸ›¡ï¸ Firewall & Install
      shell: pwsh
      run: |
        New-NetFirewallRule -DisplayName "${{ inputs.firewall-rule-name }}" -Direction Inbound -LocalPort ${{ inputs.port }} -Protocol TCP -Action Allow
        if (Get-Service -Name "${{ inputs.service-name }}" -ErrorAction SilentlyContinue) {
          sc.exe stop "${{ inputs.service-name }}" 2>&1 | Out-Null
          sc.exe delete "${{ inputs.service-name }}" 2>&1 | Out-Null
        }
        $msi = Get-ChildItem installer -Filter "*.msi" -Recurse | Select-Object -First 1
        if (!$msi) { throw "No MSI found" }
        Write-Host "Installing $($msi.Name)..."
        $msiPath = $msi.FullName
        $args = "/i `"$msiPath`" /qn /L*v installation.log"
        $proc = Start-Process msiexec.exe -ArgumentList $args -Wait -NoNewWindow -PassThru
        if ($proc.ExitCode -ne 0) {
          Get-Content installation.log -Tail 50
          throw "Install failed with code $($proc.ExitCode)"
        }

    - name: "ðŸ” Diag 1: Verify Install Directory"
      shell: pwsh
      run: |
        $expected = "${{ inputs.executable-path }}"
        if (Test-Path $expected) {
          Write-Host "âœ… Binary FOUND at: $expected"
        } else {
          Write-Error "âŒ Binary MISSING at: $expected"
          Write-Host "Listing C:\Program Files to see what happened:"
          Get-ChildItem "C:\Program Files" -Recurse -Depth 2 | Select-Object FullName
          exit 1
        }

    - name: "ðŸ” Diag 2: Check Windows Service Status"
      shell: pwsh
      run: |
        $svc = Get-Service "${{ inputs.service-name }}" -ErrorAction SilentlyContinue
        if (!$svc) {
          Write-Error "âŒ Service '${{ inputs.service-name }}' is NOT registered! MSI Install failed to register service."
          exit 1
        }
        Write-Host "Service Status: $($svc.Status)"

        if ($svc.Status -ne 'Running') {
          Write-Host "âš ï¸ Service is not running. Attempting to start..."
          Start-Service "${{ inputs.service-name }}"
          Start-Sleep -Seconds 5
          $svc = Get-Service "${{ inputs.service-name }}"
        }

        if ($svc.Status -eq 'Running') {
          Write-Host "âœ… Service is RUNNING"
        } else {
          Write-Error "âŒ Service failed to start. Status: $($svc.Status)"
          Write-Host "Dumping Event Logs for Service Failure:"
          Get-EventLog -LogName System -Source "Service Control Manager" -Newest 20 | Format-Table -AutoSize
          exit 1
        }

    - name: "ðŸ” Diag 3: Port Listener Check"
      shell: pwsh
      run: |
        Write-Host "Starting Port Hunt on ${{ inputs.port }}..."
        $max = 30
        for ($i=1; $i -le $max; $i++) {
          $conn = Get-NetTCPConnection -LocalPort ${{ inputs.port }} -ErrorAction SilentlyContinue
          if ($conn) {
            Write-Host "âœ… Port ${{ inputs.port }} is OPEN (State: $($conn.State))"
            exit 0
          }
          Write-Host "â³ Attempt $i of $max: Port not open yet..."
          Start-Sleep -Seconds 2
        }
        Write-Error "âŒ Timeout: Nothing is listening on Port ${{ inputs.port }} after 60 seconds."
        Write-Host "Checking for ANY relevant processes:"
        Get-Process | Where-Object { $_.ProcessName -match "fortuna|python" } | Format-Table Id, ProcessName, Responding
        exit 1

    - name: "ðŸ” Diag 4: HTTP Health Probe"
      shell: pwsh
      run: |
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:${{ inputs.port }}/health" -UseBasicParsing
          if ($response.StatusCode -eq 200) {
            Write-Host "âœ… HTTP 200 OK received. System is GREEN."
            Write-Host $response.Content
          } else {
            Write-Error "âŒ HTTP Error: $($response.StatusCode)"
            exit 1
          }
        } catch {
          Write-Error "âŒ HTTP Request Failed: $_"
          exit 1
        }

    - name: 'ðŸ“¸ The Paparazzi (Visual Proof)'
      shell: pwsh
      run: |
        Write-Host "Installing Playwright..."
        npm install playwright
        npx playwright install chromium --with-deps

        $url = "http://127.0.0.1:${{ inputs.port }}/docs"

        node -e "
          const { chromium } = require('playwright');
          (async () => {
            try {
              const browser = await chromium.launch();
              const page = await browser.newPage();
              await page.goto('$url', { timeout: 15000 });
              await page.waitForSelector('.swagger-ui', { timeout: 5000 }).catch(() => console.log('UI not fully loaded, snapping anyway...'));
              await page.screenshot({ path: 'proof-of-life.png', fullPage: true });
              await browser.close();
            } catch (e) {
              console.error(e); process.exit(1);
            }
          })();
        "

    - name: Upload Visual Proof
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: visual-proof-${{ github.run_id }}
        path: proof-of-life.png

    - name: ðŸ§¹ Cleanup
      if: always()
      shell: pwsh
      run: |
        sc.exe stop ${{ inputs.service-name }}
        sc.exe delete ${{ inputs.service-name }}
        Remove-NetFirewallRule -DisplayName "${{ inputs.firewall-rule-name }}" -ErrorAction SilentlyContinue
