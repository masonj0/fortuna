name: 'Run Smoke Test (Socket Handover)'
description: 'Launches an executable, waits for a socket to be bound, and performs a health check.'
inputs:
  exe-path:
    description: 'Path to the executable to launch'
    required: true
  service-port:
    description: 'Port to wait for on localhost'
    required: true
  health-endpoint:
    description: 'Health endpoint to check (e.g., /health)'
    required: false
    default: '/health'
  api-key:
    description: 'API key for the service'
    required: false
runs:
  using: 'composite'
  steps:
    - name: Run Python Smoke Test
      shell: python
      run: |
        import os, sys, subprocess, socket, time, threading
        from contextlib import closing

        # --- CONFIGURATION ---
        EXE_PATH = os.environ.get("INPUT_EXE-PATH")
        HOST = "127.0.0.1"
        PORT = int(os.environ.get("INPUT_SERVICE-PORT"))
        HEALTH_ENDPOINT = os.environ.get("INPUT_HEALTH-ENDPOINT", "/health")
        API_KEY = os.environ.get("INPUT_API-KEY", "default-key")
        STARTUP_TIMEOUT = 90  # seconds
        POLL_INTERVAL = 0.5   # seconds
        STDOUT_LOG = "service-logs/stdout.txt"
        STDERR_LOG = "service-logs/stderr.txt"
        PID_FILE = "service.pid"

        # --- UTILITY FUNCTIONS ---
        def print_banner(message):
            print(f"\\n{'='*25} {message} {'='*25}")

        def check_socket(host, port):
            with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
                return sock.connect_ex((host, port)) == 0

        def tail_file(filename, lines=10):
            try:
                with open(filename, "r") as f:
                    content = f.readlines()
                return "".join(content[-lines:])
            except FileNotFoundError:
                return "Log file not found."
            except Exception as e:
                return f"Error reading log: {e}"

        # --- MAIN LOGIC ---
        def main():
            print_banner("SOCKET HANDOVER PROTOCOL INITIATED")

            # 1. Pre-flight check: Find a free port
            print(f"Checking if port {PORT} is available...")
            if check_socket(HOST, PORT):
                print(f"âŒ FATAL: Port {PORT} is already in use before starting the service.")
                sys.exit(1)
            print(f"âœ… Port {PORT} is free.")

            # 2. Launch the service executable
            print_banner(f"LAUNCHING {os.path.basename(EXE_PATH)}")
            launch_env = os.environ.copy()
            launch_env["FORTUNA_PORT"] = str(PORT)
            launch_env["API_KEY"] = API_KEY
            launch_env["FORTUNA_ENV"] = "smoke-test"
            launch_env["PYTHONUNBUFFERED"] = "1"

            if not os.path.exists(EXE_PATH):
                print(f"âŒ FATAL: Executable not found at {EXE_PATH}")
                sys.exit(1)

            with open(STDOUT_LOG, "wb") as out_log, open(STDERR_LOG, "wb") as err_log:
                process = subprocess.Popen([EXE_PATH], env=launch_env, stdout=out_log, stderr=err_log)

            with open(PID_FILE, "w") as f:
                f.write(str(process.pid))
            print(f"ðŸš€ Service process started with PID: {process.pid}")
            print(f"   - stdout -> {STDOUT_LOG}")
            print(f"   - stderr -> {STDERR_LOG}")

            # 3. Wait for the socket to be bound
            print_banner(f"WAITING FOR SOCKET BIND ON {HOST}:{PORT}")
            start_time = time.time()
            bound = False
            while time.time() - start_time < STARTUP_TIMEOUT:
                if process.poll() is not None:
                    print(f"âŒ FATAL: Process terminated unexpectedly with exit code {process.poll()}.")
                    break
                if check_socket(HOST, PORT):
                    print(f"âœ… Socket is now bound! (Took {time.time() - start_time:.2f}s)")
                    bound = True
                    break
                time.sleep(POLL_INTERVAL)
                print(f"   ... waiting ({time.time() - start_time:.1f}s)", end="\\r")

            if not bound:
                print(f"âŒ FATAL: Timed out after {STARTUP_TIMEOUT}s waiting for port {PORT} to be bound.")

            # 4. Final Verification and Diagnostics
            print_banner("FINAL DIAGNOSTICS")
            print(f"STDOUT (Last 10 lines):\\n{tail_file(STDOUT_LOG)}")
            print(f"STDERR (Last 10 lines):\\n{tail_file(STDERR_LOG)}")

            if process.poll() is not None:
                print("âŒ Final state: PROCESS IS DEAD.")
                sys.exit(1)
            else:
                print("âœ… Final state: PROCESS IS ALIVE.")

            if not bound:
                print("âŒ Final state: SOCKET NOT BOUND.")
                sys.exit(1)
            else:
                print("âœ… Final state: SOCKET IS BOUND.")

            print_banner("SOCKET HANDOVER SUCCESSFUL")
            sys.exit(0)

        if __name__ == "__main__":
            main()
      env:
        INPUT_EXE-PATH: ${{ inputs.exe-path }}
        INPUT_SERVICE-PORT: ${{ inputs.service-port }}
        INPUT_HEALTH-ENDPOINT: ${{ inputs.health-endpoint }}
        INPUT_API-KEY: ${{ inputs.api-key }}