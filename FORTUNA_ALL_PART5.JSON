{
    ".github/scripts/generate_sbom.py": "import json\nfrom datetime import datetime\nfrom pathlib import Path\n\nfreeze = Path('backend/backend-freeze.txt')\npackages = []\nif freeze.exists():\n    for line in freeze.read_text().splitlines():\n        if '==' in line:\n            packages.append({\n                'name': line.split('==')[0],\n                'version': line.split('==')[1]\n            })\n\nsbom = {\n    'spdxVersion': 'SPDX-2.3',\n    'name': 'HatTrick Fusion Backend',\n    'packages': packages\n}\n\nPath('sbom.json').write_text(json.dumps(sbom, indent=2))\n",
    ".github/workflows/build-electron-hybrid.yml": "name:  Build Electron MSI (Hybrid V12 Engine)\n\non:\n  push:\n    branches: [ \"main\" ]\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  NODE_VERSION: '20'\n  PYTHON_VERSION: '3.12'\n  # Paths\n  BACKEND_DIR: 'python_service'\n  FRONTEND_DIR: 'web_platform/frontend'\n  ELECTRON_DIR: 'electron'\n  FORTUNA_PORT: '8102'\n  # Mock API keys for service startup\n  API_KEY: mock_key\n  TVG_API_KEY: mock\n  GREYHOUND_API_URL: http://mock\n  FORTUNA_ENV: smoke-test\n\njobs:\n  quality-gate:\n    name: 'Run Tests'\n    runs-on: windows-latest\n    timeout-minutes: 30\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.12'\n      - run: |\n          pip install -r python_service/requirements-dev.txt\n          pytest python_service/tests\n  # ==================================================================================\n  # JOB 1: BUILD CORE (The \"HatTrick\" Engine)\n  # ==================================================================================\n  build-core:\n    name: '\u2699\ufe0f Build Core Components'\n    runs-on: windows-latest\n    timeout-minutes: 30\n    needs: quality-gate\n    outputs:\n      semver: ${{ steps.meta.outputs.semver }}\n      build_id: ${{ steps.meta.outputs.build_id }}\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: \ud83d\udd16 Metadata\n        id: meta\n        shell: pwsh\n        run: |\n          $ver = if (\"${{ github.ref }}\" -match 'refs/tags/v(.*)') { $Matches[1] } else { \"0.0.${{ github.run_number }}\" }\n          \"semver=$ver\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"build_id=${{ github.run_id }}\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n\n      # --- FRONTEND (Standard) ---\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'\n\n      - name: \ud83c\udfa8 Build Frontend\n        shell: pwsh\n        run: |\n          cd ${{ env.FRONTEND_DIR }}\n          npm ci --prefer-offline\n          npm run build\n\n      # --- BACKEND (The \"HatTrick\" Upgrade) ---\n      - uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n\n      - name: \ud83d\udc0d Install Python Dependencies\n        run: |\n          pip install -r ${{ env.BACKEND_DIR }}/requirements-dev.txt\n          pip install pyinstaller==6.6.0\n\n      - name: \ud83d\udce6 Build Python Backend\n        shell: pwsh\n        env:\n          BACKEND_DIR: ${{ env.BACKEND_DIR }}\n          PYTHONUTF8: '1'\n        run: python scripts/generate_spec_electron.py\n\n      - name: \ud83d\udce4 Upload Backend Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-service-${{ github.run_id }}\n          path: dist/service/fortuna-backend/\n          retention-days: 1\n\n      - name: \ud83d\udce4 Upload Frontend Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: frontend-build-${{ github.run_id }}\n          path: ${{ env.FRONTEND_DIR }}/out/\n          retention-days: 1\n\n  # ==================================================================================\n  # JOB 2: PACKAGE ELECTRON (The \"Ironclad\" Chassis)\n  # ==================================================================================\n  package-electron:\n    name: '\u26a1 Package Electron MSI'\n    runs-on: windows-latest\n    needs: build-core\n    timeout-minutes: 30\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: '${{ env.ELECTRON_DIR }}/package-lock.json'\n\n      - name: \ud83d\udce5 Download Backend Artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: python-service-${{ github.run_id }}\n          path: python-service-bin\n\n      - name: \ud83d\udce5 Download Frontend Artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: frontend-build-${{ github.run_id }}\n          path: ${{ env.FRONTEND_DIR }}/out\n\n      - name: \ud83d\ude9a Stage Artifacts for Electron\n        shell: pwsh\n        run: |\n          # No staging needed, artifacts are downloaded to the correct locations\n          Write-Host \"Backend and Frontend artifacts downloaded to their respective directories.\"\n\n\n      - name: \ud83d\udcc4 Ensure WiX License Exists for electron-builder\n        shell: pwsh\n        run: |\n          # electron-builder uses build_wix/license.rtf by convention\n          $wixDir = 'build_wix'\n          if (-not (Test-Path $wixDir)) { New-Item -ItemType Directory -Path $wixDir | Out-Null }\n          $licensePath = Join-Path $wixDir 'license.rtf'\n          if (-not (Test-Path $licensePath)) {\n            Write-Host '\u26a0\ufe0f License file missing. Generating placeholder for electron-builder...'\n            $rtfContent = '{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0 Arial;}}\\f0\\fs24 END USER LICENSE AGREEMENT\\par\\par This is a placeholder license for Fortuna Faucet. Please replace with actual terms.}'\n            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii\n            Write-Host '\u2705 Placeholder license.rtf created.'\n          } else {\n            Write-Host '\u2705 Existing license.rtf found.'\n          }\n      - name: \ud83c\udfd7\ufe0f Build MSI\n        working-directory: ${{ env.ELECTRON_DIR }}\n        env:\n          CSC_IDENTITY_AUTO_DISCOVERY: 'false'\n        run: |\n          npm ci --prefer-offline\n          $ver = \"${{ needs.build-core.outputs.semver }}\"\n          npm run dist -- --win msi --config electron-builder-config.yml --publish never --config.artifactName=\"Fortuna-Electron-${ver}.msi\"\n\n      - name: \ud83d\udd2c Forensic Packaging Analysis\n        shell: pwsh\n        run: |\n          Write-Host \"=== HYBRID STAGING LAYOUT ===\"\n          Get-ChildItem -Path \"${{ env.ELECTRON_DIR }}/dist/win-unpacked\" -Recurse | Select-Object FullName, Length\n\n      - name: '\ud83d\udc24 The Canary (Malware Pre-Flight)'\n        shell: pwsh\n        continue-on-error: true\n        run: |\n          $msi = Get-ChildItem -Recurse -Filter \"*.msi\" | Select-Object -First 1\n          if (!$msi) { Write-Warning \"No MSI found to scan.\"; exit 0 }\n\n          Write-Host \"\ud83d\udd0d Scanning $($msi.Name) with Windows Defender...\"\n          $defender = \"C:\\Program Files\\Windows Defender\\MpCmdRun.exe\"\n\n          if (-not (Test-Path $defender)) {\n              Write-Warning \"Windows Defender CLI not found at expected path.\"\n              exit 0\n          }\n\n          # ScanType 3 = File/Custom Scan\n          $proc = Start-Process -FilePath $defender -ArgumentList \"-Scan -ScanType 3 -File `\"$($msi.FullName)`\"\" -Wait -PassThru -NoNewWindow\n\n          if ($proc.ExitCode -eq 0) {\n              Write-Host \"\u2705 CLEAN: Windows Defender found no threats.\" -ForegroundColor Green\n          } elseif ($proc.ExitCode -eq 2) {\n              Write-Error \"\ud83d\udea8 THREAT DETECTED: Windows Defender flagged this installer!\"\n              exit 1\n          } else {\n              Write-Warning \"\u26a0\ufe0f Scan completed with inconclusive exit code: $($proc.ExitCode)\"\n          }\n\n      - name: \ud83d\udce4 Upload MSI\n        uses: actions/upload-artifact@v4\n        with:\n          name: electron-msi-${{ github.run_id }}\n          path: ${{ env.ELECTRON_DIR }}/dist/*.msi\n          retention-days: 1\n\n  # ==================================================================================\n  # JOB 3: SMOKE TEST (The \"Robust\" Verification)\n  # ==================================================================================\n  smoke-test:\n    name: '\ud83d\udd2c Smoke Test'\n    runs-on: windows-latest\n    needs: package-electron\n    timeout-minutes: 30\n    steps:\n      - name: \ud83d\udce5 Download MSI\n        uses: actions/download-artifact@v4\n        with:\n          name: electron-msi-${{ github.run_id }}\n          path: installer\n\n      - name: Configure Firewall\n        shell: pwsh\n        run: |\n          New-NetFirewallRule -DisplayName \"FortunaTest\" -Direction Inbound -LocalPort 8102 -Protocol TCP -Action Allow\n\n      - name: \ud83e\udd2b Install & Verify\n        shell: pwsh\n        run: |\n          $msi = Get-ChildItem \"installer\" -Filter \"*.msi\" -Recurse | Select -First 1\n          if (!$msi) { throw \"No MSI found\" }\n\n          Write-Host \"Installing $($msi.Name)...\"\n          # EXOTIC INGREDIENT: PassThru for accurate exit codes\n          $proc = Start-Process msiexec.exe -ArgumentList \"/i `\"$($msi.FullName)`\" /qn /L*v install.log\" -Wait -PassThru\n\n          if ($proc.ExitCode -ne 0) {\n            Get-Content install.log -Tail 50\n            throw \"Install failed with code $($proc.ExitCode)\"\n          }\n\n      - name: '\u2705 Create Required Runtime Directories Post-Install'\n        shell: pwsh\n        run: |\n          $installRoot = \"C:\\Program Files\\Fortuna Faucet\"\n          if (-not (Test-Path $installRoot)) {\n            Write-Error \"Installation directory not found at $installRoot. Cannot create runtime directories.\"\n            exit 1\n          }\n          New-Item -Path \"$installRoot\\data\" -ItemType Directory -Force | Out-Null\n          New-Item -Path \"$installRoot\\json\" -ItemType Directory -Force | Out-Null\n          New-Item -Path \"$installRoot\\logs\" -ItemType Directory -Force | Out-Null\n          Write-Host \"\u2705 Created data, json, and logs directories in $installRoot\"\n\n      - name: \ud83d\udd0d Debug Backend Launch (Direct Execution)\n        shell: pwsh\n        run: |\n          $paths = @(\n            \"C:\\Program Files\\Fortuna Faucet\\resources\\resources\\python-service-bin\\fortuna-backend.exe\",\n            \"C:\\Program Files\\Fortuna Faucet\\resources\\python-service-bin\\fortuna-backend.exe\"\n          )\n          $exe = $paths | Where-Object { Test-Path $_ } | Select-Object -First 1\n\n          if ($exe) {\n            Write-Host \"Found backend at: $exe\"\n            Write-Host \"Running diagnostic...\"\n            & $exe --help 2>&1 | Tee-Object -FilePath \"backend_debug.log\"\n            Get-Content \"backend_debug.log\"\n          } else {\n            Write-Warning \"Backend binary not found. Dumping file structure:\"\n            Get-ChildItem \"C:\\Program Files\\Fortuna Faucet\" -Recurse | Select-Object FullName\n          }\n\n      - name: \ud83d\ude80 Launch & Wait (Port Detection)\n        shell: pwsh\n        run: |\n          $root = 'C:\\Program Files\\Fortuna Faucet'\n          $exe = Get-ChildItem $root -Filter \"*.exe\" -Recurse | Where { $_.Name -notmatch 'uninstall' } | Select -First 1\n          if (!$exe) { throw \"Executable not found in $root\" }\n\n          Write-Host \"Target: $($exe.FullName)\"\n\n          # Create Log Directory\n          $logDir = \"C:\\Temp\\fortuna-logs\"\n          New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n\n          # Launch Electron with Log Redirection\n          # We use Start-Process to detach, but redirect streams\n          $proc = Start-Process -FilePath $exe.FullName -ArgumentList \"--no-sandbox\" -NoNewWindow -PassThru -RedirectStandardOutput \"$logDir\\stdout.log\" -RedirectStandardError \"$logDir\\stderr.log\"\n\n          Write-Host \"Electron launched (PID: $($proc.Id)). Waiting for Port 8102...\"\n\n          # Wait for Port 8102 (The Backend)\n          $deadline = (Get-Date).AddSeconds(60)\n          $connected = $false\n\n          while ((Get-Date) -lt $deadline) {\n            try {\n              $tcp = New-Object System.Net.Sockets.TcpClient\n              $tcp.Connect('127.0.0.1', 8102)\n              $tcp.Close()\n              Write-Host \"\u2705 SUCCESS: Backend is listening on port 8102!\" -ForegroundColor Green\n              $connected = $true\n              break\n            } catch {\n              Write-Host \"  ...waiting for port...\"\n              Start-Sleep 2\n            }\n          }\n\n          if (-not $connected) {\n            Write-Error \"\u274c TIMEOUT: Backend did not bind port 8102.\"\n\n            Write-Host \"--- ELECTRON STDOUT ---\"\n            if (Test-Path \"$logDir\\stdout.log\") { Get-Content \"$logDir\\stdout.log\" -Tail 50 }\n\n            Write-Host \"--- ELECTRON STDERR ---\"\n            if (Test-Path \"$logDir\\stderr.log\") { Get-Content \"$logDir\\stderr.log\" -Tail 50 }\n\n            exit 1\n          }\n\n      - name: \"\ud83d\udc80 CSI: Windows (Post-Mortem Diagnostics)\"\n        if: failure()\n        shell: pwsh\n        run: |\n          Write-Host \"=== BACKEND LOGS (If Available) ===\"\n          if (Test-Path \"C:\\ProgramData\\Fortuna\\logs\\backend.log\") { Get-Content \"C:\\ProgramData\\Fortuna\\logs\\backend.log\" -Tail 100 }\n          Write-Host \"=== PORT 8102 LISTENER ===\"\n          netstat -an | findstr \"8102\"\n          Write-Host \"=== RUNNING PROCESSES ===\"\n          tasklist /FI \"IMAGENAME eq fortuna*\"\n\n      - name: '\ud83d\udcf8 The Paparazzi (Visual Proof)'\n        shell: pwsh\n        run: |\n          Write-Host \"Installing Playwright (Node.js)...\"\n          npm install playwright\n          npx playwright install chromium --with-deps\n\n          $port = \"${{ env.FORTUNA_PORT }}\"\n          $url = \"http://127.0.0.1:$port/health\"\n\n          Write-Host \"Capturing screenshot of $url...\"\n          node -e \"\n            const { chromium } = require('playwright');\n            (async () => {\n              try {\n                const browser = await chromium.launch();\n                const page = await browser.newPage();\n                console.log('Navigating to $url...');\n                await page.goto('$url', { timeout: 15000 });\n                await page.screenshot({ path: 'proof-of-life.png', fullPage: true });\n                console.log('\u2705 Screenshot captured: proof-of-life.png');\n                await browser.close();\n              } catch (e) {\n                console.error('\u274c Paparazzi Failed:', e);\n                process.exit(1);\n              }\n            })();\n          \"\n\n      - name: \ud83d\udce4 Upload Visual Proof\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: visual-proof-${{ github.run_id }}\n          path: proof-of-life.png\n          retention-days: 7\n\n      - name: \ud83e\uddf9 Cleanup\n        if: always()\n        run: Stop-Process -Name \"Fortuna Faucet\", \"fortuna-backend\" -Force -ErrorAction SilentlyContinue\n\n  # ==================================================================================\n  # JOB 4: RELEASE (The \"Triple-Tap\" Staging)\n  # ==================================================================================\n  release:\n    name: '\ud83d\udce6 Release'\n    runs-on: windows-latest\n    needs: smoke-test\n    timeout-minutes: 30\n    steps:\n      - name: \ud83d\udce5 Download MSI\n        uses: actions/download-artifact@v4\n        with:\n          name: electron-msi-${{ github.run_id }}\n          path: staging\n\n      - name: \ud83d\ude9a Robocopy Safe-Stage\n        shell: pwsh\n        run: |\n          $dest = \"final-artifact\"\n          New-Item -ItemType Directory -Path $dest -Force | Out-Null\n\n          # EXOTIC INGREDIENT: The Robocopy Logic that finally worked\n          robocopy staging $dest /E /np\n\n          # 0-3 = Success. 4+ = Error.\n          if ($LASTEXITCODE -le 3) {\n            Write-Host \"\u2705 Staged successfully.\"\n            exit 0\n          } else {\n            throw \"Robocopy failed with code $LASTEXITCODE\"\n          }\n\n      - name: \ud83d\udce4 Upload Final\n        uses: actions/upload-artifact@v4\n        with:\n          name: Final-Electron-MSI\n          path: final-artifact/\n",
    ".github/workflows/build-electron-msi-gpt5.yml": "# System Timestamp: 2025-12-07 15:30:00\nname: \ud83d\udd28 Build Electron MSI Installer (Production)\n\non:\n  push:\n    branches: [\"main\"]\n  pull_request:\n    branches: [ \"main\" ]\n  schedule:\n    - cron: '0 2 * * *'\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  NODE_VERSION: '18'\n  PYTHON_VERSION: '3.11'\n  ELECTRON_BUILDER_CACHE: ${{ github.workspace }}/.cache/electron-builder\n  BACKEND_DIR: 'web_service/backend'\n  PYTHONUTF8: '1'\n  FORTUNA_PORT: '8102'\n  API_KEY: mock_key\n  FORTUNA_ENV: smoke-test\n  TVG_API_KEY: mock\n  GREYHOUND_API_URL: http://mock\n\njobs:\n  validate-environment:\n    name: \u2705 Pre-flight Validation\n    runs-on: windows-latest\n    timeout-minutes: 30\n    outputs:\n      node_version: ${{ steps.versions.outputs.node }}\n      python_version: ${{ steps.versions.outputs.python }}\n      build_id: ${{ steps.versions.outputs.build_id }}\n      semver: ${{ steps.meta.outputs.semver }}\n      short_sha: ${{ steps.meta.outputs.short_sha }}\n    steps:\n      - name: \ud83e\uddf9 Clean Previous Build Artifacts\n        shell: pwsh\n        run: |\n          Remove-Item -Path \"electron/dist\" -Recurse -Force -ErrorAction SilentlyContinue\n          Remove-Item -Path \"build_wix\" -Recurse -Force -ErrorAction SilentlyContinue\n          Write-Host \"\u2705 Cleaned up previous build directories.\"\n\n      - name: \ud83d\udce5 Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n\n      - name: \ud83d\udd0d Verify Critical Files Exist\n        shell: pwsh\n        run: |\n          # FIX: Removed dynamic spec file from check\n          $criticalFiles = @(\n            'electron/electron-builder-config.yml',\n            'web_platform/frontend/package.json',\n            '${{ env.BACKEND_DIR }}/requirements-dev.txt',\n            'electron/package.json'\n          )\n\n          $manifest = @{\n            timestamp = Get-Date -Format 'o'\n            checks = @()\n            errors = @()\n          }\n\n          foreach ($file in $criticalFiles) {\n            if (Test-Path -LiteralPath $file) {\n              $hash = (Get-FileHash -LiteralPath $file -Algorithm SHA256).Hash\n              $manifest.checks += @{\n                file = $file\n                exists = $true\n                sha256 = $hash\n              }\n              Write-Host \"\u2713 $file ($hash.Substring(0,8)...)\"\n            } else {\n              $manifest.errors += @{ file = $file; error = 'MISSING' }\n              Write-Error \"\u2717 CRITICAL: $file not found\"\n              exit 1\n            }\n          }\n\n          $manifest | ConvertTo-Json | Out-File -FilePath \".\\\\validation-manifest.json\"\n          Write-Host \"Manifest saved\"\n\n      - name: \ud83d\udcca Capture Version Information\n        id: versions\n        shell: pwsh\n        run: |\n          $nodeVersion = node --version\n          $pythonVersion = python --version\n          $buildId = \"${{ github.run_id }}-${{ github.run_attempt }}\"\n\n          Write-Host \"Node: $nodeVersion\"\n          Write-Host \"Python: $pythonVersion\"\n          Write-Host \"Build ID: $buildId\"\n\n          \"node=$nodeVersion\" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"python=$pythonVersion\" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"build_id=$buildId\" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append\n\n      - name: \ud83d\udea8 Capture Environment State\n        if: always()\n        shell: pwsh\n        run: |\n          New-Item -ItemType Directory -Path \"debug-artifacts\" -Force | Out-Null\n\n          # System info\n          systeminfo | Out-File \"debug-artifacts/systeminfo.txt\"\n          Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber | Out-File \"debug-artifacts/os-version.txt\"\n\n          # Disk space\n          $free = (Get-Volume | Where DriveLetter -eq 'C').SizeRemaining\n          if ($free -lt 10GB) { Write-Error \"Insufficient disk space\"; exit 1 }\n          Get-Volume | Out-File \"debug-artifacts/disk-space.txt\"\n\n          # File permissions - FIX: $. to $_.\n          Get-ChildItem -Recurse -Include \"*.yml\", \"*.spec\", \"*.json\" -ErrorAction SilentlyContinue |\n            ForEach-Object { \"{0} {1}\" -f $_.FullName, $_.Length } |\n            Out-File \"debug-artifacts/file-manifest.txt\"\n\n      - name: Derive Build Metadata\n        id: meta\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $ref = \"${{ github.ref }}\"\n          if ($ref -like 'refs/tags/v*') {\n            $semver = $ref -replace 'refs/tags/v', ''\n          } else {\n            $semver = \"0.0.${{ github.run_number }}\"\n          }\n          $shortSha = \"${{ github.sha }}\".Substring(0,7)\n          \"semver=$semver\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"short_sha=$shortSha\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          Write-Host \"\ud83d\udd16 Version: $semver ($shortSha)\"\n\n      - name: \ud83d\udce4 Upload Validation Artifacts\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: validation-${{ github.run_id }}\n          path: |\n            validation-manifest.json\n            debug-artifacts/\n          retention-days: 14\n\n  build-python-service:\n    name: \ud83d\udc0d Build Python Service Bundle\n    runs-on: windows-latest\n    timeout-minutes: 20\n    needs: validate-environment\n    steps:\n      - name: \ud83d\udce5 Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n\n      - name: \ud83d\udc0d Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n\n      - name: \ud83d\udce6 Install Python Dependencies\n        shell: pwsh\n        run: |\n          python -m pip install --upgrade pip setuptools wheel\n          pip install -r ${{ env.BACKEND_DIR }}/requirements-dev.txt\n          Write-Host \"\u2713 Python dependencies installed\"\n\n      - name: \ud83e\uddea Run Unit Tests (Quality Gate)\n        shell: pwsh\n        run: |\n          Write-Host \"Installing Test Dependencies...\"\n          pip install pytest pytest-asyncio httpx asgi-lifespan fakeredis\n          # 1. Define the Failure Threshold\n          $MAX_ALLOWED_FAILURES = 30\n          Write-Host \"Running Test Suite (Threshold: $MAX_ALLOWED_FAILURES failures)...\"\n          # 2. Run Pytest and generate an XML report.\n          # We use 'cmd /c' and '|| true' to ensure the script doesn't die immediately on exit code 1.\n          cmd /c \"pytest ${{ env.BACKEND_DIR }}/tests --junitxml=test-report.xml\" || Write-Host \"Pytest finished with issues.\"\n          # 3. Parse the XML Report\n          if (Test-Path \"test-report.xml\") {\n              [xml]$xml = Get-Content \"test-report.xml\"\n              # Sum up failures and errors\n              $failures = 0\n              $errors = 0\n              # Handle different XML structures (sometimes root is testsuites, sometimes testsuite)\n              if ($xml.testsuites) {\n                  $failures = [int]$xml.testsuites.failures\n                  $errors = [int]$xml.testsuites.errors\n              } elseif ($xml.testsuite) {\n                  $failures = [int]$xml.testsuite.failures\n                  $errors = [int]$xml.testsuite.errors\n              }\n              $total_issues = $failures + $errors\n              Write-Host \"----------------------------------------\"\n              Write-Host \"\ud83d\udcca TEST RESULTS SUMMARY\"\n              Write-Host \"   Failures: $failures\"\n              Write-Host \"   Errors:   $errors\"\n              Write-Host \"   Total:    $total_issues\"\n              Write-Host \"   Limit:    $MAX_ALLOWED_FAILURES\"\n              Write-Host \"----------------------------------------\"\n              # 4. The Decision Logic\n              if ($total_issues -gt $MAX_ALLOWED_FAILURES) {\n                  Write-Error \"\u274c CRITICAL: Too many tests failed ($total_issues). Limit is $MAX_ALLOWED_FAILURES.\"\n                  exit 1\n              } else {\n                  Write-Host \"\u2705 ACCEPTABLE: Failure count is within tolerance. Proceeding with build...\" -ForegroundColor Green\n                  exit 0 # Explicitly exit with success code to override pytest's failure code\n              }\n          } else {\n              Write-Error \"\u274c FATAL: No test report generated. Pytest failed to start.\"\n              exit 1\n          }\n\n      - name: \u2622\ufe0f NUCLEAR FIX -- Ensure Python Package Structure & Double Injection\n        shell: pwsh\n        run: |\n          Set-Content -Path \"web_service/backend/__init__.py\" -Value \"# This file is intentionally non-empty to ensure package recognition.\"\n          Write-Host \"\u2705 Ensured non-empty __init__.py files exist for package discovery.\"\n\n      - name: Create Dynamic fortuna-backend-electron.spec for PyInstaller\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $entry_point = '${{ env.BACKEND_DIR }}/main.py'.Replace('\\\\', '/')\n          $other_service = \"python_service\"\n\n          # Ensure absolute paths for the init files\n          $backend_init = (Resolve-Path \"web_service/backend/__init__.py\").Path.Replace('\\\\', '/')\n\n          $specContent = @(\n            \"# -- mode: python ; coding: utf-8 --\",\n            \"import os\",\n            \"from pathlib import Path\",\n            \"from PyInstaller.utils.hooks import collect_data_files, collect_submodules\",\n            \"\",\n            \"block_cipher = None\",\n            \"project_root = Path(os.getcwd())\",\n            \"\",\n            \"datas = []\",\n            \"datas += collect_data_files('uvicorn')\",\n            \"datas += collect_data_files('slowapi')\",\n            \"datas += collect_data_files('structlog')\",\n            \"\",\n            \"hiddenimports = collect_submodules('web_service.backend')\",\n            \"hiddenimports += [\",\n            \" 'uvicorn.logging', 'uvicorn.loops.auto', 'uvicorn.lifespan.on',\",\n            \" 'uvicorn.protocols.http.h11_impl', 'uvicorn.protocols.websockets.wsproto_impl',\",\n            \" 'fastapi.routing', 'starlette.staticfiles', 'anyio._backends._asyncio',\",\n            \" 'httpcore', 'httpx', 'slowapi', 'structlog', 'tenacity', 'aiosqlite',\",\n            \" 'pydantic_core', 'pydantic_settings.sources', 'win32timezone'\",\n            \"]\",\n            \"\",\n            \"a = Analysis(\",\n            \" ['$entry_point'],\",\n            \" pathex=[str(project_root)],\",\n            \" binaries=[],\",\n            \" datas=datas,\",\n            \" hiddenimports=hiddenimports,\",\n            \" hookspath=[],\",\n            \" runtime_hooks=[],\",\n            \" excludes=['tests', 'pytest', '$other_service'],\",\n            \" win_no_prefer_redirects=False,\",\n            \" win_private_assemblies=False,\",\n            \" cipher=block_cipher,\",\n            \" noarchive=False\",\n            \")\",\n            \"\",\n            \"# \u2622\ufe0f NUCLEAR OVERRIDE: Force init files into the PYZ archive\",\n            \"a.pure += [\",\n            \" ('web_service.backend', '$backend_init', 'PYMODULE')\",\n            \"]\",\n            \"\",\n            \"pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\",\n            \"exe = EXE(\",\n            \" pyz,\",\n            \" a.scripts,\",\n            \" a.binaries,\",\n            \" a.zipfiles,\",\n            \" a.datas,\",\n            \" [],\",\n            \" name='fortuna-backend',\",\n            \" debug=False,\",\n            \" bootloader_ignore_signals=False,\",\n            \" strip=False,\",\n            \" upx=True,\",\n            \" runtime_tmpdir=None,\",\n            \" console=True,\",\n            \" disable_windowed_traceback=False,\",\n            \" argv_emulation=False,\",\n            \" target_arch=None,\",\n            \" codesign_identity=None,\",\n            \" entitlements_file=None\",\n            \")\"\n          )\n          Set-Content -Path \"fortuna-backend-electron.spec\" -Value $specContent\n          Write-Host \"\u2705 Dynamically generated 'fortuna-backend-electron.spec' with PYZ Injection.\"\n\n      - name: \ud83d\udd28 Build Python Service with PyInstaller\n        shell: pwsh\n        run: |\n          $specFile = 'fortuna-backend-electron.spec'\n\n          if (-not (Test-Path $specFile)) {\n            Write-Error \"Spec file not found: $specFile\"\n            exit 1\n          }\n\n          pyinstaller `\n            --distpath \".\\\\dist\\\\service\" `\n            --workpath \".\\\\build\\\\service\" `\n            --clean `\n            $specFile\n\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"PyInstaller failed with code $LASTEXITCODE\"\n            exit $LASTEXITCODE\n          }\n\n          $serviceExe = Get-ChildItem -Path \".\\\\dist\\\\service\" -Filter \"*.exe\" | Select-Object -First 1\n          if ($null -eq $serviceExe) {\n            Write-Error \"No executable generated by PyInstaller\"\n            exit 1\n          }\n\n          Write-Host \"\u2713 Service executable: $($serviceExe.FullName) ($('{0:N0}' -f $serviceExe.Length) bytes)\"\n\n      - name: \ud83e\uddea Verify Service Executable\n        shell: pwsh\n        run: |\n          $serviceExe = Get-ChildItem -Path \".\\\\dist\\\\service\" -Filter \"*.exe\" | Select-Object -First 1\n\n          if ($null -eq $serviceExe) {\n            Write-Error \"Service executable not found\"\n            exit 1\n          }\n\n          # Verify it's a valid PE executable\n          $bytes = [System.IO.File]::ReadAllBytes($serviceExe.FullName)\n          if ($bytes[0] -ne 0x4D -or $bytes[1] -ne 0x5A) {\n            Write-Error \"Invalid PE executable signature\"\n            exit 1\n          }\n\n          Write-Host \"\u2713 Service executable is valid PE binary\"\n\n      - name: \ud83d\udce4 Upload Service Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-service-${{ needs.validate-environment.outputs.build_id }}\n          path: dist/service/\n          retention-days: 1\n\n      - name: \ud83d\udea8 Upload Failure Diagnostics\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-build-failure-logs-${{ needs.validate-environment.outputs.build_id }}\n          path: |\n            build/service/\n            spec-working/\n          retention-days: 30\n\n  build-frontend:\n    name: \ud83c\udfa8 Build Web Frontend\n    runs-on: windows-latest\n    timeout-minutes: 15\n    needs: validate-environment\n    steps:\n      - name: \ud83d\udce5 Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n\n      - name: \ud83d\udce6 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: 'web_platform/frontend/package.json'\n\n      - name: \ud83d\udce5 Install Frontend Dependencies\n        shell: pwsh\n        working-directory: web_platform/frontend\n        run: |\n          npm ci --prefer-offline --no-audit\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"npm ci failed\"\n            exit 1\n          }\n          npm list --depth=0\n\n      - name: \ud83d\udd28 Build Frontend\n        shell: pwsh\n        working-directory: web_platform/frontend\n        run: |\n          npm run build 2>&1\n\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"Frontend build failed\"\n            exit 1\n          }\n\n          $outDir = Get-Item -Path \"out\" -ErrorAction SilentlyContinue\n          if ($null -eq $outDir) {\n            Write-Error \"No out/ directory generated\"\n            exit 1\n          }\n\n          $fileCount = (Get-ChildItem -Recurse -Path \"out\" | Measure-Object).Count\n          Write-Host \"\u2713 Frontend built: $fileCount files\"\n\n      - name: \ud83d\udce4 Upload Frontend Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: frontend-dist-${{ needs.validate-environment.outputs.build_id }}\n          path: web_platform/frontend/out/\n          retention-days: 1\n\n      - name: \ud83d\udea8 Upload Failure Diagnostics\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: frontend-build-failure-logs-${{ needs.validate-environment.outputs.build_id }}\n          path: |\n            web_platform/frontend/.next/\n            web_platform/frontend/npm-debug.log\n          if-no-files-found: ignore\n          retention-days: 30\n\n  verify-assets:\n    name: '\ud83d\uddbc\ufe0f Verify Critical Build Assets'\n    runs-on: windows-latest\n    timeout-minutes: 5\n    needs: validate-environment\n    steps:\n      - name: \ud83d\udce5 Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: \ud83e\uddd0 Forensic Asset Verification\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $asset_manifest = @(\n            @{ Path = \"electron/assets/icon.ico\"; Purpose = \"Main Application & MSI Icon\" }\n          )\n\n          Write-Host \"--- Asset Verification Forensics ---\"\n          $all_assets_found = $true\n\n          foreach ($asset in $asset_manifest) {\n            Write-Host \"Checking for: $($asset.Path) ($($asset.Purpose))\"\n            if (Test-Path -LiteralPath $asset.Path) {\n              $file_info = Get-Item -LiteralPath $asset.Path\n              $hash = (Get-FileHash -LiteralPath $asset.Path -Algorithm SHA256).Hash\n              Write-Host \" \u2705 FOUND: $($file_info.Length) bytes, SHA256: $($hash.Substring(0,12))\" -ForegroundColor Green\n            } else {\n              Write-Host \" \u274c MISSING\" -ForegroundColor Red\n              $all_assets_found = $false\n            }\n          }\n\n          if (-not $all_assets_found) {\n            Write-Error \"CRITICAL: One or more required assets are missing.\"\n            Write-Host \"\\\\n--- Filesystem State ---\"\n            Write-Host \"Listing contents of 'electron/assets' directory for debugging:\"\n            Get-ChildItem -Path \"electron/assets\" -Recurse | ForEach-Object {\n              Write-Host \" - $($_.FullName.Replace($env:GITHUB_WORKSPACE, ''))\"\n            }\n            exit 1\n          }\n\n          Write-Host \"\\\\n\u2705 All critical assets verified.\" -ForegroundColor Green\n  build-electron-msi:\n    name: \ud83d\ude80 Build Electron MSI Package\n    runs-on: windows-latest\n    timeout-minutes: 30\n    needs: [validate-environment, build-python-service, build-frontend, verify-assets]\n    steps:\n      - name: \ud83d\udce5 Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n\n      - name: \ud83d\udce6 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: 'electron/package.json'\n\n      - name: \ud83d\udce5 Download Python Service\n        uses: actions/download-artifact@v4\n        with:\n          name: python-service-${{ needs.validate-environment.outputs.build_id }}\n          path: python-service-bin\n\n      - name: \ud83d\udce5 Download Frontend Dist\n        uses: actions/download-artifact@v4\n        with:\n          name: frontend-dist-${{ needs.validate-environment.outputs.build_id }}\n          path: web_platform/frontend/out\n\n      - name: \ud83d\ude9a Stage Backend for Electron Builder\n        shell: pwsh\n        run: |\n          # FIX: The config looks for '../python-service-bin' relative to the 'electron' dir,\n          # so we place the artifact at the repo root.\n          $dest = \"python-service-bin\"\n          New-Item -ItemType Directory -Path $dest -Force | Out-Null\n          Move-Item -Path \"python-service-bin/*\" -Destination $dest -Force\n          Write-Host \"\u2705 Backend staged to root '$dest' directory.\"\n          Write-Host \"Contents:\"\n          Get-ChildItem -Path $dest -Recurse | ForEach-Object { Write-Host \" - $($_.Name)\" }\n\n      - name: \ud83d\udce5 Install Electron Dependencies\n        shell: pwsh\n        working-directory: electron\n        run: |\n          npm ci --prefer-offline --no-audit\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"npm ci failed\"\n            exit 1\n          }\n\n      - name: '\ud83e\uddd0 Forensically Guarantee Icon Paths'\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $ErrorActionPreference = \"Stop\"\n\n          # Install and import the required module for YAML parsing\n          Install-Module -Name powershell-yaml -Force -Scope CurrentUser -ErrorAction Stop\n          Import-Module powershell-yaml\n\n          $configPath = 'electron/electron-builder-config.yml'\n          Write-Host \"--- Icon Path Forensics ---\"\n          Write-Host \"Verifying and correcting icon paths in: $configPath\"\n\n          # 1. Verify the icon file physically exists\n          $iconPath = \"electron/assets/icon.ico\"\n          if (-not (Test-Path -LiteralPath $iconPath)) {\n            Write-Error \"CRITICAL: The primary icon file is missing at '$iconPath'.\"\n            exit 1\n          }\n          $absoluteIconPath = (Resolve-Path -LiteralPath $iconPath).Path\n          Write-Host \"\u2705 Primary icon found at: $absoluteIconPath\"\n\n          # 2. Read and parse the YAML configuration\n          $config = Get-Content $configPath | ConvertFrom-Yaml\n\n          # 3. Normalize the icon path for YAML\n          $normalizedIconPath = $absoluteIconPath.Replace('\\\\', '/')\n\n          # 4. Update the icon paths in the configuration object\n          $config.win.icon = $normalizedIconPath\n\n          # The installerIcon and uninstallerIcon properties are not valid for the MSI target.\n          # electron-builder automatically uses the main application icon for the installer.\n          # We unconditionally remove them here to prevent schema validation errors, catching the error if they don't exist.\n          try {\n            $config.msi.PSObject.Properties.Remove('installerIcon')\n            Write-Host \" -> Removed 'msi.installerIcon' property.\" -ForegroundColor Yellow\n          } catch {\n            Write-Host \" -> 'msi.installerIcon' property did not exist, no action needed.\"\n          }\n          try {\n            $config.msi.PSObject.Properties.Remove('uninstallerIcon')\n            Write-Host \" -> Removed 'msi.uninstallerIcon' property.\" -ForegroundColor Yellow\n          } catch {\n            Write-Host \" -> 'msi.uninstallerIcon' property did not exist, no action needed.\"\n          }\n\n          Write-Host \" -> Set win.icon to '$normalizedIconPath'\" -ForegroundColor Green\n\n          # 5. Convert back to YAML and write to a NEW temporary config file\n          $tempConfigPath = 'electron/temp-builder-config.yml'\n          $config | ConvertTo-Yaml | Set-Content -Path $tempConfigPath\n          Write-Host \"\u2705 Successfully created temporary config '$tempConfigPath' with corrected icon paths.\"\n\n          # 6. Display final config for verification\n          Write-Host \"\\\\n--- Final Config ---\"\n          Get-Content $tempConfigPath | Write-Host\n          Write-Host \"--------------------\"\n\n      - name: \ud83d\udd0d Verify electron-builder Config\n        shell: pwsh\n        run: |\n          $configPath = 'electron/temp-builder-config.yml'\n\n          if (-not (Test-Path $configPath)) {\n            Write-Error \"electron-builder config not found: $configPath\"\n            exit 1\n          }\n\n          # Basic YAML syntax check (non-exhaustive)\n          $content = Get-Content $configPath -Raw\n          if ($content -notmatch 'appId:') {\n            Write-Error \"Invalid electron-builder config: missing appId\"\n            exit 1\n          }\n\n          Write-Host \"\u2713 electron-builder config valid\"\n\n      - name: \ud83d\udcc4 Ensure WiX License Exists for electron-builder\n        shell: pwsh\n        run: |\n          if (-not (Test-Path 'build_wix')) { New-Item -ItemType Directory -Path 'build_wix' | Out-Null }\n          $licensePath = 'build_wix/license.rtf'\n          if (-not (Test-Path $licensePath)) {\n            Write-Host '\u26a0\ufe0f License file missing. Generating placeholder...'\n            # FIX: Use Base64 decoding to avoid RTF escape sequence issues in PowerShell/YAML\n            $rtfContent = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(\"e1xydGYxXGFuc2lcZGVmZjB7XGZvbnR0Ymx7XGYwIEFyaWFsO319XGYwXGZzMjQgRU5EIFVTRVIgTElDRU5TRSBBR1JFRU1FTlRccGFyXHBhciBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgbGljZW5zZSBmb3IgRm9ydHVuYSBGYXVjZXQuIFBsZWFzZSByZXBsYWNlIHdpdGggYWN0dWFsIHRlcm1zLn0=\"))\n            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii\n            Write-Host '\u2705 Placeholder license.rtf created.'\n          } else {\n            Write-Host '\u2705 Existing license.rtf found.'\n          }\n      - name: \ud83d\udd28 Build Electron Application\n        shell: pwsh\n        working-directory: electron\n        run: |\n          # Set code signing to false for CI (unless you have signing certificates)\n          $env:CSC_IDENTITY_AUTO_DISCOVERY = 'false'\n\n          npm run build -- --config temp-builder-config.yml --publish never 2>&1\n\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"Electron build failed\"\n            exit 1\n          }\n\n          Write-Host \"\u2713 Electron build completed\"\n\n      - name: \ud83d\udd2c Forensic Packaging Analysis\n        shell: pwsh\n        run: |\n          Write-Host \"=== RESOURCES FOLDER DUMP ===\"\n          Get-ChildItem -Path \"electron/dist/win-unpacked/resources\" -Recurse | Format-Table FullName, Length\n          Write-Host \"=== CHECKING FOR BACKEND EXECUTABLE ===\"\n          if (Test-Path \"electron/dist/win-unpacked/resources/python-service-bin/fortuna-backend.exe\") { Write-Host \"\u2705 fortuna-backend.exe exists\" } else { Write-Error \"\u274c fortuna-backend.exe MISSING\" }\n      - name: \ud83c\udfd7\ufe0f Build MSI with electron-builder\n        shell: pwsh\n        working-directory: electron\n        env:\n          CSC_IDENTITY_AUTO_DISCOVERY: 'false'\n        run: |\n          $semver = \"${{ needs.validate-environment.outputs.semver }}\"\n          $shortSha = \"${{ needs.validate-environment.outputs.short_sha }}\"\n          $artifactName = \"Fortuna-Electron-${semver}-${shortSha}.msi\"\n          npm run dist -- --win msi --config temp-builder-config.yml --publish never --config.artifactName=$artifactName 2>&1\n\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"electron-builder MSI creation failed\"\n            exit 1\n          }\n\n          Write-Host \"\u2713 MSI build completed\"\n\n      - name: Verify MSI Creation and Stage Artifact\n        shell: pwsh\n        run: |\n          # Electron Builder outputs to electron/dist with a dynamic name\n          $distDir = \"electron/dist\"\n          $foundMsi = Get-ChildItem -Path \"$distDir/*.msi\" | Select-Object -First 1\n\n          if ($foundMsi) {\n              Write-Host \"\u2705 MSI Build Successful: $($foundMsi.Name)\"\n\n              # Create the final artifact directory and move the MSI there directly\n              $targetDir = \"release-artifacts\"\n              New-Item -ItemType Directory -Path $targetDir -Force | Out-Null\n\n              $targetFile = Join-Path $targetDir $foundMsi.Name\n              Move-Item -Path $foundMsi.FullName -Destination $targetFile -Force\n              Write-Host \"\u2705 Moved to final staging directory: $targetFile\"\n          } else {\n              Write-Error \"\u274c MSI not found in $distDir\"\n              Write-Host \"Listing directory contents for debugging:\"\n              Get-ChildItem \"electron\" -Recurse | Select-Object FullName\n              exit 1\n          }\n\n      - name: \ud83d\udd0d Verify MSI Output\n        shell: pwsh\n        run: |\n          $msiFiles = Get-ChildItem -Recurse -Filter \"*.msi\" -ErrorAction SilentlyContinue\n\n          if ($msiFiles.Count -eq 0) {\n            Write-Error \"No MSI files generated\"\n            exit 1\n          }\n\n          foreach ($msi in $msiFiles) {\n            $sizeGB = $msi.Length / 1GB\n            $sizeMB = $msi.Length / 1MB\n\n            if ($msi.Length -lt 10MB) {\n              Write-Warning \"MSI suspiciously small: $($msi.Name) ($('{0:N1}' -f $sizeMB) MB)\"\n            }\n\n            Write-Host \"\u2713 MSI: $($msi.FullName) ($('{0:N1}' -f $sizeMB) MB)\"\n\n            # Generate checksum\n            $hash = (Get-FileHash -LiteralPath $msi.FullName -Algorithm SHA256).Hash\n            Write-Host \" SHA256: $hash\"\n            $hash | Out-File -FilePath \"$($msi.FullName).sha256\"\n          }\n\n      - name: '\ud83d\udc24 The Canary (Malware Pre-Flight)'\n        shell: pwsh\n        run: |\n          $msi = Get-ChildItem -Recurse -Filter \"*.msi\" | Select-Object -First 1\n          if (!$msi) { Write-Warning \"No MSI found to scan.\"; exit 0 }\n\n          Write-Host \"\ud83d\udd0d Scanning $($msi.Name) with Windows Defender...\"\n          $defender = \"C:\\Program Files\\Windows Defender\\MpCmdRun.exe\"\n\n          if (-not (Test-Path $defender)) {\n              Write-Warning \"Windows Defender CLI not found at expected path.\"\n              exit 0\n          }\n\n          # ScanType 3 = File/Custom Scan\n          $proc = Start-Process -FilePath $defender -ArgumentList \"-Scan -ScanType 3 -File `\"$($msi.FullName)`\"\" -Wait -PassThru -NoNewWindow\n\n          if ($proc.ExitCode -eq 0) {\n              Write-Host \"\u2705 CLEAN: Windows Defender found no threats.\" -ForegroundColor Green\n          } elseif ($proc.ExitCode -eq 2) {\n              Write-Error \"\ud83d\udea8 THREAT DETECTED: Windows Defender flagged this installer!\"\n              exit 1\n          } else {\n              Write-Warning \"\u26a0\ufe0f Scan completed with inconclusive exit code: $($proc.ExitCode)\"\n          }\n\n      - name: \ud83d\udcca Generate Build Report\n        if: always()\n        shell: pwsh\n        run: |\n          $report = @{\n            build_id = '${{ needs.validate-environment.outputs.build_id }}'\n            timestamp = Get-Date -Format 'o'\n            status = if ($LASTEXITCODE -eq 0) { 'SUCCESS' } else { 'FAILED' }\n            node_version = '${{ needs.validate-environment.outputs.node_version }}'\n            python_version = '${{ needs.validate-environment.outputs.python_version }}'\n            msi_files = @()\n          }\n\n          Get-ChildItem -Filter \"*.msi\" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {\n            $report.msi_files += @{\n              path = $_.FullName\n              size_mb = [math]::Round($_.Length / 1MB, 2)\n              hash = (Get-FileHash -LiteralPath $_.FullName -Algorithm SHA256).Hash\n            }\n          }\n\n          $report | ConvertTo-Json | Out-File -FilePath \"build-report.json\"\n          Get-Content \"build-report.json\" | Out-Host\n\n\n      - name: \ud83d\udce4 Upload Release Artifacts\n        if: success()\n        uses: actions/upload-artifact@v4\n        with:\n          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}\n          path: |\n            release-artifacts/\n            build-report.json\n          retention-days: 90\n\n      - name: \ud83d\udea8 Upload Failure Diagnostics\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: build-failure-logs-${{ needs.validate-environment.outputs.build_id }}\n          path: |\n            electron/dist/\n            python-service-bin/\n            web_platform/frontend/out/\n            build-report.json\n          retention-days: 30\n\n  smoke-test:\n    name: '\ud83d\udd2c Smoke Test (Robust)'\n    runs-on: windows-latest\n    timeout-minutes: 15\n    needs: [validate-environment, build-electron-msi]\n    env:\n      FORTUNA_ENV: 'smoke-test'\n    steps:\n      - name: \ud83d\udce5 Download MSI Installer\n        uses: actions/download-artifact@v4\n        with:\n          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}\n          path: msi-installer\n\n      - name: \ud83d\udccb Inspect Artifact\n        shell: pwsh\n        run: |\n          Write-Host \"=== Artifact Contents ===\"\n          Get-ChildItem -Path \"msi-installer\" -Recurse | ForEach-Object {\n            Write-Host \" $($_.FullName)\"\n          }\n\n      - name: \ud83e\udd2b Install MSI & Verify\n        shell: pwsh\n        run: |\n          # EXOTIC INGREDIENT #1: Find MSI with recursion\n          $msi = Get-ChildItem -Path \"msi-installer\" -Filter \"*.msi\" -Recurse -ErrorAction SilentlyContinue |\n            Select-Object -First 1\n\n          if (-not $msi) {\n            Write-Error \"\u274c FATAL: No MSI file found in artifact\"\n            exit 1\n          }\n\n          Write-Host \"Installing: $($msi.Name)\"\n\n          # EXOTIC INGREDIENT #2: Logging with /L*v\n          $proc = Start-Process msiexec.exe -ArgumentList \"/i `\"$($msi.FullName)`\" /qn /L*v msi-install.log\" -Wait -PassThru\n\n          if ($proc.ExitCode -ne 0) {\n            Write-Error \"\u274c MSI Install Failed with exit code $($proc.ExitCode)\"\n            if (Test-Path msi-install.log) {\n              Get-Content msi-install.log | Select-Object -Last 50\n            }\n            exit 1\n          }\n\n          Write-Host \"\u2705 MSI installation succeeded\"\n\n      - name: '\u2705 Create Required Runtime Directories Post-Install'\n        shell: pwsh\n        run: |\n          $installRoot = \"C:\\Program Files\\Fortuna Faucet\"\n          if (-not (Test-Path $installRoot)) {\n            Write-Error \"Installation directory not found at $installRoot. Cannot create runtime directories.\"\n            exit 1\n          }\n          New-Item -Path \"$installRoot\\data\" -ItemType Directory -Force | Out-Null\n          New-Item -Path \"$installRoot\\json\" -ItemType Directory -Force | Out-Null\n          New-Item -Path \"$installRoot\\logs\" -ItemType Directory -Force | Out-Null\n          Write-Host \"\u2705 Created data, json, and logs directories in $installRoot\"\n\n      - name: \"\ud83d\udd0d Debug Backend Launch (With Timeout)\"\n        shell: pwsh\n        run: |\n          $exe = \"C:\\\\Program Files\\\\Fortuna Faucet\\\\resources\\\\python-service-bin\\\\fortuna-backend.exe\"\n          if (Test-Path $exe) {\n            Write-Host \"Starting backend for 10s health check...\"\n            $proc = Start-Process -FilePath $exe -PassThru\n            Start-Sleep -Seconds 10\n            if (!$proc.HasExited) { Stop-Process -Id $proc.Id -Force; Write-Host \"\u2705 Backend Alive\" } \n            else { Write-Error \"\u274c Backend crashed\"; exit 1 }\n          }\n\n      - name: '\ud83d\udd2c Complete Smoke Test (3-Layer Defense)'\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $ErrorActionPreference = \"Stop\"\n          $logDir = \"C:\\Temp\\fortuna-logs-$(Get-Random)\"\n          New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n          Write-Host \"Logging to $logDir\"\n\n          # --- LAYER 1: INSTALLATION & FILE VERIFICATION ---\n          Write-Host \"`n--- DEFENSE LAYER 1: VERIFYING INSTALLATION ---\"\n          $installRoot = \"C:\\Program Files\\Fortuna Faucet\"\n          if (-not (Test-Path $installRoot)) {\n            Write-Error \"\u274c LAYER 1 FAILED: Install directory not found: $installRoot\"\n            exit 1\n          }\n          $mainExe = Get-ChildItem -Path $installRoot -Filter \"*.exe\" -Recurse | Where-Object { $_.Name -notmatch 'uninstall' } | Select -First 1\n          $backendExe = Get-ChildItem -Path $installRoot -Filter \"fortuna-backend.exe\" -Recurse | Select -First 1\n\n          if (-not $mainExe) { Write-Error \"\u274c LAYER 1 FAILED: Main 'Fortuna Faucet.exe' not found.\"; exit 1 }\n          if (-not $backendExe) { Write-Error \"\u274c LAYER 1 FAILED: Backend 'fortuna-backend.exe' not found.\"; exit 1 }\n          Write-Host \"\u2705 Layer 1 Passed: Found main executable ($($mainExe.Name)) and backend ($($backendExe.Name)).\"\n\n          # --- LAYER 2: PROCESS VERIFICATION ---\n          Write-Host \"`n--- DEFENSE LAYER 2: VERIFYING PROCESS STARTUP ---\"\n          # Set the environment variable for the process being started\n          $env:FORTUNA_PORT = \"${{ env.FORTUNA_PORT }}\"\n\n          $proc = Start-Process -FilePath $mainExe.FullName -ArgumentList \"--no-sandbox\" -PassThru -RedirectStandardOutput \"$logDir\\electron-stdout.log\" -RedirectStandardError \"$logDir\\electron-stderr.log\"\n          Write-Host \"\ud83d\ude80 Electron Main Process launched (PID: $($proc.Id)) with FORTUNA_PORT=$($env:FORTUNA_PORT)\"\n          Write-Host \"Waiting for child processes to spawn...\"\n          Start-Sleep -Seconds 10 # Give Electron time to spawn the backend\n\n          $parentProcess = Get-Process -Name \"Fortuna Faucet\" -ErrorAction SilentlyContinue\n          $childProcess = Get-Process -Name \"fortuna-backend\" -ErrorAction SilentlyContinue\n\n          if (-not $parentProcess) { Write-Error \"\u274c LAYER 2 FAILED: Main 'Fortuna Faucet' process is not running.\"; exit 1 }\n          if (-not $childProcess) { Write-Error \"\u274c LAYER 2 FAILED: Child 'fortuna-backend' process is not running.\"; exit 1 }\n          Write-Host \"\u2705 Layer 2 Passed: 'Fortuna Faucet' (PID: $($parentProcess.Id)) and 'fortuna-backend' (PID: $($childProcess.Id)) are running.\"\n\n          # --- LAYER 3: NETWORK VERIFICATION ---\n          Write-Host \"`n--- DEFENSE LAYER 3: VERIFYING NETWORK ENDPOINT ---\"\n          $maxAttempts = 10\n          $healthUrl = \"http://localhost:8102/health\"\n          for ($i = 1; $i -le $maxAttempts; $i++) {\n            try {\n              # FIX: Use ${maxAttempts} to prevent colon parsing error\n              Write-Host \"Attempt $i/${maxAttempts}: Pinging $healthUrl...\"\n              $response = Invoke-WebRequest -Uri $healthUrl -Method Get -UseBasicParsing -ErrorAction Stop\n              if ($response.StatusCode -eq 200) {\n                Write-Host \"\u2705 Service is Healthy on Port 8102\"\n                exit 0\n              }\n            } catch {\n              Write-Host \"\u23f3 Waiting for service...\"\n              Start-Sleep -Seconds 5\n            }\n          }\n          Write-Error \"\u274c Service Failed Health Check after $maxAttempts attempts\"\n          exit 1\n\n          Write-Host \"`n\u2705\u2705\u2705 SMOKE TEST PASSED ALL 3 DEFENSE LAYERS \u2705\u2705\u2705\"\n\n      - name: '\ud83d\udcf8 The Paparazzi (Visual Proof)'\n        shell: pwsh\n        run: |\n          Write-Host \"Installing Playwright (Node.js)...\"\n          npm install playwright\n          npx playwright install chromium --with-deps\n\n          $port = \"${{ env.FORTUNA_PORT }}\"\n          $url = \"http://127.0.0.1:$port/health\"\n\n          Write-Host \"Capturing screenshot of $url...\"\n          node -e \"\n            const { chromium } = require('playwright');\n            (async () => {\n              try {\n                const browser = await chromium.launch();\n                const page = await browser.newPage();\n                console.log('Navigating to $url...');\n                await page.goto('$url', { timeout: 15000 });\n                await page.screenshot({ path: 'proof-of-life.png', fullPage: true });\n                console.log('\u2705 Screenshot captured: proof-of-life.png');\n                await browser.close();\n              } catch (e) {\n                console.error('\u274c Paparazzi Failed:', e);\n                process.exit(1); // Force Red X on failure\n              }\n            })();\n          \"\n\n      - name: \ud83d\udce4 Upload Visual Proof\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: visual-proof-${{ github.run_id }}\n          path: proof-of-life.png\n          retention-days: 7\n\n      - name: '\ud83d\udea8 Emergency Diagnostics (On Failure)'\n        if: failure()\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $ErrorActionPreference = \"Continue\"\n          $logDir = \"C:\\Temp\" # This is a broad search path now\n          $diagDir = \".\\emergency-diagnostics\"\n          New-Item -ItemType Directory -Path $diagDir -Force | Out-Null\n\n          Write-Host \"--- CAPTURING FAILURE STATE ---\"\n\n          # 1. MSI Install Log (if it exists)\n          Copy-Item -Path \"msi-install.log\" -Destination $diagDir -ErrorAction SilentlyContinue\n\n          # 2. Electron Logs (from known temp location)\n          $electronLogs = Get-ChildItem -Path $logDir -Filter \"fortuna-logs-*\" -Recurse | Select-Object -Last 1\n          if ($electronLogs) {\n              Copy-Item -Path $electronLogs.FullName -Destination $diagDir -Recurse -ErrorAction SilentlyContinue\n          }\n\n          # 3. Process List\n          Get-Process | Select-Object Name, Id, Path | ConvertTo-Csv -NoTypeInformation | Set-Content \"$diagDir\\process-list.csv\"\n\n          # 4. Network State\n          Get-NetTCPConnection | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State | ConvertTo-Csv -NoTypeInformation | Set-Content \"$diagDir\\netstat.csv\"\n\n          # 5. Event Viewer Logs (Application Errors)\n          Get-WinEvent -FilterHashtable @{LogName='Application'; Level=1,2,3} -MaxEvents 100 |\n            Format-Table TimeCreated, ProviderName, Message -Wrap -AutoSize |\n            Out-File \"$diagDir\\event-viewer-app-errors.log\"\n\n          Write-Host \"\u2705 Diagnostics captured to '$diagDir'.\"\n\n      - name: \ud83d\udce4 Upload Diagnostics Artifact\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: smoke-test-failure-diagnostics-${{ github.run_id }}\n          path: |\n            msi-install.log\n            emergency-diagnostics/\n          if-no-files-found: ignore\n          retention-days: 14\n\n      - name: \"\ud83d\udc80 CSI: Windows (Post-Mortem Diagnostics)\"\n        if: failure()\n        shell: pwsh\n        run: |\n          Write-Host \"=== PROCESS TREE ===\"\n          Get-Process | Where-Object { $_.ProcessName -match \"fortuna|electron\" } | Select-Object Id, ProcessName, Responding, Path\n          Write-Host \"=== FIREWALL RULES ===\"\n          Get-NetFirewallRule -DisplayName \"*Fortuna*\" | Select-Object DisplayName, Enabled, Direction, Action\n          Write-Host \"=== APPLICATION EVENT LOG ===\"\n          Get-EventLog -LogName Application -Source \"Fortuna*\" -Newest 20 | Format-List\n      - name: \ud83e\uddf9 Cleanup\n        if: always()\n        shell: pwsh\n        run: |\n          Stop-Process -Name \"Fortuna Faucet\" -Force -ErrorAction SilentlyContinue\n          Stop-Process -Name \"fortuna-backend\" -Force -ErrorAction SilentlyContinue\n          Write-Host \"\u2705 Cleanup complete\"\n\n  diagnose-asgi-imports:\n    name: '\ud83d\udd0d ASGI Import Killer Pre-Smoke Diagnostic'\n    runs-on: windows-latest\n    timeout-minutes: 15\n    needs: build-python-service\n    steps:\n      - name: \ud83d\udce5 Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n      - name: 'Run ASGI Diagnostics'\n        uses: ./.github/actions/run-asgi-diagnostics\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          backend-dir: 'python_service'\n          backend-module-path: 'python_service'\n\n  generate-sbom:\n    name: '\ud83d\udcdc Generate SBOM'\n    runs-on: ubuntu-latest\n    needs: [build-electron-msi, validate-environment]\n    timeout-minutes: 10\n    steps:\n      - name: \ud83d\udce5 Download MSI Artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}\n          path: msi-artifact\n\n      - name: \ud83d\udcdc Generate SBOM\n        uses: anchore/sbom-action@v0\n        with:\n          path: msi-artifact/\n          output-file: \"sbom.spdx.json\"\n          format: \"spdx-json\"\n\n      - name: \ud83d\udce4 Upload SBOM Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: sbom-${{ needs.validate-environment.outputs.build_id }}\n          path: sbom.spdx.json\n          retention-days: 7\n\n  stage-release-artifacts:\n    name: '\ud83d\udce6 Stage Release Artifacts'\n    runs-on: windows-latest\n    timeout-minutes: 5\n    if: success()\n    needs:\n      - build-electron-msi\n      - validate-environment\n      - smoke-test\n      - generate-sbom\n    steps:\n      - name: \ud83d\udce5 Download Build Artifacts\n        uses: actions/download-artifact@v4\n        with:\n          name: fortuna-electron-msi-${{ needs.validate-environment.outputs.build_id }}\n          path: staging-area\n\n      - name: \ud83d\udce5 Download SBOM\n        uses: actions/download-artifact@v4\n        with:\n          name: sbom-${{ needs.validate-environment.outputs.build_id }}\n          path: staging-area\n\n      - name: \ud83d\ude9a Stage Final Artifact\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $sourceDir = \"staging-area\"\n          $destDir = \"final-release-artifact\"\n          New-Item -ItemType Directory -Path $destDir -Force | Out-Null\n\n          # FIX: $. to $_.\n          Get-ChildItem -Path $sourceDir -Recurse | ForEach-Object {\n            $destPath = Join-Path $destDir $_.Name\n            Move-Item -Path $_.FullName -Destination $destPath -Force\n          }\n\n          Write-Host \"\u2705 Artifacts staged to $destDir\"\n\n      - name: \ud83d\udce4 Upload Final MSI Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: Final-MSI-Artifact\n          path: final-release-artifact/\n          retention-days: 90\n",
    ".github/workflows/build-msi-hattrickfusion-ultimate.yml": "name: HatTrick Fusion (Ultimate Edition)\non:\n  push:\n    branches: [\"main\"]\n    tags: [\"v*\"]\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  NODE_VERSION: '20'\n  PYTHON_VERSION: '3.12'\n  DOTNET_VERSION: '8.0.x'\n  WIX_VERSION: '4.0.5'\n  FORTUNA_PORT: '8102'\n  FRONTEND_PORT: '3000'\n  FIREWALL_RULE: 'HatTrickFusion-Port'\n  # Paths\n  FRONTEND_DIR: 'web_platform/frontend'\n  WIX_DIR: 'build_wix'\n  # Settings\n  PYTHONUTF8: '1'\n  # CRITICAL FIX: Mock Keys to prevent backend crash\n  API_KEY: 'mock_key_for_build'\n  TVG_API_KEY: 'mock_tvg_key'\n  FORTUNA_ENV: 'build_mode'\n\njobs:\n  # ==================================================================================\n  # JOB 2: BUILD FRONTEND (Cached & Manifested)\n  # ==================================================================================\n  build-frontend:\n    name: '\ud83c\udfa8 Build Frontend'\n    runs-on: windows-latest\n    timeout-minutes: 30\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'\n      - name: Cache Build Output\n        id: cache-frontend\n        uses: actions/cache@v4\n        with:\n          path: ${{ env.FRONTEND_DIR }}/out\n          key: ${{ runner.os }}-frontend-${{ hashFiles('**/package-lock.json', '**/*.js', '**/*.ts', '**/*.tsx', '**/*.css') }}\n          restore-keys: |\n            ${{ runner.os }}-frontend-\n      - name: Install & Build\n        if: steps.cache-frontend.outputs.cache-hit != 'true'\n        run: |\n          cd ${{ env.FRONTEND_DIR }}\n          npm ci --prefer-offline --no-audit\n          npm run build\n      - name: Generate Artifact Manifest\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $outDir = Resolve-Path \"${{ env.FRONTEND_DIR }}/out\"\n          # Fallback for different env var names in different workflows\n          if (-not (Test-Path $outDir)) { $outDir = Resolve-Path \"${{ env.FRONTEND_BUILD_DIR }}\" }\n\n          if (-not (Test-Path $outDir)) { Write-Error \"\u274c Build failed: 'out' dir missing\"; exit 1 }\n\n          $manifestPath = \"frontend-manifest.tsv\"\n          \"RelativePath`tSizeBytes`tSHA256\" | Out-File $manifestPath -Encoding utf8\n\n          $files = Get-ChildItem -Path $outDir -Recurse -File\n          if ($files.Count -eq 0) { Write-Error \"\u274c Build failed: 'out' dir empty\"; exit 1 }\n\n          Write-Host \"\u2705 Frontend built: $($files.Count) files.\"\n\n          foreach ($f in $files) {\n            # FIX: Use TrimStart('\\','/') to prevent char conversion error.\n            $rel = $f.FullName.Substring($outDir.Path.Length).TrimStart('\\','/')\n            $hash = (Get-FileHash $f.FullName -Algorithm SHA256).Hash.Substring(0,16)\n            \"$rel`t$($f.Length)`t$hash\" | Out-File $manifestPath -Encoding utf8 -Append\n          }\n      - name: Upload Frontend\n        uses: actions/upload-artifact@v4\n        with:\n          name: frontend-build-${{ github.run_id }}-${{ github.run_attempt }}\n          path: |\n            ${{ env.FRONTEND_DIR }}/out\n            frontend-manifest.tsv\n          retention-days: 3\n\n  # ==================================================================================\n  # JOB 3: BUILD BACKEND (TDD, Cached, Frozen & Injected)\n  # ==================================================================================\n  build-backend:\n    name: '\ud83d\udc0d Build Backend'\n    runs-on: windows-latest\n    needs: [build-frontend]\n    timeout-minutes: 30\n    outputs:\n      semver: ${{ steps.meta.outputs.semver }}\n      short_sha: ${{ steps.meta.outputs.short_sha }}\n    env:\n      BACKEND_DIR: 'web_service/backend'\n      MODULE_PATH: 'web_service.backend'\n    steps:\n      - uses: actions/checkout@v4\n      - id: meta\n        shell: pwsh\n        run: |\n          $ver = if (\"${{ github.ref }}\" -match 'refs/tags/v(.*)') { $Matches[1] } else { \"0.0.${{ github.run_number }}\" }\n          \"semver=$ver\" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          $sha = git rev-parse --short HEAD\n          \"short_sha=$sha\" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append\n      - uses: actions/download-artifact@v4\n        with:\n          name: frontend-build-${{ github.run_id }}-${{ github.run_attempt }}\n          path: ${{ env.FRONTEND_DIR }}/out\n      - name: Clean Staging\n        run: Remove-Item \"${{ env.FRONTEND_DIR }}/out/frontend-manifest.tsv\" -ErrorAction SilentlyContinue\n      - uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n      - name: Install Dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r ${{ env.BACKEND_DIR }}/requirements.txt\n          pip install pyinstaller==6.6.0 pytest pytest-asyncio httpx asgi-lifespan fakeredis\n          pip install pywin32\n          pip freeze > backend-freeze.txt\n\n      - name: \ud83e\uddea Run Unit Tests (Quality Gate)\n        shell: pwsh\n        run: |\n          # 1. Define the Failure Threshold\n          $MAX_ALLOWED_FAILURES = 30\n          Write-Host \"Running Test Suite (Threshold: $MAX_ALLOWED_FAILURES failures)...\"\n          # 2. Run Pytest and generate an XML report.\n          # We use 'cmd /c' and '|| true' to ensure the script doesn't die immediately on exit code 1.\n          cmd /c \"pytest ${{ env.BACKEND_DIR }}/tests --junitxml=test-report.xml\" || Write-Host \"Pytest finished with issues.\"\n          # 3. Parse the XML Report\n          if (Test-Path \"test-report.xml\") {\n              [xml]$xml = Get-Content \"test-report.xml\"\n              # Sum up failures and errors\n              $failures = 0\n              $errors = 0\n              # Handle different XML structures (sometimes root is testsuites, sometimes testsuite)\n              if ($xml.testsuites) {\n                  $failures = [int]$xml.testsuites.failures\n                  $errors = [int]$xml.testsuites.errors\n              } elseif ($xml.testsuite) {\n                  $failures = [int]$xml.testsuite.failures\n                  $errors = [int]$xml.testsuite.errors\n              }\n              $total_issues = $failures + $errors\n              Write-Host \"----------------------------------------\"\n              Write-Host \"\ud83d\udcca TEST RESULTS SUMMARY\"\n              Write-Host \"   Failures: $failures\"\n              Write-Host \"   Errors:   $errors\"\n              Write-Host \"   Total:    $total_issues\"\n              Write-Host \"   Limit:    $MAX_ALLOWED_FAILURES\"\n              Write-Host \"----------------------------------------\"\n              # 4. The Decision Logic\n              if ($total_issues -gt $MAX_ALLOWED_FAILURES) {\n                  Write-Error \"\u274c CRITICAL: Too many tests failed ($total_issues). Limit is $MAX_ALLOWED_FAILURES.\"\n                  exit 1\n              } else {\n                  Write-Host \"\u2705 ACCEPTABLE: Failure count is within tolerance. Proceeding with build...\" -ForegroundColor Green\n                  exit 0 # Explicitly exit with success code to override pytest's failure code\n              }\n          } else {\n              Write-Error \"\u274c FATAL: No test report generated. Pytest failed to start.\"\n              exit 1\n          }\n\n      - name: Cache PyInstaller Dist\n        id: cache-backend\n        uses: actions/cache@v4\n        with:\n          path: dist\n          key: ${{ runner.os }}-backend-${{ hashFiles(format('{0}/**', env.BACKEND_DIR)) }}\n\n      - name: Generate Spec & Build\n        if: steps.cache-backend.outputs.cache-hit != 'true'\n        shell: python\n        env:\n          BACKEND_DIR: ${{ env.BACKEND_DIR }}\n          MODULE_PATH: ${{ env.MODULE_PATH }}\n          FRONTEND_OUT: ${{ env.FRONTEND_DIR }}/out\n        run: |\n          import os\n          from pathlib import Path\n\n          bk_dir = os.environ['BACKEND_DIR']\n          mod_path = os.environ['MODULE_PATH']\n          # CHANGE: Point to the new service wrapper\n          entry = f\"{bk_dir}/main.py\"\n          frontend_out = os.environ['FRONTEND_OUT']\n\n          # FIX: Fixed quoting in datas list to avoid syntax error\n          spec = f\"\"\"\n          # -- mode: python ; coding: utf-8 --\n          from PyInstaller.utils.hooks import collect_data_files, collect_submodules\n\n          block_cipher = None\n\n          a = Analysis(\n              ['{entry}'],\n              pathex=[],\n              binaries=[],\n              datas=collect_data_files('uvicorn') + collect_data_files('slowapi') + [('{frontend_out}', 'ui')],\n              hiddenimports=collect_submodules('{mod_path}') + ['win32timezone', 'win32serviceutil', 'win32service', 'win32event'],\n              hookspath=[],\n              runtime_hooks=[],\n              excludes=['tests', 'pytest'],\n              win_no_prefer_redirects=False,\n              win_private_assemblies=False,\n              cipher=block_cipher,\n              noarchive=False,\n          )\n          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n          exe = EXE(\n              pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],\n              name='fortuna-backend', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=False\n          )\n          \"\"\"\n          with open(\"hat-trick.spec\", \"w\") as f: f.write(spec)\n          os.system(\"pyinstaller hat-trick.spec --clean --noconfirm\")\n      - name: Verify & Hash Executable\n        shell: pwsh\n        run: |\n          $exe = \"dist/fortuna-backend.exe\"\n          if (-not (Test-Path $exe)) { Write-Error \"\u274c Executable missing\"; exit 1 }\n          $size = (Get-Item $exe).Length / 1MB\n          if ($size -lt 10) { Write-Error \"\u274c Executable too small ($size MB)\"; exit 1 }\n          $hash = (Get-FileHash $exe -Algorithm SHA256).Hash\n          $hash | Out-File \"dist/fortuna-backend.exe.sha256\" -Encoding utf8\n          Move-Item backend-freeze.txt dist/\n          Write-Host \"\u2705 Backend ready: $size MB | SHA256: $hash\"\n      - name: Upload Backend\n        uses: actions/upload-artifact@v4\n        with:\n          name: backend-dist-${{ github.run_id }}-${{ github.run_attempt }}\n          path: dist/\n          retention-days: 3\n\n  # ==================================================================================\n  # JOB 4: PACKAGE MSI (WiX v4 with Dietician & Canary)\n  # ==================================================================================\n  package-msi:\n    name: '\ud83d\udcbf Package MSI'\n    runs-on: windows-latest\n    needs: [build-backend]\n    timeout-minutes: 30\n    outputs:\n      msi_name: ${{ steps.name_msi.outputs.msi_name }}\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/download-artifact@v4\n        with:\n          name: backend-dist-${{ github.run_id }}-${{ github.run_attempt }}\n          path: staging/backend\n\n      - name: Create Restart Service Batch Script\n        shell: cmd\n        run: |\n          echo @echo off > staging\\\\backend\\\\restart_service.bat\n          echo net stop FortunaWebService >> staging\\\\backend\\\\restart_service.bat\n          echo net start FortunaWebService >> staging\\\\backend\\\\restart_service.bat\n          echo Created restart_service.bat for installer inclusion.\n\n      - uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ env.DOTNET_VERSION }}\n\n      - name: '\u2696\ufe0f The Dietician (Size Analysis)'\n        shell: pwsh\n        run: |\n          $target = \"staging\"\n          $limitMB = 300\n          Write-Host \"--- \ud83d\udcca Size Breakdown ---\"\n          $files = Get-ChildItem -Path $target -Recurse -File -ErrorAction SilentlyContinue\n          if (!$files) { Write-Warning \"No files found to weigh.\"; exit 0 }\n          $totalBytes = ($files | Measure-Object -Property Length -Sum).Sum\n          $totalMB = [math]::Round($totalBytes / 1MB, 2)\n          Write-Host \"Total Payload Size: $totalMB MB\"\n          if ($totalMB -gt $limitMB) {\n              Write-Warning \"\u26a0\ufe0f BLOAT ALERT: Build exceeds $limitMB MB limit! Check the heaviest files below.\"\n          } else {\n              Write-Host \"\u2705 Size within limits (< $limitMB MB).\" -ForegroundColor Green\n          }\n          Write-Host \"`n--- \ud83d\udc18 Top 10 Heaviest Files ---\"\n          $files | Sort-Object Length -Descending | Select-Object -First 10 @{N='File';E={$_.FullName.Replace($pwd,'')}}, @{N='Size(MB)';E={\"{0:N2}\" -f ($_.Length/1MB)}} | Format-Table -AutoSize\n\n      - name: \ud83d\udcc4 Ensure WiX License Exists\n        shell: pwsh\n        run: |\n          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }\n          $licensePath = 'build_wix/license.rtf'\n          if (-not (Test-Path $licensePath)) {\n            Write-Host '\u26a0\ufe0f License file missing. Generating placeholder...'\n            # FIX: Use Base64 decoding to avoid RTF escape sequence issues\n            $rtfContent = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(\"e1xydGYxXGFuc2lcZGVmZjB7XGZvbnR0Ymx7XGYwIEFyaWFsO319XGYwXGZzMjQgRU5EIFVTRVIgTElDRU5TRSBBR1JFRU1FTlRccGFyXHBhciBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgbGljZW5zZSBmb3IgRm9ydHVuYSBGYXVjZXQuIFBsZWFzZSByZXBsYWNlIHdpdGggYWN0dWFsIHRlcm1zLn0=\"))\n            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii\n            Write-Host '\u2705 Placeholder license.rtf created.'\n          } else {\n            Write-Host '\u2705 Existing license.rtf found.'\n          }\n      - name: Prepare WiX\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }\n\n          # Copy template and apply fix\n          Copy-Item build_wix/Product_WithService.wxs build_wix/Product.wxs -Force\n\n          # Stage Executable\n          if (Test-Path staging/backend/fortuna-backend.exe) {\n            Move-Item staging/backend/fortuna-backend.exe staging/backend/fortuna-webservice.exe -Force\n          }\n\n          # FIX: Generate Valid .wixproj with Extensions\n          $proj = @(\n            '<Project Sdk=\"WixToolset.Sdk/${{ env.WIX_VERSION }}\">',\n            '  <PropertyGroup>',\n            '    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>',\n            '    <OutputType>Package</OutputType>',\n            '    <Platforms>x64</Platforms>',\n            '    <DefineConstants>Version=$(Version);SourceDir=$(SourceDir);ServicePort=$(ServicePort)</DefineConstants>',\n            '  </PropertyGroup>',\n            '  <ItemGroup>',\n            '    <PackageReference Include=\"WixToolset.UI.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '    <PackageReference Include=\"WixToolset.Firewall.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '    <PackageReference Include=\"WixToolset.Util.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '  </ItemGroup>',\n            '  <ItemGroup>',\n            '    <Compile Include=\"Product.wxs\" />',\n            '  </ItemGroup>',\n            '</Project>'\n          )\n          Set-Content build_wix/Fortuna.wixproj ($proj -join \"`r`n\") -Encoding utf8\n      - name: \ud83d\udd2c Forensic Packaging Analysis\n        shell: pwsh\n        run: |\n          Write-Host \"=== STAGING DIRECTORY MANIFEST ===\"\n          Get-ChildItem -Path staging -Recurse | Sort-Object Length | Format-Table FullName, Length, LastWriteTime -AutoSize\n\n          Write-Host \"=== CRITICAL DLL CHECK ===\"\n          $critical = @(\"vcruntime140.dll\", \"python3.dll\", \"sqlite3.dll\")\n          foreach ($file in $critical) {\n            $found = Get-ChildItem -Path staging -Recurse -Filter $file\n            if ($found) { Write-Host \"\u2705 FOUND: $file\" -ForegroundColor Green }\n            else { Write-Host \"\u274c MISSING: $file (This will cause a crash)\" -ForegroundColor Red }\n          }\n      - name: Build MSI\n        working-directory: ${{ env.WIX_DIR }}\n        # FIX: Pass variables via DefineConstants\n        run: dotnet build Fortuna.wixproj -c Release -p:Platform=x64 -p:Version=\"0.0.${{ github.run_number }}\" -p:SourceDir=\"../staging/backend\" -p:ServicePort=\"${{ env.FORTUNA_PORT }}\"\n\n      - name: '\ud83d\udc24 The Canary (Malware Pre-Flight)'\n        shell: pwsh\n        run: |\n          $msi = Get-ChildItem -Path \"${{ env.WIX_DIR }}/bin/x64/Release\" -Filter \"*.msi\" | Select-Object -First 1\n          if (!$msi) { Write-Warning \"No MSI found to scan.\"; exit 0 }\n          Write-Host \"\ud83d\udd0d Scanning $($msi.Name) with Windows Defender...\"\n          $defender = \"C:\\Program Files\\Windows Defender\\MpCmdRun.exe\"\n          if (-not (Test-Path $defender)) { Write-Warning \"Windows Defender CLI not found.\"; exit 0 }\n          $proc = Start-Process -FilePath $defender -ArgumentList \"-Scan -ScanType 3 -File `\"$($msi.FullName)`\"\" -Wait -PassThru -NoNewWindow\n          if ($proc.ExitCode -eq 0) { Write-Host \"\u2705 CLEAN: Windows Defender found no threats.\" -ForegroundColor Green }\n          elseif ($proc.ExitCode -eq 2) { Write-Error \"\ud83d\udea8 THREAT DETECTED!\"; exit 1 }\n          else { Write-Warning \"\u26a0\ufe0f Scan inconclusive: $($proc.ExitCode)\" }\n\n      - name: Rename & Hash MSI\n        id: name_msi\n        shell: pwsh\n        run: |\n          $ver = \"${{ needs.build-backend.outputs.semver }}\"\n          $sha = \"${{ needs.build-backend.outputs.short_sha }}\"\n\n          # FIX: Don't assume the name. Find whatever MSI was built.\n          $releaseDir = \"${{ env.WIX_DIR }}/bin/x64/Release\"\n          $msiFound = Get-ChildItem -Path $releaseDir -Filter \"*.msi\" | Select-Object -First 1\n\n          if (-not $msiFound) {\n            Write-Error \"\u274c FATAL: No MSI file found in $releaseDir. Build may have failed silently.\"\n            exit 1\n          }\n\n          Write-Host \"Found built MSI: $($msiFound.Name)\"\n\n          $targetName = \"HatTrickFusion-${ver}-${sha}.msi\"\n          $newPath = Join-Path $releaseDir $targetName\n\n          Move-Item -Path $msiFound.FullName -Destination $newPath -Force\n\n          # Generate Hash\n          $hash = (Get-FileHash $newPath -Algorithm SHA256).Hash\n          $hash | Out-File \"$newPath.sha256\" -Encoding utf8\n\n          Write-Host \"\u2705 MSI Renamed to: $targetName\"\n          \"msi_name=$targetName\" | Out-File $env:GITHUB_OUTPUT -Append\n\n      - name: Upload MSI\n        uses: actions/upload-artifact@v4\n        with:\n          name: msi-installer-${{ github.run_id }}-${{ github.run_attempt }}\n          path: ${{ env.WIX_DIR }}/bin/x64/Release/*\n          retention-days: 7\n\n  # ==================================================================================\n  # JOB 5: SMOKE TEST (Triple-Loop + Paparazzi)\n  # ==================================================================================\n  smoke-test:\n    name: '\ud83d\udd2c Smoke Test'\n    runs-on: windows-latest\n    needs: [package-msi]\n    timeout-minutes: 30\n    steps:\n      - uses: actions/download-artifact@v4\n        with:\n          name: msi-installer-${{ github.run_id }}-${{ github.run_attempt }}\n          path: installer\n      - name: \ud83d\udee1\ufe0f Firewall & Install\n        shell: pwsh\n        run: |\n          New-NetFirewallRule -DisplayName \"${{ env.FIREWALL_RULE }}\" -Direction Inbound -LocalPort ${{ env.FORTUNA_PORT }} -Protocol TCP -Action Allow\n          if (Get-Service -Name FortunaWebService -ErrorAction SilentlyContinue) {\n            sc.exe stop FortunaWebService 2>&1 | Out-Null\n            sc.exe delete FortunaWebService 2>&1 | Out-Null\n          }\n          $msi = Get-ChildItem installer -Filter \"*.msi\" -Recurse | Select -First 1\n          if (!$msi) { throw \"No MSI found\" }\n          Write-Host \"Installing $($msi.Name)...\"\n          $msiPath = $msi.FullName\n          $args = \"/i `\"$msiPath`\" /qn /L*v installation.log\"\n          $proc = Start-Process msiexec.exe -ArgumentList $args -Wait -NoNewWindow -PassThru\n          if ($proc.ExitCode -ne 0) {\n            Get-Content install.log -Tail 50\n            throw \"Install failed with code $($proc.ExitCode)\"\n          }\n\n      - name: Create Runtime Directories\n        shell: pwsh\n        run: |\n          $installDir = \"C:\\Program Files\\Fortuna Faucet Service\"\n          New-Item -ItemType Directory -Path \"$installDir\\data\" -Force\n          New-Item -ItemType Directory -Path \"$installDir\\json\" -Force\n          New-Item -ItemType Directory -Path \"$installDir\\logs\" -Force\n          Write-Host \"\u2705 Ensured runtime directories exist in $installDir\"\n      - name: \"\ud83d\udd0d Debug Backend Launch (With Timeout)\"\n        shell: pwsh\n        run: |\n          $exe = \"C:\\Program Files\\Fortuna Faucet Service\\fortuna-webservice.exe\"\n          if (Test-Path $exe) {\n            Write-Host \"Starting backend for 10s health check...\"\n            $proc = Start-Process -FilePath $exe -PassThru\n            Start-Sleep -Seconds 10\n            \n            if (!$proc.HasExited) {\n              Write-Host \"\u2705 Backend is running (Alive for 10s). Killing it now.\"\n              Stop-Process -Id $proc.Id -Force\n            } else {\n              Write-Error \"\u274c Backend crashed immediately! Check logs.\"\n              exit 1\n            }\n          } else {\n            Write-Warning \"Backend not found at expected path.\"\n          }\n      - name: '\u23f3 Loop 1 - Service Registration'\n        shell: pwsh\n        run: |\n          $reg = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\FortunaWebService\"\n          for ($i=0; $i -lt 30; $i++) {\n            if (Test-Path $reg) { Write-Host \"\u2705 Service Registered\"; exit 0 }\n            Start-Sleep 1\n          }\n          throw \"Service failed to register in Registry\"\n\n      - name: '\ud83d\ude80 Loop 2 - Launch & Port Bind'\n        shell: python\n        env:\n          PORT: ${{ env.FORTUNA_PORT }}\n        run: |\n          import os, socket, time, urllib.request, urllib.error, subprocess, sys\n          port = int(os.environ[\"PORT\"])\n          print(\"--- Starting Service ---\")\n          subprocess.run([\"sc.exe\", \"start\", \"FortunaWebService\"], check=False)\n          print(f\"--- Waiting for Port {port} (60s) ---\")\n          for _ in range(60):\n            try:\n              with socket.create_connection((\"127.0.0.1\", port), timeout=1):\n                print(\"[SUCCESS] Socket bound.\")\n                sys.exit(0)\n            except:\n              time.sleep(1)\n\n          print(\"[FAILED] Port bind timeout\")\n          subprocess.run([\"sc.exe\", \"query\", \"FortunaWebService\"])\n          sys.exit(1)\n\n      - name: Test Service Health (Smoke Test)\n        shell: pwsh\n        run: |\n          $maxAttempts = 10\n          $healthUrl = \"http://localhost:8102/health\"\n          for ($i = 1; $i -le $maxAttempts; $i++) {\n            try {\n              # FIX: Use ${maxAttempts} to prevent colon parsing error\n              Write-Host \"Attempt $i/${maxAttempts}: Pinging $healthUrl...\"\n              $response = Invoke-WebRequest -Uri $healthUrl -Method Get -UseBasicParsing -ErrorAction Stop\n              if ($response.StatusCode -eq 200) {\n                Write-Host \"\u2705 Service is Healthy on Port 8102\"\n                exit 0\n              }\n            } catch {\n              Write-Host \"\u23f3 Waiting for service...\"\n              Start-Sleep -Seconds 5\n            }\n          }\n          Write-Error \"\u274c Service Failed Health Check after $maxAttempts attempts\"\n          exit 1\n\n      - name: '\ud83d\udcf8 The Paparazzi (Visual Proof)'\n        shell: pwsh\n        run: |\n          Write-Host \"Installing Playwright (Node.js)...\"\n          npm install playwright\n          npx playwright install chromium --with-deps\n          \n          $url = \"http://127.0.0.1:8102/health\"\n          node -e \"\n            const { chromium } = require('playwright');\n            (async () => {\n              try {\n                const browser = await chromium.launch();\n                const page = await browser.newPage();\n                await page.goto('$url', { timeout: 15000 });\n                await page.screenshot({ path: 'proof-of-life.png', fullPage: true });\n                await browser.close();\n              } catch (e) { process.exit(1); }\n            })();\n          \"\n\n      - name: Upload Visual Proof\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: visual-proof-${{ github.run_id }}\n          path: proof-of-life.png\n\n      - name: \ud83d\udcca Capture Diagnostics\n        if: failure()\n        shell: pwsh\n        run: |\n          $diag = \"diagnostics\"\n          New-Item -ItemType Directory -Path $diag -Force\n          Copy-Item install.log $diag\n          Get-EventLog -LogName Application -Source \"FortunaWebService\" -Newest 50 | Out-File \"$diag/events.txt\"\n          Get-Service FortunaWebService | Out-File \"$diag/service_state.txt\"\n          netstat -anob > \"$diag/netstat.txt\"\n      - name: \ud83d\udce4 Upload Diagnostics\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: smoke-test-failure-${{ needs.path-finder.outputs.build_id }}\n          path: diagnostics/\n          retention-days: 30\n      - name: \"\ud83d\udc80 CSI: Windows (Post-Mortem Diagnostics)\"\n        if: failure()\n        shell: pwsh\n        run: |\n          Write-Host \"=== 1. PROCESS STATE ===\"\n          Get-Process | Where-Object { $_.ProcessName -match \"fortuna|python|electron\" } | Format-Table -AutoSize\n\n          Write-Host \"=== 2. NETWORK PORTS (8102) ===\"\n          netstat -anb | Select-String \"8102\" -Context 2,2\n\n          Write-Host \"=== 3. WINDOWS EVENT LOGS (Last 50 Errors) ===\"\n          Get-EventLog -LogName Application -EntryType Error,Warning -Newest 50 | Format-Table TimeGenerated, Source, Message -AutoSize\n\n          Write-Host \"=== 4. MSI INSTALL LOG ===\"\n          if (Test-Path \"installation.log\") { Get-Content \"installation.log\" -Tail 200 }\n      - name: \ud83e\uddf9 Cleanup\n        if: always()\n        run: |\n          sc.exe stop FortunaWebService\n          sc.exe delete FortunaWebService\n          Remove-NetFirewallRule -DisplayName \"${{ env.FIREWALL_RULE }}\" -ErrorAction SilentlyContinue\n      - name: \"\ud83d\uded1 Stop Fortuna Service\"\n        if: always()\n        shell: cmd\n        run: net stop FortunaWebService || echo Service was not running\n\n  # ==================================================================================\n  # JOB 6: GENERATE SBOM\n  # ==================================================================================\n  generate-sbom:\n    name: '\ud83d\udcdc Generate SBOM'\n    runs-on: ubuntu-latest\n    needs: [build-backend]\n    timeout-minutes: 30\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/download-artifact@v4\n        with:\n          name: backend-dist-${{ github.run_id }}-${{ github.run_attempt }}\n          path: backend\n      - name: Create SBOM\n        uses: anchore/sbom-action@v0\n        with:\n          path: backend\n          output-file: sbom.spdx.json\n          format: spdx-json\n      - name: Upload SBOM\n        uses: actions/upload-artifact@v4\n        with:\n          name: sbom-${{ github.run_id }}-${{ github.run_attempt }}\n          path: sbom.json\n\n  # ==================================================================================\n  # JOB 7: RELEASE (On Tag)\n  # ==================================================================================\n  release:\n    name: '\ud83d\ude80 Create Release'\n    runs-on: ubuntu-latest\n    if: startsWith(github.ref, 'refs/tags/')\n    needs: [smoke-test, generate-sbom]\n    timeout-minutes: 30\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/download-artifact@v4\n        with:\n          name: msi-installer-${{ github.run_id }}-${{ github.run_attempt }}\n          path: assets\n      - uses: actions/download-artifact@v4\n        with:\n          name: sbom-${{ github.run_id }}-${{ github.run_attempt }}\n          path: assets\n      - name: Generate Checksums\n        run: |\n          cd assets\n          sha256sum * > SHASUMS256.txt\n      - name: Publish Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            build_wix/FortunaWebSetup.msi\n            sbom.json\n          draft: false\n          prerelease: false\n",
    ".github/workflows/build-msi-unified.yml": "name: Unified MSI Builder (Gold Standard)\n\non:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\nenv:\n  NODE_VERSION: '20'\n  PYTHON_VERSION: '3.12'\n  DOTNET_VERSION: '8.0.x'\n  WIX_VERSION: '4.0.5'\n  FRONTEND_DIR: 'web_platform/frontend'\n  WIX_DIR: 'build_wix'\n  SERVICE_PORT: '8102'\n  UPGRADE_CODE: 'FA689549-366B-4C5C-A482-1132F9A34B10'\n  # Mock API keys for service startup stability\n  API_KEY: mock_key\n  TVG_API_KEY: mock\n  GREYHOUND_API_URL: http://mock\n  FORTUNA_ENV: smoke-test\n\njobs:\n  quality-gate:\n    name: '\u2705 Quality Gate'\n    runs-on: windows-latest\n    timeout-minutes: 15\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n          cache-dependency-path: 'web_service/backend/requirements.txt'\n\n      - name: Install Python Dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r web_service/backend/requirements.txt\n          pip install pytest pytest-asyncio httpx asgi-lifespan fakeredis\n\n      - name: Run Pytest (Soft Fail)\n        shell: pwsh\n        run: |\n          $MAX_FAILURES = 30\n          Write-Host \"Running Test Suite (Threshold: $MAX_FAILURES failures)...\"\n          cmd /c \"pytest web_service/backend --junitxml=test-report.xml\" || Write-Host \"Pytest finished with issues.\"\n\n          if (Test-Path \"test-report.xml\") {\n              [xml]$xml = Get-Content \"test-report.xml\"\n              $failures = 0; $errors = 0\n              if ($xml.testsuites) { $failures = [int]$xml.testsuites.failures; $errors = [int]$xml.testsuites.errors }\n              elseif ($xml.testsuite) { $failures = [int]$xml.testsuite.failures; $errors = [int]$xml.testsuite.errors }\n\n              $total = $failures + $errors\n              Write-Host \"Total Issues: $total (Limit: $MAX_FAILURES)\"\n              if ($total -gt $MAX_FAILURES) { Write-Error \"\u274c Too many failures.\"; exit 1 }\n              else { Write-Host \"\u2705 Failure count acceptable.\"; exit 0 }\n          } else {\n              Write-Warning \"No test report found. Skipping gate.\"\n          }\n\n  build-executable:\n    name: '\ud83d\udee0\ufe0f Build Executable'\n    runs-on: windows-latest\n    needs: [quality-gate]\n    timeout-minutes: 20\n    env:\n      BACKEND_DIR: 'web_service/backend'\n      BACKEND_MODULE_PATH: 'web_service.backend'\n    outputs:\n      build_id: ${{ steps.vars.outputs.build_id }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Set Build ID\n        id: vars\n        run: echo \"build_id=${{ github.run_id }}-${{ github.run_attempt }}\" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'\n\n      - name: Build Frontend\n        shell: pwsh\n        run: |\n          cd \"${{ env.FRONTEND_DIR }}\"\n          npm ci --prefer-offline\n          npm run build\n          if (-not (Test-Path \"out\")) { throw \"Frontend build failed.\" }\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n          cache-dependency-path: '${{ env.BACKEND_DIR }}/requirements.txt'\n\n      - name: Build Backend (PyInstaller)\n        shell: python\n        env:\n          BACKEND_DIR: ${{ env.BACKEND_DIR }}\n          MODULE_PATH: ${{ env.BACKEND_MODULE_PATH }}\n          FRONTEND_OUT: ${{ env.FRONTEND_DIR }}/out\n        run: |\n          import os\n          from pathlib import Path\n\n          # Install deps\n          os.system(\"pip install -r \" + os.environ['BACKEND_DIR'] + \"/requirements.txt\")\n          os.system(\"pip install pyinstaller==6.6.0\")\n\n          bk_dir = os.environ['BACKEND_DIR'].replace('\\\\', '/')\n          mod_path = os.environ['MODULE_PATH']\n          frontend_out = os.environ['FRONTEND_OUT'].replace('\\\\', '/')\n          entry = f\"{bk_dir}/main.py\"\n\n          spec = f\"\"\"\n          # -- mode: python ; coding: utf-8 --\n          from PyInstaller.utils.hooks import collect_data_files, collect_submodules\n          block_cipher = None\n          a = Analysis(\n              ['{entry}'],\n              pathex=[],\n              binaries=[],\n              datas=collect_data_files('uvicorn') + collect_data_files('slowapi') + [('{frontend_out}', 'ui')],\n              # FIX: Added win32timezone to prevent Error 1053\n              hiddenimports=collect_submodules('{mod_path}') + ['win32timezone'],\n              hookspath=[],\n              runtime_hooks=[],\n              excludes=['tests', 'pytest'],\n              win_no_prefer_redirects=False,\n              win_private_assemblies=False,\n              cipher=block_cipher,\n              noarchive=False,\n          )\n          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n          exe = EXE(\n              pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],\n              name='fortuna-backend', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=False\n          )\n          \"\"\"\n          with open(\"unified.spec\", \"w\") as f: f.write(spec)\n          os.system(\"pyinstaller unified.spec --clean --noconfirm\")\n\n      - name: Upload Backend Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: backend-dist-${{ steps.vars.outputs.build_id }}\n          path: dist/fortuna-backend.exe\n          retention-days: 1\n\n  package-msi:\n    name: '\ud83d\udcbf Package MSI'\n    runs-on: windows-latest\n    needs: [build-executable]\n    timeout-minutes: 20\n    outputs:\n      build_id: ${{ needs.build-executable.outputs.build_id }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Download Backend Artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: backend-dist-${{ needs.build-executable.outputs.build_id }}\n          path: staging/backend\n\n      - name: Prepare Staging\n        shell: pwsh\n        run: |\n          # Rename EXE for WiX\n          Rename-Item -Path staging/backend/fortuna-backend.exe -NewName fortuna-webservice.exe -Force\n\n          # Create Restart Script (Required by WiX)\n          $scriptContent = \"@echo off`r`necho Requesting Admin privileges...`r`nnet stop FortunaWebService`r`nnet start FortunaWebService`r`necho Service Restarted.`r`npause\"\n          Set-Content -Path \"staging/backend/restart_service.bat\" -Value $scriptContent -Encoding Ascii\n          Write-Host \"\u2705 Created restart_service.bat\"\n\n      - name: Setup .NET SDK\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ env.DOTNET_VERSION }}\n\n      - name: Prepare WiX Project\n        shell: pwsh\n        run: |\n          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }\n\n          # License\n          if (-not (Test-Path 'build_wix/license.rtf')) {\n             Set-Content -Path 'build_wix/license.rtf' -Value '{\\rtf1\\ansi Placeholder License}' -Encoding Ascii\n          }\n\n          # Copy WXS\n          Copy-Item \"${{ env.WIX_DIR }}/Product_WithService.wxs\" \"${{ env.WIX_DIR }}/Product.wxs\" -Force\n\n          # Generate Project\n          $proj = @(\n            '<Project Sdk=\"WixToolset.Sdk/${{ env.WIX_VERSION }}\">',\n            '  <PropertyGroup>',\n            '    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>',\n            '    <OutputType>Package</OutputType>',\n            '    <Platforms>x64</Platforms>',\n            '    <DefineConstants>Version=$(Version);SourceDir=$(SourceDir);ServicePort=$(ServicePort)</DefineConstants>',\n            '  </PropertyGroup>',\n            '  <ItemGroup>',\n            '    <PackageReference Include=\"WixToolset.UI.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '    <PackageReference Include=\"WixToolset.Firewall.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '    <PackageReference Include=\"WixToolset.Util.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '  </ItemGroup>',\n            '  <ItemGroup>',\n            '    <Compile Include=\"Product.wxs\" />',\n            '  </ItemGroup>',\n            '</Project>'\n          )\n          Set-Content \"${{ env.WIX_DIR }}/Fortuna.wixproj\" -Value ($proj -join \"`r`n\") -Encoding utf8\n\n      - name: Build MSI\n        working-directory: ${{ env.WIX_DIR }}\n        run: dotnet build Fortuna.wixproj -c Release -p:Platform=x64 -p:Version=\"0.0.${{ github.run_number }}\" -p:SourceDir=\"../staging/backend\" -p:ServicePort=\"${{ env.SERVICE_PORT }}\"\n\n      - name: Upload MSI Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: msi-installer-${{ needs.build-executable.outputs.build_id }}\n          path: ${{ env.WIX_DIR }}/bin/x64/Release/*\n          retention-days: 1\n\n  smoke-test:\n    name: '\ud83d\udd2c Smoke Test'\n    runs-on: windows-latest\n    needs: package-msi\n    timeout-minutes: 20\n    steps:\n      - name: Download MSI\n        uses: actions/download-artifact@v4\n        with:\n          name: msi-installer-${{ needs.package-msi.outputs.build_id }}\n          path: msi-installer\n\n      - name: Install MSI\n        shell: pwsh\n        run: |\n          $msi = Get-ChildItem -Path \"msi-installer\" -Filter \"*.msi\" -Recurse | Select-Object -First 1\n          if (-not $msi) { throw \"No MSI found\" }\n          Write-Host \"Installing $($msi.Name)...\"\n          $proc = Start-Process msiexec.exe -ArgumentList \"/i `\"$($msi.FullName)`\" /qn /L*v msi-install.log\" -Wait -PassThru\n          if ($proc.ExitCode -ne 0) { throw \"Install failed: $($proc.ExitCode)\" }\n\n      - name: Wait for Service & Port\n        shell: python\n        env:\n          PORT: ${{ env.SERVICE_PORT }}\n        run: |\n          import socket, time, subprocess, sys, os\n          port = int(os.environ[\"PORT\"])\n          print(f\"Waiting for port {port}...\")\n\n          # Force start if needed\n          subprocess.run([\"sc.exe\", \"start\", \"FortunaWebService\"], check=False)\n\n          for i in range(60):\n            try:\n              with socket.create_connection((\"127.0.0.1\", port), timeout=1):\n                print(\"\u2705 Socket bound!\")\n                sys.exit(0)\n            except:\n              time.sleep(1)\n\n          print(\"\u274c Timeout waiting for port.\")\n          subprocess.run([\"sc.exe\", \"query\", \"FortunaWebService\"])\n          sys.exit(1)\n\n      - name: '\ud83d\udcf8 The Paparazzi (Visual Proof)'\n        shell: pwsh\n        run: |\n          Write-Host \"Installing Playwright (Node.js)...\"\n          npm install playwright\n          npx playwright install chromium --with-deps\n          \n          $url = \"http://127.0.0.1:${{ env.SERVICE_PORT }}/health\"\n          node -e \"\n            const { chromium } = require('playwright');\n            (async () => {\n              try {\n                const browser = await chromium.launch();\n                const page = await browser.newPage();\n                await page.goto('$url', { timeout: 15000 });\n                await page.screenshot({ path: 'proof.png', fullPage: true });\n                await browser.close();\n              } catch (e) { process.exit(1); }\n            })();\n          \"\n      - name: Upload Proof\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: visual-proof-${{ github.run_id }}\n          path: proof.png\n\n      - name: Cleanup\n        if: always()\n        run: sc.exe delete FortunaWebService\n",
    ".github/workflows/build-web-service-msi-jules.yml": "# System Timestamp: 2025-12-04 16:01:12.318079\nname: Build Fortuna Faucet Web Service Installer (Synthesized Overkill)\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n  actions: read\n  checks: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\ndefaults:\n  run:\n    shell: pwsh\n\nenv:\n  NODE_VERSION: '20'\n  PYTHON_VERSION: '3.12'\n  DOTNET_VERSION: '8.0.x'\n  PYTHONUTF8: '1'\n  PIP_DISABLE_PIP_VERSION_CHECK: '1'\n  PIP_NO_PYTHON_VERSION_WARNING: '1'\n  NPM_CONFIG_FUND: 'false'\n  NPM_CONFIG_AUDIT: 'false'\n  FORCE_COLOR: '3'\n  FRONTEND_DIR: 'web_platform/frontend'\n  FRONTEND_BUILD_DIR: 'web_platform/frontend/out'\n  WIX_DIR: 'build_wix'\n  SERVICE_PORT: '8102'\n  HEALTH_ENDPOINT: '/health'\n  API_KEY: ${{ secrets.TEST_API_KEY }}\n  TVG_API_KEY: \"mock_key\"\n  GREYHOUND_API_URL: \"http://mock\"\n  FORTUNA_ENV: \"smoke-test\"\n  MSI_STAGING_DIR: 'build_wix/staging'\n  MSI_OUTPUT_DIR: 'dist'\n  WIX_VERSION: '4.0.5'\n\njobs:\n  path-finder:\n    name: '\ud83d\udd0e Path Finder Dynamic Backend Detection'\n    runs-on: windows-latest\n    outputs:\n      backend_dir: ${{ steps.find-path.outputs.backend_dir }}\n      backend_module_path: ${{ steps.find-path.outputs.backend_module_path }}\n      spec_file: ${{ steps.find-path.outputs.spec_file }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Detect Backend Path\n        id: find-path\n        run: |\n          Set-StrictMode -Version Latest\n          $web_service_path = \"web_service/backend\"\n          $python_service_path = \"python_service\"\n          $backend_dir = \"\"\n          $backend_module_path = \"\"\n          $spec_file = \"\"\n\n          Write-Host \"--- Path Finding Forensics ---\"\n          Write-Host \"Searching for the correct backend service directory...\"\n\n          # Test web_service path\n          $web_service_main = Test-Path (Join-Path $web_service_path \"main.py\")\n          $web_service_api = Test-Path (Join-Path $web_service_path \"api.py\")\n          $web_service_init = Test-Path (Join-Path $web_service_path \"__init__.py\")\n          Write-Host \"Checking '$web_service_path':\"\n          Write-Host \"  main.py -> $web_service_main\"\n          Write-Host \"  api.py -> $web_service_api\"\n          Write-Host \"  __init__.py -> $web_service_init\"\n\n          # Test python_service path\n          $python_service_main = Test-Path (Join-Path $python_service_path \"main.py\")\n          $python_service_api = Test-Path (Join-Path $python_service_path \"api.py\")\n          $python_service_init = Test-Path (Join-Path $python_service_path \"__init__.py\")\n          Write-Host \"Checking '$python_service_path':\"\n          Write-Host \"  main.py -> $python_service_main\"\n          Write-Host \"  api.py -> $python_service_api\"\n          Write-Host \"  __init__.py -> $python_service_init\"\n\n          if ($web_service_main -and $web_service_api -and $web_service_init) {\n            $backend_dir = $web_service_path\n            $backend_module_path = \"web_service.backend\"\n            $spec_file = \"jules.spec\"\n            Write-Host \"\u2705 Verdict: Detected 'web_service/backend' as the target.\" -ForegroundColor Green\n          } elseif ($python_service_main -and $python_service_api -and $python_service_init) {\n            $backend_dir = $python_service_path\n            $backend_module_path = \"python_service\"\n            $spec_file = \"fortuna-backend-webservice.spec\"\n            Write-Host \"\u2705 Verdict: Detected 'python_service' as the target.\" -ForegroundColor Green\n          } else {\n            Write-Host \"\u274c FATAL: Could not determine a valid backend directory. Neither 'web_service/backend' nor 'python_service' contains the required files (main.py, api.py, __init__.py).\" -ForegroundColor Red\n            exit 1\n          }\n\n          Write-Host \"--- Outputs ---\"\n          Write-Host \"backend_dir: $backend_dir\"\n          Write-Host \"backend_module_path: $backend_module_path\"\n          Write-Host \"spec_file: $spec_file\"\n\n          \"backend_dir=$backend_dir\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"backend_module_path=$backend_module_path\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"spec_file=$spec_file\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n  system-check:\n    name: '\u2699\ufe0f System Prerequisites'\n    runs-on: windows-latest\n    timeout-minutes: 5\n    outputs:\n      disk_free_gb: ${{ steps.system.outputs.disk_gb }}\n    steps:\n      - name: Verify Build Tools\n        run: |\n          Set-StrictMode -Version Latest\n          $tools = @('dotnet', 'python', 'node', 'npm', 'git')\n          foreach ($tool in $tools) {\n            Write-Host \"Checking for $($tool)...\"\n            Get-Command $tool -ErrorAction SilentlyContinue\n            if (-not $?) {\n              Write-Host \"\u274c FATAL: Build tool '$tool' not found in PATH.\" -ForegroundColor Red\n              exit 1\n            }\n          }\n          Write-Host \"\u2705 All critical build tools are present.\" -ForegroundColor Green\n      - name: Check Disk Space\n        id: system\n        run: |\n          Set-StrictMode -Version Latest\n          $disk = Get-Volume | Where-Object { $_.DriveLetter -eq 'C' }\n          $freeGB = [math]::Round($disk.SizeRemaining / 1GB, 2)\n          if ($freeGB -lt 10) {\n            Write-Host \"\u26a0\ufe0f WARNING: Low disk space. Only $freeGB GB free (10+ GB recommended).\" -ForegroundColor Yellow\n          } else {\n            Write-Host \"\u2705 Disk space check passed ($freeGB GB free).\" -ForegroundColor Green\n          }\n          \"disk_gb=$freeGB\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n\n  repo-preflight:\n    name: '\ud83e\uddea Repo Preflight & Integrity'\n    runs-on: windows-latest\n    needs: [path-finder, system-check]\n    timeout-minutes: 5\n    outputs:\n      frontend_lock_hash: ${{ steps.hashes.outputs.frontend_lock_hash }}\n      backend_requirements_hash: ${{ steps.hashes.outputs.backend_requirements_hash }}\n      wix_definition_hash: ${{ steps.hashes.outputs.wix_definition_hash }}\n      semver: ${{ steps.meta.outputs.semver }}\n      short_sha: ${{ steps.meta.outputs.short_sha }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Derive Build Metadata\n        id: meta\n        run: |\n          Set-StrictMode -Version Latest\n          $ref = \"${{ github.ref }}\"\n          if ($ref -like 'refs/tags/v*') {\n            $semver = $ref -replace 'refs/tags/v', ''\n          } else {\n            $semver = \"0.0.${{ github.run_number }}\"\n          }\n          $shortSha = \"${{ github.sha }}\".Substring(0,7)\n          \"semver=$semver\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"short_sha=$shortSha\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          Write-Host \"\ud83d\udd16 Version: $semver ($shortSha)\"\n\n      - name: Validate Critical Files Exist\n        env:\n          BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}\n        run: |\n          Set-StrictMode -Version Latest\n          $paths = @(\n            \"${{ env.FRONTEND_DIR }}/package.json\",\n            \"${{ env.FRONTEND_DIR }}/package-lock.json\",\n            (Join-Path $env:BACKEND_DIR \"requirements.txt\"),\n            (Join-Path $env:BACKEND_DIR \"main.py\"),\n            \"${{ env.WIX_DIR }}/Product_WithService.wxs\"\n          )\n          foreach ($path in $paths) {\n            if (-not (Test-Path $path)) {\n              Write-Host \"\u274c FATAL: Required path missing: $path\" -ForegroundColor Red\n              exit 1\n            }\n          }\n          Write-Host \"\u2705 All critical files confirmed.\"\n\n      - name: Capture Integrity Hashes\n        id: hashes\n        env:\n          BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}\n        run: |\n          Set-StrictMode -Version Latest\n          $frontend = (Get-FileHash \"${{ env.FRONTEND_DIR }}/package-lock.json\" -Algorithm SHA256).Hash\n          $backend = (Get-FileHash (Join-Path $env:BACKEND_DIR \"requirements.txt\") -Algorithm SHA256).Hash\n          $wix = (Get-FileHash \"${{ env.WIX_DIR }}/Product_WithService.wxs\" -Algorithm SHA256).Hash\n          \"frontend_lock_hash=$frontend\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"backend_requirements_hash=$backend\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          \"wix_definition_hash=$wix\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n\n      - name: Upload Integrity Snapshot\n        uses: actions/upload-artifact@v4\n        with:\n          name: repo-preflight-${{ github.run_id }}\n          path: |\n            ${{ env.FRONTEND_DIR }}/package-lock.json\n            ${{ env.BACKEND_DIR }}/requirements.txt\n            ${{ env.WIX_DIR }}/Product_WithService.wxs\n          retention-days: 3\n\n  frontend-quality:\n    name: '\ud83e\uddfc Frontend Quality Gates'\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    needs: repo-preflight\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'\n\n      - name: Cache Frontend Build\n        id: cache-frontend\n        uses: actions/cache@v4\n        with:\n          path: ${{ env.FRONTEND_BUILD_DIR }}\n          key: ${{ runner.os }}-frontend-build-${{ hashFiles('${{ env.FRONTEND_DIR }}/**') }}\n\n      - name: Install Dependencies\n        run: |\n          Set-StrictMode -Version Latest\n          cd \"${{ env.FRONTEND_DIR }}\"\n          npm ci --prefer-offline --no-audit --no-fund\n\n      - name: Run Lint (if defined)\n        run: |\n          Set-StrictMode -Version Latest\n          cd \"${{ env.FRONTEND_DIR }}\"\n          $pkg = Get-Content package.json -Raw | ConvertFrom-Json\n          if ($pkg.scripts.PSObject.Properties.Name -contains 'lint') {\n            Write-Host \"\ud83e\uddf9 Running npm run lint\"\n            npm run lint\n          } else {\n            Write-Host \"\u2139\ufe0f No lint script defined, skipping.\"\n          }\n\n      - name: Run Tests (if defined)\n        run: |\n          Set-StrictMode -Version Latest\n          cd \"${{ env.FRONTEND_DIR }}\"\n          $pkg = Get-Content package.json -Raw | ConvertFrom-Json\n          if ($pkg.scripts.PSObject.Properties.Name -contains 'test') {\n            Write-Host \"\ud83e\uddea Running npm test -- --watch=false\"\n            npm test -- --watch=false\n          } else {\n            Write-Host \"\u2139\ufe0f No test script defined, skipping.\"\n          }\n\n      - name: Security Audit (non-blocking)\n        continue-on-error: true\n        run: |\n          Set-StrictMode -Version Latest\n          cd \"${{ env.FRONTEND_DIR }}\"\n          npm audit --audit-level=critical\n\n  backend-quality:\n    name: '\ud83e\uddef Backend Quality Gates'\n    runs-on: ubuntu-latest\n    timeout-minutes: 20\n    needs: [path-finder, repo-preflight]\n    env:\n      BACKEND_REQUIREMENTS_HASH: ${{ needs.repo-preflight.outputs.backend_requirements_hash }}\n      BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}\n      BACKEND_SPEC: ${{ needs.path-finder.outputs.spec_file }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n          cache-dependency-path: |\n            ${{ env.BACKEND_DIR }}/requirements.txt\n            ${{ env.BACKEND_DIR }}/requirements-dev.txt\n\n      - name: Cache Backend Build\n        id: cache-backend\n        uses: actions/cache@v4\n        with:\n          path: dist\n          key: ${{ runner.os }}-backend-build-${{ hashFiles(format('{0}/**', env.BACKEND_DIR), format('{0}', env.BACKEND_SPEC)) }}\n\n      - name: Install Dependencies\n        run: |\n          Set-StrictMode -Version Latest\n          python -m pip install --upgrade pip setuptools wheel\n          pip install -r (Join-Path $env:BACKEND_DIR \"requirements.txt\")\n          if (Test-Path (Join-Path $env:BACKEND_DIR \"requirements-dev.txt\")) {\n            pip install -r (Join-Path $env:BACKEND_DIR \"requirements-dev.txt\")\n          }\n\n      - name: Bytecode Compile (Fail Fast)\n        run: |\n          Set-StrictMode -Version Latest\n          python -m compileall -q \"${{ env.BACKEND_DIR }}\"\n\n      - name: Run Pytest (if available)\n        run: |\n          Set-StrictMode -Version Latest\n          python -c 'import importlib.util, sys; sys.exit(0 if importlib.util.find_spec(\"pytest\") else 1)'\n          if ($LASTEXITCODE -eq 0) {\n            Write-Host \"\ud83e\uddea pytest detected, running suite...\"\n            python -m pytest \"${{ env.BACKEND_DIR }}\" --maxfail=1 --disable-warnings\n          } else {\n            Write-Host \"\u2139\ufe0f pytest not installed; skipping tests.\"\n          }\n\n      - name: pip-audit (non-blocking)\n        continue-on-error: true\n        run: |\n          Set-StrictMode -Version Latest\n          pip install pip-audit\n          pip-audit -r (Join-Path $env:BACKEND_DIR \"requirements.txt\")\n\n  sbom:\n    name: '\ud83d\udcc4 SBOM Snapshot'\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    needs: repo-preflight\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Generate SBOM (SPDX)\n        uses: anchore/sbom-action@v0\n        with:\n          output-file: sbom.spdx.json\n          format: spdx-json\n\n      - name: Upload SBOM\n        uses: actions/upload-artifact@v4\n        with:\n          name: sbom-${{ github.run_id }}\n          path: sbom.spdx.json\n          retention-days: 7\n\n  build-frontend:\n    name: '\ud83d\udce6 Build Frontend'\n    runs-on: windows-latest\n    timeout-minutes: 20\n    needs: [path-finder, repo-preflight, frontend-quality]\n    env:\n      FRONTEND_LOCK_HASH: ${{ needs.repo-preflight.outputs.frontend_lock_hash }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'\n\n      - name: Cache Frontend Build\n        id: cache-frontend\n        uses: actions/cache@v4\n        with:\n          path: ${{ env.FRONTEND_BUILD_DIR }}\n          key: ${{ runner.os }}-frontend-build-${{ hashFiles('${{ env.FRONTEND_DIR }}/**') }}\n          restore-keys: |\n            ${{ runner.os }}-frontend-build-\n\n      - name: Prime npm Cache\n        uses: actions/cache@v4\n        with:\n          path: ~\\AppData\\Local\\npm-cache\n          key: ${{ runner.os }}-npm-${{ env.NODE_VERSION }}-${{ env.FRONTEND_LOCK_HASH }}\n          restore-keys: |\n            ${{ runner.os }}-npm-${{ env.NODE_VERSION }}-\n\n      - name: Install Dependencies\n        run: |\n          Set-StrictMode -Version Latest\n          cd \"${{ env.FRONTEND_DIR }}\"\n          npm ci --prefer-offline --no-audit --no-fund\n\n      - name: Build Frontend\n        if: steps.cache-frontend.outputs.cache-hit != 'true'\n        env:\n          NEXT_PUBLIC_API_URL: http://127.0.0.1:${{ env.SERVICE_PORT }}\n        run: |\n          Set-StrictMode -Version Latest\n          cd \"${{ env.FRONTEND_DIR }}\"\n          npm run build\n\n      - name: Report Cache Status\n        run: |\n          if ('${{ steps.cache-frontend.outputs.cache-hit }}' -eq 'true') {\n            Write-Host \"\u2705 Frontend build restored from cache.\" -ForegroundColor Green\n          } else {\n            Write-Host \"\u2139\ufe0f No cache hit. A new build was performed.\" -ForegroundColor Yellow\n          }\n\n      - name: Verify Build Output\n        run: |\n          Set-StrictMode -Version Latest\n          $outDir = Resolve-Path \"${{ env.FRONTEND_BUILD_DIR }}\"\n          if (-not (Test-Path $outDir)) {\n             Write-Host \"\u274c FATAL: Build directory not found\" -ForegroundColor Red\n             exit 1\n          }\n          $files = Get-ChildItem -Path $outDir -Recurse -File\n          if ($files.Count -eq 0) {\n             Write-Host \"\u274c FATAL: Build directory empty\" -ForegroundColor Red\n             exit 1\n          }\n          Write-Host \"\u2705 Frontend built: $($files.Count) files.\"\n\n      - name: Generate Artifact Manifest\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $outDir = Resolve-Path \"${{ env.FRONTEND_DIR }}/out\"\n          # Fallback for different env var names in different workflows\n          if (-not (Test-Path $outDir)) { $outDir = Resolve-Path \"${{ env.FRONTEND_BUILD_DIR }}\" }\n\n          if (-not (Test-Path $outDir)) { Write-Error \"\u274c Build failed: 'out' dir missing\"; exit 1 }\n\n          $manifestPath = \"frontend-manifest.tsv\"\n          \"RelativePath`tSizeBytes`tSHA256\" | Out-File $manifestPath -Encoding utf8\n\n          $files = Get-ChildItem -Path $outDir -Recurse -File\n          if ($files.Count -eq 0) { Write-Error \"\u274c Build failed: 'out' dir empty\"; exit 1 }\n\n          Write-Host \"\u2705 Frontend built: $($files.Count) files.\"\n\n          foreach ($f in $files) {\n            # FIX: Changed TrimStart('\\\\\\\\', '/') to TrimStart('\\\\', '/') to prevent char conversion error\n            $rel = $f.FullName.Substring($outDir.Path.Length).TrimStart('\\','/')\n            $hash = (Get-FileHash $f.FullName -Algorithm SHA256).Hash.Substring(0,16)\n            \"$rel`t$($f.Length)`t$hash\" | Out-File $manifestPath -Encoding utf8 -Append\n          }\n\n      - name: Upload Frontend Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: frontend-build-${{ github.run_id }}\n          path: ${{ env.FRONTEND_BUILD_DIR }}\n          retention-days: 3\n\n      - name: Upload Manifest\n        uses: actions/upload-artifact@v4\n        with:\n          name: frontend-manifest-${{ github.run_id }}\n          path: frontend-manifest.tsv\n          retention-days: 3\n\n  build-backend:\n    name: '\ud83d\udc0d Build Backend'\n    runs-on: windows-latest\n    timeout-minutes: 25\n    needs: [path-finder, repo-preflight, build-frontend, backend-quality]\n    env:\n      BACKEND_REQUIREMENTS_HASH: ${{ needs.repo-preflight.outputs.backend_requirements_hash }}\n      BUILD_VERSION: ${{ needs.repo-preflight.outputs.semver }}\n      BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}\n      BACKEND_MODULE_PATH: ${{ needs.path-finder.outputs.backend_module_path }}\n      BACKEND_SPEC: ${{ needs.path-finder.outputs.spec_file }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Download Frontend Artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: frontend-build-${{ github.run_id }}\n          path: temp-frontend\n\n      - name: Cache Backend Build\n        id: cache-backend\n        uses: actions/cache@v4\n        with:\n          path: dist\n          key: ${{ runner.os }}-backend-build-${{ hashFiles(format('{0}/**', env.BACKEND_DIR), format('{0}', env.BACKEND_SPEC)) }}\n          restore-keys: |\n            ${{ runner.os }}-backend-build-\n\n      - name: Stage Frontend for PyInstaller\n        run: |\n          Set-StrictMode -Version Latest\n          $dest = \"staging/ui\"\n          New-Item -ItemType Directory -Path $dest -Force | Out-Null\n          Copy-Item -Path \"temp-frontend/*\" -Destination $dest -Recurse -Force\n          Write-Host \"\u2705 Frontend staged for inclusion.\"\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          cache: 'pip'\n          cache-dependency-path: |\n            ${{ env.BACKEND_DIR }}/requirements.txt\n            ${{ env.BACKEND_DIR }}/requirements-dev.txt\n\n      - name: Install Dependencies\n        run: |\n          Set-StrictMode -Version Latest\n          python -m pip install --upgrade pip setuptools wheel\n          pip install -r (Join-Path $env:BACKEND_DIR \"requirements.txt\")\n          if (Test-Path (Join-Path $env:BACKEND_DIR \"requirements-dev.txt\")) {\n            pip install -r (Join-Path $env:BACKEND_DIR \"requirements-dev.txt\")\n          }\n\n      - name: Freeze Dependency Snapshot\n        if: steps.cache-backend.outputs.cache-hit != 'true'\n        run: |\n          Set-StrictMode -Version Latest\n          pip freeze | Out-File backend-freeze.txt -Encoding utf8\n\n      - name: Create Dynamic webservice.spec for PyInstaller\n        if: steps.cache-backend.outputs.cache-hit != 'true'\n        shell: python\n        env:\n          BACKEND_DIR: ${{ needs.path-finder.outputs.backend_dir }}\n          BACKEND_MODULE_PATH: ${{ needs.path-finder.outputs.backend_module_path }}\n          FRONTEND_OUT: ${{ env.FRONTEND_DIR }}/out\n        run: |\n          import os\n          from pathlib import Path\n\n          # FIX: Normalize paths to forward slashes to avoid f-string backslash hell\n          bk_dir = os.environ['BACKEND_DIR'].replace('\\\\', '/')\n          mod_path = os.environ['BACKEND_MODULE_PATH']\n          frontend_out = os.environ['FRONTEND_OUT'].replace('\\\\', '/')\n          spec_file = \"jules.spec\" # Hardcode the correct spec file name\n\n          entry = f\"{bk_dir}/main.py\"\n\n          spec = f\"\"\"\n          # -- mode: python ; coding: utf-8 --\n          from PyInstaller.utils.hooks import collect_data_files, collect_submodules\n\n          block_cipher = None\n\n          a = Analysis(\n              ['{entry}'],\n              pathex=[],\n              binaries=[],\n              datas=collect_data_files('uvicorn') + collect_data_files('slowapi') + [('{frontend_out}', 'ui')],\n              hiddenimports=collect_submodules('{mod_path}') + ['win32timezone'],\n              hookspath=[],\n              runtime_hooks=[],\n              excludes=['tests', 'pytest'],\n              win_no_prefer_redirects=False,\n              win_private_assemblies=False,\n              cipher=block_cipher,\n              noarchive=False,\n          )\n          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n          exe = EXE(\n              pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],\n              name='fortuna-backend', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=False\n          )\n          \"\"\"\n          with open(spec_file, \"w\") as f: f.write(spec)\n\n      - name: Create Required Backend Directories\n        if: steps.cache-backend.outputs.cache-hit != 'true'\n        run: |\n          Set-StrictMode -Version Latest\n          New-Item -ItemType Directory -Path (Join-Path $env:BACKEND_DIR \"data\") -Force | Out-Null\n          New-Item -ItemType Directory -Path (Join-Path $env:BACKEND_DIR \"json\") -Force | Out-Null\n          Write-Host \"\u2705 Created required backend directories for PyInstaller.\" -ForegroundColor Green\n\n\n      - name: Build with PyInstaller\n        if: steps.cache-backend.outputs.cache-hit != 'true'\n        env:\n          FORTUNA_VERSION: ${{ needs.repo-preflight.outputs.semver }}\n        run: |\n          Set-StrictMode -Version Latest\n          pyinstaller \"${{ env.BACKEND_SPEC }}\" --clean --log-level=WARN --noconfirm\n\n      - name: Report Cache Status\n        run: |\n          if ('${{ steps.cache-backend.outputs.cache-hit }}' -eq 'true') {\n            Write-Host \"\u2705 Backend build restored from cache.\" -ForegroundColor Green\n          } else {\n            Write-Host \"\u2139\ufe0f No cache hit. A new build was performed.\" -ForegroundColor Yellow\n          }\n\n      - name: Verify Executable\n        run: |\n          Set-StrictMode -Version Latest\n          $exePath = \"dist/fortuna-backend.exe\"\n          if (-not (Test-Path $exePath)) {\n            Write-Host \"\u274c FATAL: Executable not found\" -ForegroundColor Red\n            exit 1\n          }\n          $hash = (Get-FileHash $exePath -Algorithm SHA256).Hash\n          $size = (Get-Item $exePath).Length / 1MB\n          if ($size -lt 10) {\n            Write-Host \"\u274c FATAL: Executable is suspiciously small: $($size) MB. Build may be incomplete.\" -ForegroundColor Red\n            exit 1\n          }\n          \"fortuna-backend.exe`t$hash\" | Out-File backend-sha256.tsv -Encoding utf8\n          Write-Host \"\u2705 Backend ready: $([math]::Round($size, 2)) MB ($hash)\"\n\n      - name: Upload Backend Executable\n        uses: actions/upload-artifact@v4\n        with:\n          name: backend-executable-${{ github.run_id }}\n          path: dist/fortuna-backend.exe\n          retention-days: 3\n\n      - name: Upload Backend Metadata\n        uses: actions/upload-artifact@v4\n        with:\n          name: backend-metadata-${{ github.run_id }}\n          path: |\n            backend-sha256.tsv\n            backend-freeze.txt\n          retention-days: 7\n\n  diagnose-asgi-imports:\n    name: '\ud83d\udd0d ASGI Import Killer Pre-Smoke Diagnostic'\n    runs-on: windows-latest\n    timeout-minutes: 15\n    needs: [path-finder, build-backend]\n    continue-on-error: true\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n      - name: 'Run ASGI Diagnostics'\n        uses: ./.github/actions/run-asgi-diagnostics\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n          backend-dir: ${{ needs.path-finder.outputs.backend_dir }}\n          backend-module-path: ${{ needs.path-finder.outputs.backend_module_path }}\n\n  diagnose-runtime:\n    name: '\ud83d\udd0e Diagnose PyInstaller Runtime'\n    runs-on: windows-latest\n    timeout-minutes: 10\n    needs: [path-finder, build-backend]\n    continue-on-error: true\n    env:\n      BACKEND_MODULE_PATH: ${{ needs.path-finder.outputs.backend_module_path }}\n    steps:\n      - name: \ud83d\udce5 Download Backend Executable\n        uses: actions/download-artifact@v4\n        with:\n          name: backend-executable-${{ github.run_id }}\n          path: dist\n\n      - name: \ud83d\udc0d Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: \ud83d\udce6 Install PyInstaller\n        run: pip install pyinstaller==6.6.0\n\n      - name: \ud83d\udd75\ufe0f Extract and Analyze Executable Contents\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $exePath = \"dist/fortuna-backend.exe\"\n\n          Write-Host \"--- Executable Analysis ---\"\n          Write-Host \"Analyzing contents of $exePath with pyi-archive_viewer...\"\n\n          $archiveContents = pyi-archive_viewer $exePath\n          if ($LASTEXITCODE -ne 0) {\n            Write-Error \"Failed to analyze executable with pyi-archive_viewer.\"\n            exit 1\n          }\n\n          Write-Host \"\\n--- Archive Contents ---\"\n          $archiveContents | Out-Host\n\n          # FIX: Normalize slashes for comparison\n          $expectedInitFile = ($env:BACKEND_MODULE_PATH.Replace('.', '/') + '/__init__.py')\n\n          # Check for the file, replacing backslashes with forward slashes in the output\n          $found = $archiveContents | ForEach-Object { $_.Replace('\\', '/') } | Select-String -Pattern $expectedInitFile -SimpleMatch -Quiet\n\n          if ($found) {\n            Write-Host \"\u2705 SUCCESS: Key module file found inside the executable archive.\" -ForegroundColor Green\n          } else {\n            Write-Error \"\u274c FAILURE: Key module file '$expectedInitFile' NOT found inside the executable.\"\n            exit 1\n          }\n\n      - name: \ud83d\udce4 Upload Extracted Artifacts\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: extracted-executable-${{ github.run_id }}\n          path: extracted_exe/\n          retention-days: 7\n\n  smoke-test:\n    name: '\ud83d\udd2c Smoke Test (Triple-Loop Synthesis)'\n    runs-on: windows-latest\n    timeout-minutes: 20\n    needs:\n      - build-backend\n      - package-msi-service # Run after packaging is complete\n    steps:\n      - name: \ud83d\udce5 Download MSI Installer\n        uses: actions/download-artifact@v4\n        with:\n          name: fortuna-service-msi-${{ github.run_id }}\n          path: msi-installer\n\n      - name: \ud83d\udd75\ufe0f Find MSI Installer\n        id: find_msi\n        shell: pwsh\n        run: |\n          $msi = Get-ChildItem -Path \"msi-installer\" -Filter \"*.msi\" -Recurse | Select-Object -First 1\n          if (-not $msi) {\n            Write-Error \"\u274c No MSI found in the artifact!\"\n            Get-ChildItem -Path \"msi-installer\" -Recurse | Write-Host\n            exit 1\n          }\n          Write-Host \"\u2705 Found MSI: $($msi.FullName)\"\n          \"msi_path=$($msi.FullName)\" | Out-File -FilePath $env:GITHUB_OUTPUT -Append\n\n      - name: \ud83d\udee1\ufe0f Grant Full Control to SYSTEM for Temp Directory\n        shell: pwsh\n        run: |\n          $tempPath = $env:TEMP\n          Write-Host \"Granting SYSTEM FullControl on $tempPath\"\n          icacls $tempPath /grant \"NT AUTHORITY\\SYSTEM:(OI)(CI)F\" /T\n          if ($LASTEXITCODE -ne 0) {\n            Write-Warning \"icacls command failed, but continuing...\"\n          } else {\n            Write-Host \"\u2705 Privileges granted successfully.\"\n          }\n\n      - name: Create Runtime Directories\n        shell: pwsh\n        run: |\n          $installDir = \"C:\\Program Files\\Fortuna Faucet Service\"\n          New-Item -ItemType Directory -Path \"$installDir\\data\" -Force\n          New-Item -ItemType Directory -Path \"$installDir\\json\" -Force\n          New-Item -ItemType Directory -Path \"$installDir\\logs\" -Force\n          Write-Host \"\u2705 Ensured runtime directories exist in $installDir\"\n\n      - name: '\ud83d\ude80 LOOP 1 - Install & Verify Service Registration'\n        shell: pwsh\n        run: |\n          if (Get-Service -Name FortunaWebService -ErrorAction SilentlyContinue) {\n            sc.exe stop FortunaWebService 2>&1 | Out-Null\n            sc.exe delete FortunaWebService 2>&1 | Out-Null\n          }\n\n          $msiPath = \"${{ steps.find_msi.outputs.msi_path }}\"\n          Write-Host \"Starting installation of $msiPath...\"\n\n          $proc = Start-Process msiexec.exe -ArgumentList \"/i `\"$msiPath`\" /qn /L*v msi-install.log\" -Wait -PassThru\n\n          # Allow exit code 3010 (reboot required)\n          if ($proc.ExitCode -ne 0 -and $proc.ExitCode -ne 3010) {\n            Write-Error \"\u274c MSI installation failed with exit code $($proc.ExitCode).\"\n            exit 1\n          }\n\n          Write-Host \"\u2705 Installation completed (Exit Code: $($proc.ExitCode)). Verifying service registration...\"\n\n          $service = Get-Service -Name \"FortunaWebService\" -ErrorAction SilentlyContinue\n          if (-not $service) {\n            Write-Error \"\u274c FATAL: Service 'FortunaWebService' was not registered.\"\n            exit 1\n          }\n\n          Write-Host \"\u2705 Service is registered. State: $($service.Status)\"\n\n      - name: Emit MSI log tail\n        if: always()\n        shell: pwsh\n        run: |\n          if (Test-Path msi-install.log) {\n            Write-Host \"`n=== msi-install.log (last 200 lines) ===\"\n            Get-Content msi-install.log -Tail 200\n          } else {\n            Write-Host \"No msi-install.log found\"\n          }\n\n      - name: \ud83d\ude80 Active Port Poll\n        shell: pwsh\n        run: |\n          $start = Get-Date\n          while ((Get-Date) - $start -lt (New-TimeSpan -Seconds 30)) {\n            if (Test-NetConnection -ComputerName localhost -Port 8102 -InformationLevel Quiet) {\n              Write-Host \"\u2705 Service is listening.\"\n              return\n            }\n            Start-Sleep 1\n          }\n          throw \"\u274c Service failed to bind port 8102 within 30 seconds.\"\n\n      - name: Test Service Health (Smoke Test)\n        shell: pwsh\n        run: |\n          $maxAttempts = 10\n          $healthUrl = \"http://localhost:8102/health\"\n          for ($i = 1; $i -le $maxAttempts; $i++) {\n            try {\n              # FIX: Use ${maxAttempts} to prevent colon parsing error\n              Write-Host \"Attempt $i/${maxAttempts}: Pinging $healthUrl...\"\n              $response = Invoke-WebRequest -Uri $healthUrl -Method Get -UseBasicParsing -ErrorAction Stop\n              if ($response.StatusCode -eq 200) {\n                Write-Host \"\u2705 Service is Healthy on Port 8102\"\n                exit 0\n              }\n            } catch {\n              Write-Host \"\u23f3 Waiting for service...\"\n              Start-Sleep -Seconds 5\n            }\n          }\n          Write-Error \"\u274c Service Failed Health Check after $maxAttempts attempts\"\n          exit 1\n\n      - name: '\ud83d\udcf8 The Paparazzi (Visual Proof)'\n        shell: pwsh\n        run: |\n          Write-Host \"Installing Playwright (Node.js)...\"\n          npm install playwright\n          npx playwright install chromium --with-deps\n          \n          $url = \"http://127.0.0.1:${{ env.SERVICE_PORT }}/health\"\n          node -e \"\n            const { chromium } = require('playwright');\n            (async () => {\n              try {\n                const browser = await chromium.launch();\n                const page = await browser.newPage();\n                await page.goto('$url', { timeout: 15000 });\n                await page.screenshot({ path: 'proof-of-life.png', fullPage: true });\n                await browser.close();\n              } catch (e) { process.exit(1); }\n            })();\n          \"\n\n      - name: \ud83d\udce4 Upload Visual Proof\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: visual-proof-${{ github.run_id }}\n          path: proof-of-life.png\n          retention-days: 7\n\n      - name: \ud83d\udcca Capture Diagnostics on Failure\n        if: failure()\n        shell: pwsh\n        run: |\n          $diag = Join-Path $PWD \"installer-diag\"\n          Remove-Item $diag -Recurse -Force -ErrorAction SilentlyContinue\n          New-Item -ItemType Directory -Path $diag | Out-Null\n          Copy-Item -Path msi-install.log -Destination $diag -Force\n          Copy-Item -Path \"C:\\ProgramData\\Fortuna\\logs\\*.log\" -Destination $diag -Force -ErrorAction SilentlyContinue\n          Copy-Item -Path \"C:\\Program Files\\Fortuna Faucet\\*\" -Destination $diag -Recurse -Force -ErrorAction SilentlyContinue\n\n      - name: \ud83d\udce4 Upload Diagnostics\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: jules-smoke-test-failure-${{ github.run_id }}\n          path: installer-diag\n          retention-days: 30\n\n      - name: \"\ud83d\udc80 CSI: Windows (Post-Mortem Diagnostics)\"\n        if: failure()\n        shell: pwsh\n        run: |\n          Write-Host \"=== 1. PROCESS STATE ===\"\n          Get-Process | Where-Object { $_.ProcessName -match \"fortuna|python\" } | Format-Table -AutoSize\n\n          Write-Host \"=== 2. NETWORK PORTS (${{ env.SERVICE_PORT }}) ===\"\n          netstat -anb | Select-String \"${{ env.SERVICE_PORT }}\" -Context 2,2\n\n          Write-Host \"=== 3. WINDOWS EVENT LOGS (Last 50 Errors) ===\"\n          Get-EventLog -LogName Application -EntryType Error,Warning -Newest 50 | Format-Table TimeGenerated, Source, Message -AutoSize -Wrap\n\n          Write-Host \"=== 4. MSI INSTALL LOG (Last 200 lines) ===\"\n          if (Test-Path \"msi-install.log\") { Get-Content \"msi-install.log\" -Tail 200 }\n      - name: \ud83e\uddf9 Cleanup\n        if: always()\n        shell: pwsh\n        run: |\n          Write-Host \"Cleaning up...\"\n          Stop-Service -Name \"FortunaWebService\" -Force -ErrorAction SilentlyContinue\n          # Uninstall may not always work, especially if the service is stuck, but we try.\n          $msiPath = \"${{ steps.find_msi.outputs.msi_path }}\"\n          if (Test-Path $msiPath) {\n            Start-Process msiexec.exe -ArgumentList \"/x `\"$msiPath`\" /qn\" -Wait\n          }\n          Get-Process -Name \"fortuna-webservice\" -ErrorAction SilentlyContinue | Stop-Process -Force\n          Write-Host \"\u2705 Cleanup complete.\"\n\n\n  package-msi-service:\n    name: '\ud83d\udcbf Package Service MSI'\n    runs-on: windows-latest\n    timeout-minutes: 25\n    needs: [path-finder, repo-preflight, build-backend]\n    env:\n      WIX_HASH: ${{ needs.repo-preflight.outputs.wix_definition_hash }}\n      BUILD_VERSION: ${{ needs.repo-preflight.outputs.semver }}\n      SHORT_SHA: ${{ needs.repo-preflight.outputs.short_sha }}\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Download Backend\n        uses: actions/download-artifact@v4\n        with:\n          name: backend-executable-${{ github.run_id }}\n          path: dist\n\n      - name: Stage Artifacts\n        id: stage\n        run: |\n          Set-StrictMode -Version Latest\n          $staging = \"${{ env.MSI_STAGING_DIR }}\"\n          New-Item -ItemType Directory -Path $staging -Force | Out-Null\n          # Rename the executable to match the service name defined in the WiX project\n          Move-Item -Path \"dist/fortuna-backend.exe\" -Destination \"$staging/fortuna-webservice.exe\" -Force\n          $msiName = \"Fortuna-WebService-${{ env.BUILD_VERSION }}-${{ env.SHORT_SHA }}.msi\".Replace('/', '-')\n          \"msi_name=$msiName\" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append\n          Write-Host \"\u2705 Staged for MSI: $msiName\"\n\n      - name: Create Restart Service Batch Script\n        shell: pwsh\n        run: |\n          $scriptContent = @\"\n          @echo off\n          echo Requesting Admin privileges to restart FortunaWebService...\n          net stop FortunaWebService\n          net start FortunaWebService\n          echo Service Restarted.\n          pause\n          \"@\n          Set-Content -Path \"${{ env.MSI_STAGING_DIR }}/restart_service.bat\" -Value $scriptContent -Encoding Ascii\n          Write-Host \"\u2705 Created restart_service.bat script.\"\n\n      - name: Setup .NET SDK\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ env.DOTNET_VERSION }}\n\n      - name: Cache NuGet\n        uses: actions/cache@v4\n        with:\n          path: ~/.nuget/packages\n          key: ${{ runner.os }}-nuget-${{ env.WIX_HASH }}\n\n      - name: \ud83d\udcc4 Ensure WiX License Exists\n        run: |\n          if (-not (Test-Path build_wix)) { New-Item -ItemType Directory -Path build_wix | Out-Null }\n          $licensePath = 'build_wix/license.rtf'\n          if (-not (Test-Path $licensePath)) {\n            Write-Host '\u26a0\ufe0f License file missing. Generating placeholder...'\n            $rtfContent = '{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0 Arial;}}\\f0\\fs24 END USER LICENSE AGREEMENT\\par\\par This is a placeholder license for Fortuna Faucet. Please replace with actual terms.}'\n            Set-Content -Path $licensePath -Value $rtfContent -Encoding Ascii\n            Write-Host '\u2705 Placeholder license.rtf created.'\n          } else {\n            Write-Host '\u2705 Existing license.rtf found.'\n          }\n      - name: Prepare WiX Project\n        run: |\n          Set-StrictMode -Version Latest\n          Copy-Item \"${{ env.WIX_DIR }}/Product_WithService.wxs\" \"${{ env.WIX_DIR }}/Product.wxs\" -Force\n\n          $proj = @(\n            '<Project Sdk=\"WixToolset.Sdk/${{ env.WIX_VERSION }}\">',\n            '  <PropertyGroup>',\n            '    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>',\n            '    <OutputType>Package</OutputType>',\n            '    <Platforms>x64</Platforms>',\n            '    <DefineConstants>Version=$(Version);SourceDir=$(SourceDir);ServicePort=$(ServicePort)</DefineConstants>',\n            '  </PropertyGroup>',\n            '  <ItemGroup>',\n            '    <PackageReference Include=\"WixToolset.UI.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '    <PackageReference Include=\"WixToolset.Firewall.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '    <PackageReference Include=\"WixToolset.Util.wixext\" Version=\"${{ env.WIX_VERSION }}\" />',\n            '  </ItemGroup>',\n            '  <ItemGroup>',\n            '    <Compile Include=\"Product.wxs\" />',\n            '  </ItemGroup>',\n            '</Project>'\n          )\n          Set-Content \"${{ env.WIX_DIR }}/Fortuna.wixproj\" -Value ($proj -join \"`r`n\") -Encoding utf8\n\n      - name: \ud83d\udd2c Forensic Packaging Analysis\n        shell: pwsh\n        run: |\n          Write-Host \"=== STAGING DIRECTORY MANIFEST ===\"\n          Get-ChildItem -Path \"${{ env.MSI_STAGING_DIR }}\" -Recurse | Sort-Object Length | Format-Table FullName, Length, LastWriteTime -AutoSize\n\n          Write-Host \"=== CRITICAL FILE CHECK ===\"\n          $critical = @(\"fortuna-webservice.exe\", \"restart_service.bat\")\n          foreach ($file in $critical) {\n            $found = Get-ChildItem -Path \"${{ env.MSI_STAGING_DIR }}\" -Recurse -Filter $file\n            if ($found) { Write-Host \"\u2705 FOUND: $file\" -ForegroundColor Green }\n            else { Write-Host \"\u274c MISSING: $file\" -ForegroundColor Red }\n          }\n      - name: Build MSI\n        working-directory: ${{ env.WIX_DIR }}\n        run: |\n          Set-StrictMode -Version Latest\n          dotnet build Fortuna.wixproj -c Release `\n            -p:Platform=x64 `\n            -p:SourceDir=\"../${{ env.MSI_STAGING_DIR }}\" `\n            -p:Version=\"${{ env.BUILD_VERSION }}\" `\n            -p:ServicePort=\"${{ env.SERVICE_PORT }}\"\n          $msiFile = \"bin/x64/Release/${{ steps.stage.outputs.msi_name }}\"\n          if (-not (Test-Path $msiFile)) { throw \"MSI not created\" }\n          $hash = (Get-FileHash $msiFile -Algorithm SHA256).Hash\n          $hash | Out-File \"$msiFile.sha256\" -Encoding utf8\n          Write-Host \"\u2705 MSI Built: $hash\"\n\n      - name: '\ud83d\udc24 The Canary (Malware Pre-Flight)'\n        shell: pwsh\n        continue-on-error: true\n        run: |\n          $msi = Get-ChildItem -Recurse -Filter \"*.msi\" | Select-Object -First 1\n          if (!$msi) { Write-Warning \"No MSI found to scan.\"; exit 0 }\n\n          Write-Host \"\ud83d\udd0d Scanning $($msi.Name) with Windows Defender...\"\n          $defender = \"C:\\Program Files\\Windows Defender\\MpCmdRun.exe\"\n\n          if (-not (Test-Path $defender)) {\n              Write-Warning \"Windows Defender CLI not found at expected path.\"\n              exit 0\n          }\n\n          # ScanType 3 = File/Custom Scan\n          $proc = Start-Process -FilePath $defender -ArgumentList \"-Scan -ScanType 3 -File `\"$($msi.FullName)`\"\" -Wait -PassThru -NoNewWindow\n\n          if ($proc.ExitCode -eq 0) {\n              Write-Host \"\u2705 CLEAN: Windows Defender found no threats.\" -ForegroundColor Green\n          } elseif ($proc.ExitCode -eq 2) {\n              Write-Error \"\ud83d\udea8 THREAT DETECTED: Windows Defender flagged this installer!\"\n              exit 1\n          } else {\n              Write-Warning \"\u26a0\ufe0f Scan completed with inconclusive exit code: $($proc.ExitCode)\"\n          }\n\n      - name: Upload MSI + Hash\n        uses: actions/upload-artifact@v4\n        with:\n          name: fortuna-service-msi-${{ github.run_id }}\n          path: ${{ env.WIX_DIR }}/bin/x64/Release/*\n          retention-days: 10\n\n  create-release:\n    name: '\ud83d\ude80 Create Release'\n    runs-on: ubuntu-latest\n    if: startsWith(github.ref, 'refs/tags/')\n    needs: package-msi-service\n    permissions:\n      contents: write\n    steps:\n      - name: Download MSI\n        uses: actions/download-artifact@v4\n        with:\n          pattern: fortuna-service-msi-*\n          merge-multiple: true\n          path: assets\n\n      - name: Download SBOM\n        uses: actions/download-artifact@v4\n        with:\n          name: sbom-${{ github.run_id }}\n          path: assets\n\n      - name: Generate Checksums\n        run: |\n          cd assets\n          ls *.msi\n          sha256sum *.msi > SHASUMS256.txt\n\n      - name: Publish Release\n        uses: softprops/action-gh-release@v2\n        with:\n          files: |\n            assets/*.msi\n            assets/*.sha256\n            assets/SHASUMS256.txt\n            assets/sbom.spdx.json\n          generate_release_notes: true\n\n  stage-release-artifacts:\n    name: '\ud83d\udce6 Stage Release Artifacts'\n    runs-on: windows-latest\n    timeout-minutes: 5\n    needs: [package-msi-service, repo-preflight]\n    steps:\n      - name: \ud83d\udce5 Download MSI Installer\n        uses: actions/download-artifact@v4\n        with:\n          name: fortuna-service-msi-${{ github.run_id }}\n          path: msi-installer\n      - name: \ud83d\ude9a Stage Final Artifact\n        shell: pwsh\n        run: |\n          Set-StrictMode -Version Latest\n          $sourceDir = \"msi-installer\"\n          $destDir = \"final-release-artifact\"\n          New-Item -ItemType Directory -Path $destDir -Force | Out-Null\n\n          robocopy $sourceDir $destDir /E\n\n          if ($LASTEXITCODE -ge 8) {\n            Write-Error \"Robocopy failed with exit code $LASTEXITCODE. This indicates a serious error.\"\n            exit 1\n          }\n\n          Write-Host \"\u2705 Robocopy completed successfully.\"\n          Get-ChildItem -Path $destDir | Write-Host\n          exit 0\n\n      - name: \ud83d\udce4 Upload Final MSI Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: Final-MSI-Artifact\n          path: final-release-artifact/\n          retention-days: 90\n",
    ".github/workflows/codeql.yml": "name: \"CodeQL\"\n\non:\n  push:\n    branches: [\"main\"]\n  pull_request:\n    branches: [\"main\"]\n  schedule:\n    - cron: '40 7 * * 4'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['javascript', 'python' ]\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v4\n\n    - name: Setup Python\n      if: matrix.language == 'python'\n      uses: actions/setup-python@v5\n      with:\n        python-version: '3.11'\n\n    - name: Setup Node.js\n      if: matrix.language == 'javascript'\n      uses: actions/setup-node@v4\n      with:\n        node-version: '20'\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v3\n      with:\n        languages: ${{ matrix.language }}\n\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v3\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v3\n",
    "PSEUDOCODE.MD": "# \ud83d\udc0e Fortuna Faucet - Complete Pseudocode Blueprint\n\n**Status:** Comprehensive System Specification (Revised & Corrected)\n**Version:** 2.2.0\n**Last Updated:** November 7, 2025\n\n---\n\n## TABLE OF CONTENTS\n\n1.  System Overview\n2.  Architecture Pillars\n3.  Backend Engine (Python) - Detailed\n4.  Frontend Interface (TypeScript/React) - Detailed\n5.  Electron Wrapper & Windows Integration - Detailed\n6.  Data Models & API Specification\n7.  Deployment & Automation (CI/CD)\n8.  End-to-End Workflows\n\n---\n\n## 1. SYSTEM OVERVIEW\n\n```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551         FORTUNA FAUCET - Racing Analysis Platform             \u2551\n\u2551  Unifying global horse/greyhound/harness racing intelligence   \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nMISSION:\n  \u2022 Acquire race data from 20+ global sources (APIs + web scraping).\n  \u2022 Normalize and deduplicate data into a canonical Race format.\n  \u2022 Apply analytical filters to surface high-value betting opportunities.\n  \u2022 Serve results via a secure, local REST API to an interactive dashboard.\n  \u2022 Operate as a professional, standalone, native Windows application.\n\nCORE TENETS:\n  \u2022 UI-First Experience: The user interface is always responsive, even during backend startup or restarts.\n  \u2022 Resilient Process Management: The backend executable's lifecycle is robustly managed, with timeouts and crash detection.\n  \u2022 Asynchronous Initialization: The backend server starts instantly, deferring heavy, blocking I/O to background threads.\n  \u2022 Secure by Design: Communication between the frontend and the privileged main process is secured via a context-aware preload script.\n  \u2022 Automated & Repeatable Builds: The entire application is built, tested, and packaged via a deterministic CI/CD pipeline.\n\nSTAKEHOLDERS:\n  \u2022 End User: Receives a professional MSI installer for a one-click, dependency-free launch.\n  \u2022 Developer: Works with clean, separated Python and TypeScript stacks, governed by this specification.\n```\n\n---\n\n## 2. ARCHITECTURE PILLARS\n\n### Pillar 1: Backend Engine (Python)\n\n```\nPYTHON_BACKEND:\n  \u251c\u2500 main.py\n  \u2502  \u2514\u2500 Entry point for PyInstaller executable; starts the Uvicorn server.\n  \u2502\n  \u251c\u2500 api.py\n  \u2502  \u2514\u2500 FastAPI application definition.\n  \u2502     \u251c\u2500 Lifespan Hook: Manages async startup/shutdown logic.\n  \u2502     \u251c\u2500 API Routes: /health, /api/status, /api/races, etc.\n  \u2502     \u2514\u2500 Dependency Injection: Provides engine and security dependencies.\n  \u2502\n  \u251c\u2500 engine.py\n  \u2502  \u2514\u2500 OddsEngine: Orchestrates all data fetching and processing.\n  \u2502\n  \u251c\u2500 adapters/\n  \u2502  \u251c\u2500 base_v3.py (Abstract Base Class for all data sources)\n  \u2502  \u2514\u2500 [20+ specific adapter implementations]\n  \u2502\n  \u251c\u2500 config.py\n  \u2502  \u2514\u2500 Pydantic settings management from .env file.\n  \u2502\n  \u2514\u2500 requirements.txt\n     \u2514\u2500 Clean, de-duplicated, and conflict-free list of all Python dependencies.\n```\n\n### Pillar 2: Frontend Interface (TypeScript/React)\n\n```\nFRONTEND:\n  \u251c\u2500 next.config.mjs\n  \u2502  \u2514\u2500 Next.js config with `output: 'export'` for 100% static generation.\n  \u2502\n  \u251c\u2500 app/page.tsx\n  \u2502  \u2514\u2500 Main application shell.\n  \u2502\n  \u251c\u2500 src/components/\n  \u2502  \u251c\u2500 LiveRaceDashboard.tsx (Main stateful component)\n  \u2502  \u2502  \u251c\u2500 Manages connection state ('connecting', 'online', 'error').\n  \u2502  \u2502  \u251c\u2500 Polls Electron main process for backend status via secure IPC.\n  \u2502  \u2502  \u2514\u2500 Fetches data from the local Python API when online.\n  \u2502  \u2502\n  \u2502  \u251c\u2500 RaceCard.tsx (Displays a single race)\n  \u2502  \u2514\u2500 StatusIndicator.tsx (Shows backend connection status)\n  \u2502\n  \u2514\u2500 src/types/\n     \u2514\u2500 racing.ts (TypeScript interfaces matching backend Pydantic models)\n```\n\n### Pillar 3: Electron Wrapper & Windows Integration\n\n```\nELECTRON_WRAPPER:\n  \u251c\u2500 main.js (Electron main process)\n  \u2502  \u251c\u2500 Creates the BrowserWindow and loads the static frontend.\n  \u2502  \u251c\u2500 Implements robust lifecycle management for the backend executable.\n  \u2502  \u251c\u2500 Provides secure IPC handlers for status checks and restarts.\n  \u2502  \u2514\u2500 Creates a system tray icon for background operation.\n  \u2502\n  \u251c\u2500 preload.js (Secure IPC Bridge)\n  \u2502  \u2514\u2500 Uses `contextBridge` to safely expose specific functions to the frontend.\n  \u2502\n  \u251c\u2500 package.json\n  \u2502  \u2514\u2500 Defines Node.js dependencies and build scripts.\n  \u2502\n  \u251c\u2500 electron-builder-config.yml\n  \u2502  \u2514\u2500 Defines the configuration for creating the final MSI installer.\n  \u2502\n  \u2514\u2500 .github/workflows/build-msi.yml\n     \u2514\u2500 GitHub Actions pipeline that automates the entire build, test, and package process.\n```\n\n---\n\n## 3. BACKEND ENGINE (PYTHON) - DETAILED\n\n### 3.1 Entry Point & Server Startup (`main.py`)\n\n```pseudocode\n// This is the script executed by fortuna-backend.exe\n\nPROCEDURE Main_Python_Entry_Point\n  // Guard required for PyInstaller and multiprocessing on Windows\n  IF this script is the main entry point:\n    CALL multiprocessing.freeze_support()\n\n    // Programmatically launch the FastAPI application using Uvicorn\n    // This call blocks and runs the server until the process is terminated\n    CALL uvicorn.run(\n      app=\"python_service.api:app\",\n      host=\"0.0.0.0\",\n      port=8000\n    )\nEND PROCEDURE\n```\n\n### 3.2 Asynchronous Application Lifecycle (`api.py`)\n\n```pseudocode\n// --- Lifespan Management (The key to a non-blocking startup) ---\nASYNC FUNCTION lifespan_manager(app: FastAPI):\n  // === ON STARTUP ===\n  LOG \"Uvicorn server is online. Starting lifespan initialization.\"\n\n  // 1. Perform immediate, non-blocking tasks\n  CONNECT to Redis cache\n\n  // 2. Defer slow, blocking tasks to a background thread\n  //    This allows the server to start accepting requests instantly.\n  SCHEDULE function \"initialize_heavy_resources(app)\" to run in a ThreadPoolExecutor\n\n  LOG \"Heavy resource initialization scheduled. Server is now responsive.\"\n\n  // 3. Yield control back to Uvicorn. The server is now live.\n  YIELD\n\n  // === ON SHUTDOWN ===\n  LOG \"Shutdown signal received.\"\n  AWAIT app.state.engine.close() // Gracefully close HTTP client connections\n  DISCONNECT from Redis\n  SHUTDOWN ThreadPoolExecutor\n\n// --- Heavy Initialization (Runs in Background) ---\nFUNCTION initialize_heavy_resources(app: FastAPI):\n  TRY\n    LOG \"Background initialization of OddsEngine has started.\"\n    settings <- get_settings_from_config()\n    engine <- create new OddsEngine(config=settings)\n    // This part is slow: it loads all ~25 adapters\n    app.state.engine <- engine\n    LOG \"Background initialization complete. OddsEngine is now available.\"\n  CATCH Exception as e:\n    LOG_CRITICAL \"Failed to initialize OddsEngine in the background.\", error=e\n    app.state.engine <- null // Ensure the app knows initialization failed\n```\n\n### 3.3 Engine Orchestration (`engine.py`)\n\n```pseudocode\nCLASS OddsEngine:\n  INIT(config):\n    self.config <- config\n    self.adapters <- [List of all adapter instances]\n    self.http_client <- httpx.AsyncClient(...)\n    self.semaphore <- asyncio.Semaphore(config.MAX_CONCURRENT_REQUESTS)\n\n    // Inject the shared, persistent HTTP client into each adapter\n    FOR adapter IN self.adapters:\n      adapter.http_client <- self.http_client\n\n  @cache_async_result(ttl_seconds=300)\n  ASYNC FUNCTION fetch_all_odds(date_str):\n    // Create a list of concurrent fetching tasks, wrapped in the semaphore\n    tasks <- [self._fetch_with_semaphore(adapter, date_str) FOR adapter in self.adapters]\n    results <- AWAIT asyncio.gather(*tasks, return_exceptions=True)\n\n    // Process results, separating successes from failures\n    all_races <- []\n    FOR result IN results:\n      IF result is a success:\n        all_races.extend(result.races)\n\n    // Deduplicate and merge races from different sources\n    deduped_races <- self._dedupe_races(all_races)\n\n    RETURN AggregatedResponse(races=deduped_races, source_statuses=...)\n```\n\n---\n\n## 4. FRONTEND INTERFACE (TYPESCRIPT/REACT) - DETAILED\n\n### 4.1 LiveRaceDashboard Component\n\n```pseudocode\nCOMPONENT LiveRaceDashboard (client-side):\n\n  STATE:\n    races: Race[] <- []\n    backendStatus: 'connecting' | 'online' | 'error' <- 'connecting'\n    lastLogs: string[] <- []\n\n  EFFECT on mount:\n    // Use the secure API exposed by preload.js\n    IF window.electronAPI exists:\n      // Set up a listener for status updates from the main process\n      window.electronAPI.onBackendStatus((update) => {\n        setBackendStatus(update.state)\n        setLastLogs(update.logs)\n      })\n\n    // Immediately request the current status\n    window.electronAPI.getBackendStatus().then((status) => {\n      setBackendStatus(status.state)\n      setLastLogs(status.logs)\n    })\n\n    // Set up a polling interval to keep status fresh\n    interval <- setInterval(() => {\n      window.electronAPI.getBackendStatus().then((status) => {\n        setBackendStatus(status.state)\n        setLastLogs(status.logs)\n      })\n    }, 3000) // Poll every 3 seconds\n\n    CLEANUP: clearInterval(interval)\n\n  EFFECT when backendStatus changes to 'online':\n    // Trigger data fetch only when the backend is confirmed to be running\n    fetchQualifiedRaces()\n\n  ASYNC FUNCTION fetchQualifiedRaces():\n    TRY:\n      // Make a standard HTTP call to the local Python server\n      response <- AWAIT fetch(\"http://127.0.0.1:8000/api/races/qualified/trifecta\")\n      IF NOT response.ok:\n        RAISE new Error(`API returned status ${response.status}`)\n\n      data <- AWAIT response.json()\n      setRaces(data.races)\n\n    CATCH e:\n      // If the API call fails, update the status\n      setBackendStatus('error')\n      setLastLogs([...lastLogs, `API Fetch Error: ${e.message}`])\n\n  FUNCTION RENDER:\n    <div className=\"dashboard\">\n      <StatusIndicator status={backendStatus} />\n      <RaceFilters />\n\n      IF backendStatus === 'error':\n        <ErrorDisplay logs={lastLogs} />\n      ELSE IF backendStatus === 'connecting':\n        <LoadingSkeleton />\n      ELSE IF races.length === 0:\n        <EmptyState message=\"No races matched your filters.\" />\n      ELSE:\n        <RaceGrid races={races} />\n    </div>\n```\n\n---\n\n## 5. ELECTRON WRAPPER & WINDOWS INTEGRATION - DETAILED\n\n### 5.1 Main Process (`main.js`) - With Robust Lifecycle Management\n\n```pseudocode\nCLASS FortunaDesktopApp:\n  INIT():\n    self.mainWindow <- null\n    self.backendState <- 'stopped'\n    self.backendLogs <- []\n    self.backendProcess <- null\n\n  FUNCTION createMainWindow():\n    // ... create BrowserWindow, load static frontend ...\n\n  FUNCTION startBackend():\n    IF self.backendProcess is not null:\n      self.backendProcess.kill()\n\n    self.backendState <- 'starting'\n    self.backendLogs <- ['Attempting to start backend...']\n    self.sendBackendStatusUpdate() // Notify UI\n\n    // Get path to the packaged executable\n    exePath <- path.join(process.resourcesPath, 'fortuna-backend', 'fortuna-backend.exe')\n\n    IF file at exePath does NOT exist:\n      self.backendState <- 'error'\n      self.backendLogs.push(`FATAL: Executable not found at ${exePath}`)\n      self.sendBackendStatusUpdate()\n      dialog.showErrorBox(\"Critical Error\", \"Backend is missing. Please reinstall.\")\n      RETURN\n\n    // Spawn the process\n    self.backendProcess <- spawn(exePath, [], { stdio: ['ignore', 'pipe', 'pipe'] })\n\n    // --- CRITICAL: Resiliency Logic ---\n    startupTimeout <- setTimeout(() => {\n      IF self.backendState === 'starting':\n        self.backendState <- 'error'\n        self.backendLogs.push('Error: Backend startup timed out after 30 seconds.')\n        self.backendProcess.kill()\n        self.sendBackendStatusUpdate()\n    }, 30000) // 30-second timeout\n\n    self.backendProcess.stdout.on('data', (data) => {\n      self.backendLogs.push(data.toString())\n      // A more robust check would be a successful health check poll\n      IF data.toString().includes(\"Uvicorn running\"):\n        self.backendState <- 'online'\n        clearTimeout(startupTimeout)\n        self.sendBackendStatusUpdate()\n    })\n\n    self.backendProcess.stderr.on('data', (data) => {\n      self.backendLogs.push(`[STDERR] ${data.toString()}`)\n    })\n\n    self.backendProcess.on('exit', (code) => {\n      clearTimeout(startupTimeout)\n      IF self.backendState is not 'error': // Avoid duplicate error messages\n        self.backendState <- 'error'\n        self.backendLogs.push(`Backend process exited unexpectedly with code: ${code}`)\n        self.sendBackendStatusUpdate()\n    })\n\n  FUNCTION sendBackendStatusUpdate():\n    // Send the latest status to the frontend renderer process\n    IF self.mainWindow is not null:\n      self.mainWindow.webContents.send('backend-status-update', {\n        state: self.backendState,\n        logs: self.backendLogs.slice(-20) // Send last 20 log lines\n      })\n\n// --- IPC Handlers (Securely Defined) ---\nipcMain.handle('get-backend-status', (event) => {\n  // SECURITY: Ensure the request is from our main window\n  IF event.sender is NOT self.mainWindow.webContents:\n    RETURN null\n\n  RETURN { state: self.backendState, logs: self.backendLogs.slice(-20) }\n})\n\nipcMain.on('restart-backend', (event) => {\n  // SECURITY: Ensure the request is from our main window\n  IF event.sender is NOT self.mainWindow.webContents:\n    RETURN\n\n  self.startBackend()\n})\n```\n\n### 5.2 Preload Script (`preload.js`)\n\n```pseudocode\n// Expose a limited, secure API to the frontend renderer process\ncontextBridge.exposeInMainWorld('electronAPI', {\n  getBackendStatus: () => ipcRenderer.invoke('get-backend-status'),\n  restartBackend: () => ipcRenderer.send('restart-backend'),\n  onBackendStatus: (callback) => ipcRenderer.on('backend-status-update', (_event, value) => callback(value))\n})\n```\n\n---\n\n## 6. DATA MODELS & API SPECIFICATION\n\n### 6.1 Core Data Models (Pydantic/TypeScript)\n\n```\nMODEL Race:\n  id: str (unique identifier, e.g., \"Betfair_USA_Aqueduct_2025-11-07_R1\")\n  venue: str\n  race_number: int\n  start_time: datetime\n  runners: List[Runner]\n  source: str\n\nMODEL Runner:\n  name: str\n  odds: Optional[float]\n```\n\n### 6.2 Primary API Endpoints\n\n```\nENDPOINT GET /health\n  Description: Simple health check, requires no authentication.\n  Response (200 OK): {\"status\": \"ok\"}\n\nENDPOINT GET /api/races/qualified/trifecta\n  Description: Fetches all race data, runs the Trifecta analyzer, and returns qualified races.\n  Headers:\n    - X-API-Key: (Required, not used in this local setup but good practice)\n  Query Params:\n    - max_field_size: int\n    - min_odds: float\n  Response (200 OK):\n    {\n      \"qualified_races\": List[Race],\n      \"analysis_metadata\": { ... }\n    }\n```\n\n---\n\n## 7. DEPLOYMENT & AUTOMATION (CI/CD)\n\n```pseudocode\nWORKFLOW Build_MSI_Installer_on_GitHub_Actions:\n  // Phase 1: Setup\n  SETUP Node.js and Python environments\n\n  // Phase 2: Build Frontend\n  RUN \"npm ci\" and \"npm run build\" in /web_platform/frontend\n  COPY static output to /electron/web-ui-build/out\n\n  // Phase 3: Build Backend\n  RUN \"pip install -r python_service/requirements.txt\"\n  // CRITICAL: Use PyInstaller with a spec file or CLI flags that include\n  // necessary hidden imports to prevent runtime crashes.\n  // e.g., --hidden-import=keyring.backends.fail.Keyring\n  EXECUTE PyInstaller to create fortuna-backend.exe\n  PLACE executable in /electron/resources/fortuna-backend\n\n  // Phase 4: Deep Integration Test\n  START fortuna-backend.exe in the background\n  POLL http://127.0.0.1:8000/health until it responds with 200 OK or times out\n  IF timeout or crash THEN FAIL the build\n\n  // Phase 5: Package\n  RUN \"npm ci\" in /electron\n  EXECUTE \"npx electron-builder\" to create the MSI installer\n\n  // Phase 6: Publish\n  UPLOAD MSI as a build artifact\n  IF build was triggered by a git tag THEN CREATE a new GitHub Release\n```\n\n---\n\n## 8. END-TO-END WORKFLOWS\n\n### 8.1 Production Startup Workflow (Resilient)\n\n```\nWORKFLOW user_launches_application:\n  STEP 1: User executes Fortuna Faucet.exe -> Electron main.js starts.\n  STEP 2: UI appears instantly. The main process creates the BrowserWindow and loads the static index.html. The UI shows a 'connecting' state.\n  STEP 3: Backend starts asynchronously. The main process calls the robust `startBackend()` function.\n  STEP 4: `startBackend()` spawns `fortuna-backend.exe` and starts a 30-second timeout.\n  STEP 5: The frontend UI polls for status every 3 seconds via the secure `window.electronAPI.getBackendStatus()`.\n  STEP 6: The backend `.exe` starts, its `lifespan` hook runs, and the Uvicorn server comes online within seconds.\n  STEP 7: The main process detects the \"Uvicorn running\" message (or a successful health poll) and updates its internal state to 'online'. The startup timeout is cleared.\n  STEP 8: On its next poll, the frontend receives the 'online' status.\n  STEP 9: The frontend's state changes, triggering the `fetchQualifiedRaces()` API call to `localhost:8000`.\n  STEP 10: Data is returned from the now fully-initialized backend and rendered in the UI.\n\n  FAILURE SCENARIO (Backend Crash):\n  STEP 6a: The backend `.exe` crashes on startup.\n  STEP 7a: The `on('exit')` handler in `main.js` fires. The state is set to 'error' with the exit code.\n  STEP 8a: On its next poll, the frontend receives the 'error' status and relevant logs.\n  STEP 9a: The UI renders an error message and a \"Restart Backend\" button.\n```\n\n---\n*This concludes the revised and definitive blueprint for the Fortuna Faucet application.*",
    "electron/electron-builder-config.yml": "appId: com.jules.fortunafaucet\nproductName: \"Fortuna Faucet\"\n\ndirectories:\n  output: dist\n  buildResources: assets\n\nfiles:\n  - filter:\n      - \"**/*\"\n\nextraResources:\n  - from: \"../python-service-bin\"\n    to: \"python-service-bin\"\n    filter:\n      - \"**/*\"\n  - from: \"../web_platform/frontend/out\"\n    to: \"resources/frontend\"\n    filter:\n      - \"**/*\"\n\nwin:\n  target: msi\n  icon: \"assets/icon.ico\"\n\nmsi:\n  oneClick: false\n  perMachine: true\n  runAfterFinish: true\n  # Explicitly pointing to the file ensures WiX picks it up\n  shortcutName: \"Fortuna Faucet\"\n  warningsAsErrors: false",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"paddock-parser-ng\"\nversion = \"0.1.0\"\ndescription = \"A toolkit to identify the best racecards for betting.\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\n[project.scripts]\npaddock_parser_ui = \"paddock_parser.entry_points:run_terminal_ui\"\npaddock_parser_dashboard = \"paddock_parser.entry_points:run_dashboard\"\npaddock_parser_predict = \"paddock_parser.entry_points:run_prediction_engine\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n# Configuration for the Ruff linter\n[tool.ruff]\n# Allow lines to be up to 120 characters long.\nline-length = 120\n\n[tool.ruff.lint]\n# Enable Pyflakes (F), pycodestyle (E, W), and isort (I) rules.\nselect = [\"E\", \"F\", \"W\", \"I\"]\nignore = []\n\n[tool.ruff.lint.isort]\n# Sort imports within their sections alphabetically.\nforce-single-line = true\n",
    "python_service/adapters/__init__.py": "# python_service/adapters/__init__.py\n# TEMPORARY FIX: Comment out the problematic adapter\n\nfrom .at_the_races_adapter import AtTheRacesAdapter\nfrom .betfair_adapter import BetfairAdapter\nfrom .betfair_greyhound_adapter import BetfairGreyhoundAdapter\n\n# from .betfair_datascientist_adapter import BetfairDataScientistAdapter  # DISABLED: PyInstaller NumPy issue\nfrom .gbgb_api_adapter import GbgbApiAdapter\nfrom .greyhound_adapter import GreyhoundAdapter\nfrom .harness_adapter import HarnessAdapter\nfrom .pointsbet_greyhound_adapter import PointsBetGreyhoundAdapter\nfrom .racing_and_sports_adapter import RacingAndSportsAdapter\nfrom .racing_and_sports_greyhound_adapter import RacingAndSportsGreyhoundAdapter\nfrom .sporting_life_adapter import SportingLifeAdapter\nfrom .the_racing_api_adapter import TheRacingApiAdapter\nfrom .timeform_adapter import TimeformAdapter\nfrom .tvg_adapter import TVGAdapter\n\n__all__ = [\n    \"GbgbApiAdapter\",\n    \"TVGAdapter\",\n    \"BetfairAdapter\",\n    \"BetfairGreyhoundAdapter\",\n    \"RacingAndSportsGreyhoundAdapter\",\n    \"AtTheRacesAdapter\",\n    \"PointsBetGreyhoundAdapter\",\n    \"RacingAndSportsAdapter\",\n    \"SportingLifeAdapter\",\n    \"TimeformAdapter\",\n    \"HarnessAdapter\",\n    \"GreyhoundAdapter\",\n    \"TheRacingApiAdapter\",\n    # \"BetfairDataScientistAdapter\",  # DISABLED\n]\n",
    "python_service/adapters/at_the_races_adapter.py": "# python_service/adapters/at_the_races_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom ..utils.text import normalize_venue_name\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass AtTheRacesAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for attheraces.com, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"AtTheRaces\"\n    BASE_URL = \"https://www.attheraces.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"\n        Fetches the raw HTML for all race pages for a given date.\n        Returns a dictionary containing the HTML content and the date.\n        \"\"\"\n        index_url = f\"/racecards/{date}\"\n        index_response = await self.make_request(self.http_client, \"GET\", index_url)\n        if not index_response:\n            self.logger.warning(\"Failed to fetch AtTheRaces index page\", url=index_url)\n            return None\n\n        index_soup = BeautifulSoup(index_response.text, \"html.parser\")\n        links = {a[\"href\"] for a in index_soup.select(\"a.race-time-link[href]\")}\n\n        async def fetch_single_html(url_path: str):\n            response = await self.make_request(self.http_client, \"GET\", url_path)\n            return response.text if response else \"\"\n\n        tasks = [fetch_single_html(link) for link in links]\n        html_pages = await asyncio.gather(*tasks)\n        return {\"pages\": html_pages, \"date\": date}\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of raw HTML strings into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"pages\"):\n            return []\n\n        all_races = []\n        try:\n            race_date = datetime.strptime(raw_data[\"date\"], \"%Y-%m-%d\").date()\n        except ValueError:\n            self.logger.error(\n                \"Invalid date format provided to AtTheRacesAdapter\",\n                date=raw_data.get(\"date\"),\n            )\n            return []\n\n        for html in raw_data[\"pages\"]:\n            if not html:\n                continue\n            try:\n                soup = BeautifulSoup(html, \"html.parser\")\n                header_element = soup.select_one(\"h1.heading-racecard-title\")\n                if not header_element:\n                    continue\n                header = header_element.get_text()\n                track_name_raw, race_time = [p.strip() for p in header.split(\"|\")[:2]]\n                track_name = normalize_venue_name(track_name_raw)\n                active_link = soup.select_one(\"a.race-time-link.active\")\n                race_number = 1\n                if active_link:\n                    parent_div = active_link.find_parent(\"div\", \"races\")\n                    if parent_div:\n                        all_links = parent_div.select(\"a.race-time-link\")\n                        race_number = all_links.index(active_link) + 1\n\n                start_time = datetime.combine(race_date, datetime.strptime(race_time, \"%H:%M\").time())\n\n                runners = [self._parse_runner(row) for row in soup.select(\"div.card-horse\")]\n                race = Race(\n                    id=f\"atr_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\",\n                    venue=track_name,\n                    race_number=race_number,\n                    start_time=start_time,\n                    runners=[r for r in runners if r],\n                    source=self.source_name,\n                )\n                all_races.append(race)\n            except (AttributeError, IndexError, ValueError):\n                self.logger.warning(\n                    \"Error parsing a race from AtTheRaces, skipping race.\",\n                    exc_info=True,\n                )\n                continue\n        return all_races\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name_element = row.select_one(\"h3.horse-name a\")\n            if not name_element:\n                return None\n            name = clean_text(name_element.get_text())\n\n            num_element = row.select_one(\"span.horse-number\")\n            if not num_element:\n                return None\n            num_str = clean_text(num_element.get_text())\n            number = int(\"\".join(filter(str.isdigit, num_str)))\n\n            odds_element = row.select_one(\"button.best-odds\")\n            odds_str = clean_text(odds_element.get_text()) if odds_element else \"\"\n\n            win_odds = parse_odds_to_decimal(odds_str)\n            odds_data = (\n                {\n                    self.source_name: OddsData(\n                        win=win_odds,\n                        source=self.source_name,\n                        last_updated=datetime.now(),\n                    )\n                }\n                if win_odds and win_odds < 999\n                else {}\n            )\n            return Runner(number=number, name=name, odds=odds_data)\n        except (AttributeError, ValueError):\n            self.logger.warning(\"Failed to parse a runner on AtTheRaces, skipping runner.\")\n            return None\n",
    "python_service/adapters/greyhound_adapter.py": "# python_service/adapters/greyhound_adapter.py\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\n\nfrom pydantic import ValidationError\n\nfrom ..core.exceptions import AdapterConfigError\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass GreyhoundAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for fetching Greyhound racing data, migrated to BaseAdapterV3.\n    Activated by setting GREYHOUND_API_URL in .env.\n    \"\"\"\n\n    SOURCE_NAME = \"Greyhound Racing\"\n\n    def __init__(self, config=None):\n        if not hasattr(config, \"GREYHOUND_API_URL\") or not config.GREYHOUND_API_URL:\n            raise AdapterConfigError(self.SOURCE_NAME, \"GREYHOUND_API_URL is not configured.\")\n        super().__init__(\n            source_name=self.SOURCE_NAME,\n            base_url=config.GREYHOUND_API_URL,\n            config=config,\n        )\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"Fetches the raw card data from the greyhound API.\"\"\"\n        endpoint = f\"v1/cards/{date}\"\n        response = await self.make_request(self.http_client, \"GET\", endpoint)\n        return response.json() if response else None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses the raw card data into a list of Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"cards\"):\n            self.logger.warning(\"No 'cards' in greyhound response or empty list.\")\n            return []\n\n        all_races = []\n        for card in raw_data.get(\"cards\", []):\n            venue = card.get(\"track_name\", \"Unknown Venue\")\n            for race_data in card.get(\"races\", []):\n                try:\n                    if not race_data.get(\"runners\"):\n                        continue\n\n                    race_id = race_data.get(\"race_id\")\n                    race_number = race_data.get(\"race_number\")\n                    start_timestamp = race_data.get(\"start_time\")\n                    if not all([race_id, race_number, start_timestamp]):\n                        continue\n\n                    race = Race(\n                        id=f\"greyhound_{race_id}\",\n                        venue=venue,\n                        race_number=race_number,\n                        start_time=datetime.fromtimestamp(start_timestamp),\n                        runners=self._parse_runners(race_data.get(\"runners\", [])),\n                        source=self.source_name,\n                    )\n                    all_races.append(race)\n                except (ValidationError, KeyError) as e:\n                    self.logger.error(\n                        \"Error parsing greyhound race\",\n                        race_id=race_data.get(\"race_id\", \"N/A\"),\n                        error=str(e),\n                    )\n                    continue\n        return all_races\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]]) -> List[Runner]:\n        \"\"\"Parses a list of runner dictionaries into Runner objects.\"\"\"\n        runners = []\n        for runner_data in runners_data:\n            try:\n                if runner_data.get(\"scratched\", False):\n                    continue\n\n                trap_number = runner_data.get(\"trap_number\")\n                dog_name = runner_data.get(\"dog_name\")\n                if not all([trap_number, dog_name]):\n                    continue\n\n                odds_data = {}\n                win_odds_val = runner_data.get(\"odds\", {}).get(\"win\")\n                if win_odds_val is not None:\n                    win_odds = Decimal(str(win_odds_val))\n                    if win_odds > 1:\n                        odds_data[self.source_name] = OddsData(\n                            win=win_odds,\n                            source=self.source_name,\n                            last_updated=datetime.now(),\n                        )\n\n                runners.append(\n                    Runner(\n                        number=trap_number,\n                        name=dog_name,\n                        scratched=runner_data.get(\"scratched\", False),\n                        odds=odds_data,\n                    )\n                )\n            except (KeyError, ValidationError):\n                self.logger.warning(\"Error parsing greyhound runner, skipping.\", runner_data=runner_data)\n                continue\n        return runners\n",
    "python_service/adapters/nyrabets_adapter.py": "# python_service/adapters/nyrabets_adapter.py\nfrom typing import Any\nfrom typing import List\n\nfrom ..models import Race\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass NYRABetsAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for nyrabets.com.\n    This adapter is a non-functional stub and has not been implemented.\n    \"\"\"\n\n    SOURCE_NAME = \"NYRABets\"\n    BASE_URL = \"https://nyrabets.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"This is a stub and does not fetch any data.\"\"\"\n        self.logger.warning(\n            f\"{self.source_name} is a non-functional stub and has not been implemented. It will not fetch any data.\"\n        )\n        return None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"This is a stub and does not parse any data.\"\"\"\n        return []\n",
    "python_service/adapters/racing_and_sports_adapter.py": "# python_service/adapters/racing_and_sports_adapter.py\n\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nfrom ..core.exceptions import AdapterConfigError\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass RacingAndSportsAdapter(BaseAdapterV3):\n    \"\"\"Adapter for Racing and Sports API, migrated to BaseAdapterV3.\"\"\"\n\n    SOURCE_NAME = \"RacingAndSports\"\n    BASE_URL = \"https://api.racingandsports.com.au/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n        if not hasattr(config, \"RACING_AND_SPORTS_TOKEN\") or not config.RACING_AND_SPORTS_TOKEN:\n            raise AdapterConfigError(self.source_name, \"RACING_AND_SPORTS_TOKEN is not configured.\")\n        self.api_token = config.RACING_AND_SPORTS_TOKEN\n\n    async def _fetch_data(self, date: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetches the raw meetings data from the Racing and Sports API.\"\"\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_token}\",\n            \"Accept\": \"application/json\",\n        }\n        params = {\"date\": date, \"jurisdiction\": \"AUS\"}\n        response = await self.make_request(\n            self.http_client,\n            \"GET\",\n            \"v1/racing/meetings\",\n            headers=headers,\n            params=params,\n        )\n        return response.json() if response else None\n\n    def _parse_races(self, raw_data: Optional[Dict[str, Any]]) -> List[Race]:\n        \"\"\"Parses the raw meetings data into a list of Race objects.\"\"\"\n        all_races = []\n        if not raw_data or not isinstance(raw_data.get(\"meetings\"), list):\n            self.logger.warning(\"No 'meetings' in RacingAndSports response or invalid format.\")\n            return all_races\n\n        for meeting in raw_data.get(\"meetings\", []):\n            if not isinstance(meeting, dict):\n                continue\n            for race_summary in meeting.get(\"races\", []):\n                if not isinstance(race_summary, dict):\n                    continue\n                try:\n                    if parsed_race := self._parse_ras_race(meeting, race_summary):\n                        all_races.append(parsed_race)\n                except (KeyError, TypeError, ValueError):\n                    self.logger.warning(\n                        \"Failed to parse RacingAndSports race, skipping\",\n                        meeting=meeting.get(\"venueName\"),\n                        race_id=race_summary.get(\"raceId\"),\n                        exc_info=True,\n                    )\n        return all_races\n\n    def _parse_ras_race(self, meeting: Dict[str, Any], race: Dict[str, Any]) -> Optional[Race]:\n        \"\"\"Parses a single race object from the API response.\"\"\"\n        race_id = race.get(\"raceId\")\n        start_time_str = race.get(\"startTime\")\n        race_number = race.get(\"raceNumber\")\n\n        if not all([race_id, start_time_str, race_number]):\n            return None\n\n        runners = [\n            Runner(\n                number=rd.get(\"runnerNumber\", 0),\n                name=rd.get(\"horseName\", \"Unknown\"),\n                scratched=rd.get(\"isScratched\", False),\n            )\n            for rd in race.get(\"runners\", [])\n            if isinstance(rd, dict) and rd.get(\"runnerNumber\")\n        ]\n\n        if not runners:\n            return None\n\n        try:\n            start_time = datetime.fromisoformat(start_time_str)\n        except (ValueError, TypeError):\n            self.logger.warning(\n                \"Invalid start time format for RacingAndSports race\",\n                start_time_str=start_time_str,\n                race_id=race_id,\n            )\n            return None\n\n        return Race(\n            id=f\"ras_{race_id}\",\n            venue=meeting.get(\"venueName\", \"Unknown Venue\"),\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n",
    "python_service/main.py": "import uvicorn\nimport sys\nimport os\nimport asyncio\nfrom multiprocessing import freeze_support\n\n# Force UTF-8 encoding for stdout and stderr, crucial for PyInstaller on Windows\nos.environ[\"PYTHONUTF8\"] = \"1\"\n\n# Import the 'app' object at the top level to make it accessible for import by other modules,\n# such as diagnostic scripts in CI/CD.\nfrom python_service.api import app, HTTPException\n\n# This is the definitive entry point for the Fortuna Faucet backend service.\n# It is designed to be compiled with PyInstaller.\n\n\ndef _configure_sys_path():\n    \"\"\"\n    Dynamically adds project paths to sys.path.\n    This is the robust solution to ensure that string-based imports like\n    \"web_service.backend.api:app\" work correctly when the application is\n    run from a PyInstaller executable. The `_MEIPASS` attribute is a temporary\n    directory created by PyInstaller at runtime.\n    \"\"\"\n    if getattr(sys, \"frozen\", False) and hasattr(sys, \"_MEIPASS\"):\n        # Running in a PyInstaller bundle. The project root is the _MEIPASS directory.\n        project_root = os.path.abspath(sys._MEIPASS)\n\n        # Aggressively add paths to resolve potential module lookup issues in frozen mode.\n        paths_to_add = [\n            project_root,\n            os.path.join(project_root, \"python_service\"),\n        ]\n\n        # Insert paths at the beginning of sys.path in reverse order\n        # to maintain the desired precedence.\n        for path in reversed(paths_to_add):\n            if path not in sys.path:\n                sys.path.insert(0, path)\n                print(f\"INFO: Added path to sys.path: {path}\")\n\n    else:\n        # Running as a normal script. The project root is one level up.\n        project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\n        if project_root not in sys.path:\n            sys.path.insert(0, project_root)\n            print(f\"INFO: Added project root to sys.path: {project_root}\")\n\n\ndef main():\n    _configure_sys_path()\n    \"\"\"\n    Primary entry point for the Fortuna Faucet backend application.\n    This function configures and runs the Uvicorn server.\n    It's crucial to launch the app this way to ensure PyInstaller's bootloader\n    can correctly resolve the package context.\n    \"\"\"\n    # When packaged, we need to ensure multiprocessing works correctly.\n    if getattr(sys, \"frozen\", False):\n        # CRITICAL for multiprocessing support in frozen mode on Windows.\n        freeze_support()\n\n    from python_service.config import get_settings\n    from fastapi.staticfiles import StaticFiles\n    from fastapi.responses import FileResponse\n    from python_service.port_check import check_port_and_exit_if_in_use\n\n    settings = get_settings()\n\n    # --- Port Sanity Check ---\n    # Before doing anything else, ensure the target port is not already in use.\n    # This prevents a common and confusing crash scenario on startup.\n    check_port_and_exit_if_in_use(settings.FORTUNA_PORT, settings.UVICORN_HOST)\n\n    # --- Conditional UI Serving for Web Service Mode ---\n    # Only serve the UI if the FORTUNA_MODE environment variable is set to 'webservice'.\n    # This prevents the Electron-packaged backend from trying to serve files it doesn't have.\n    if os.environ.get(\"FORTUNA_MODE\") == \"webservice\":\n        # Define the path to the static UI files, accommodating PyInstaller's bundle.\n        if getattr(sys, \"frozen\", False):\n            # In a bundled app, the UI files are in the '_MEIPASS/ui' directory.\n            STATIC_DIR = os.path.join(sys._MEIPASS, \"ui\")\n        else:\n            # In development, they are in the frontend's output directory.\n            STATIC_DIR = os.path.abspath(\n                os.path.join(os.path.dirname(__file__), \"..\", \"web_platform\", \"frontend\", \"out\")\n            )\n\n        # Mount the static assets directory for CSS, JS, etc.\n        if os.path.exists(os.path.join(STATIC_DIR, \"_next\")):\n            app.mount(\"/_next\", StaticFiles(directory=os.path.join(STATIC_DIR, \"_next\")), name=\"next\")\n\n        # Serve the main index.html for any non-API path.\n        @app.get(\"/{full_path:path}\", include_in_schema=False)\n        async def serve_frontend(full_path: str):\n            if full_path.startswith(\"api/\") or full_path.startswith(\"docs\") or full_path == \"health\":\n                # This is an API route, let FastAPI handle it.\n                # A 404 will be raised naturally if no route matches.\n                return\n\n            index_path = os.path.join(STATIC_DIR, \"index.html\")\n            if os.path.exists(index_path):\n                return FileResponse(index_path)\n            else:\n                # This will only be hit if the frontend files are missing entirely.\n                raise HTTPException(\n                    status_code=404,\n                    detail=\"Frontend not found. Please build the frontend and ensure it's in the correct location.\",\n                )\n\n    # CRITICAL FIX FOR PYINSTALLER on WINDOWS: Force event loop policy\n    # This resolves a silent network binding failure where Uvicorn reports startup\n    # but the OS never actually binds the port.\n    if sys.platform == \"win32\" and getattr(sys, 'frozen', False):\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n        print(\"[BOOT] Applied WindowsSelectorEventLoopPolicy for PyInstaller\", file=sys.stderr)\n\n    uvicorn.run(app, host=settings.UVICORN_HOST, port=settings.FORTUNA_PORT, log_level=\"info\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "python_service/manual_override_manager.py": "# python_service/manual_override_manager.py\nimport hashlib\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\nfrom pydantic import BaseModel\nfrom pydantic import Field\n\n\nclass ManualOverrideRequest(BaseModel):\n    request_id: str\n    adapter_name: str\n    url: str\n    timestamp: datetime = Field(default_factory=datetime.now)\n    status: str = \"pending\"  # pending, submitted, skipped\n\n\nclass ManualOverrideManager:\n    def __init__(self):\n        self._requests: Dict[str, ManualOverrideRequest] = {}\n        self._data: Dict[str, Tuple[str, str]] = {}  # request_id -> (content, content_type)\n\n    def _generate_id(self, adapter_name: str, url: str) -> str:\n        \"\"\"Generates a consistent ID for a given adapter and URL.\"\"\"\n        return hashlib.sha256(f\"{adapter_name}:{url}\".encode()).hexdigest()[:16]\n\n    def register_failure(self, adapter_name: str, url: str) -> str:\n        \"\"\"\n        Registers a failed fetch attempt and returns a unique request ID.\n        If a pending request for this exact resource already exists, it returns the existing ID.\n        \"\"\"\n        request_id = self._generate_id(adapter_name, url)\n        if request_id not in self._requests or self._requests[request_id].status != \"pending\":\n            request = ManualOverrideRequest(request_id=request_id, adapter_name=adapter_name, url=url)\n            self._requests[request_id] = request\n        return request_id\n\n    def submit_manual_data(self, request_id: str, raw_content: str, content_type: str) -> bool:\n        \"\"\"Submits manual data for a pending request.\"\"\"\n        if request_id in self._requests and self._requests[request_id].status == \"pending\":\n            self._data[request_id] = (raw_content, content_type)\n            self._requests[request_id].status = \"submitted\"\n            return True\n        return False\n\n    def skip_request(self, request_id: str) -> bool:\n        \"\"\"Marks a pending request as skipped.\"\"\"\n        if request_id in self._requests and self._requests[request_id].status == \"pending\":\n            self._requests[request_id].status = \"skipped\"\n            return True\n        return False\n\n    def get_pending_requests(self) -> List[ManualOverrideRequest]:\n        \"\"\"Returns a list of all requests that are currently pending.\"\"\"\n        return [req for req in self._requests.values() if req.status == \"pending\"]\n\n    def get_manual_data(self, adapter_name: str, url: str) -> Optional[Tuple[str, str]]:\n        \"\"\"\n        Retrieves submitted manual data for a given adapter and URL, if it exists.\n        Once retrieved, the data is consumed and will not be returned again.\n        \"\"\"\n        request_id = self._generate_id(adapter_name, url)\n        if request_id in self._data:\n            # Data is single-use; remove it after retrieval.\n            return self._data.pop(request_id)\n        return None\n\n    def clear_old_requests(self, max_age_hours: int = 24):\n        \"\"\"Removes requests and associated data older than a specified age.\"\"\"\n        cutoff = datetime.now() - timedelta(hours=max_age_hours)\n        old_request_ids = [req_id for req_id, req in self._requests.items() if req.timestamp < cutoff]\n        for req_id in old_request_ids:\n            self._requests.pop(req_id, None)\n            self._data.pop(req_id, None)\n",
    "python_service/port_check.py": "import socket\nimport sys\n\n\ndef is_port_in_use(port: int, host: str = \"127.0.0.1\") -> bool:\n    \"\"\"\n    Checks if a local port is already in use.\n\n    Args:\n        port: The port number to check.\n        host: The host to check (defaults to localhost).\n\n    Returns:\n        True if the port is in use, False otherwise.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        try:\n            s.bind((host, port))\n            return False\n        except OSError:\n            return True\n\n\ndef check_port_and_exit_if_in_use(port: int, host: str = \"127.0.0.1\"):\n    \"\"\"\n    Checks the specified port and exits the application with a user-friendly\n    message if it's already in use.\n    \"\"\"\n    # Note: A simple s.connect_ex((host, port)) == 0 is not reliable, as it can\n    # intermittently fail depending on socket states. A full bind attempt is\n    # the most robust way to check for port availability.\n    if is_port_in_use(port, host):\n        print(f\"--- FATAL ERROR ---\")\n        print(f\"Port {port} on host {host} is already in use by another application.\")\n        print(f\"Please close the other application or configure Fortuna Faucet to use a different port.\")\n        print(f\"-------------------\")\n        # Use sys.exit to ensure a clean exit, especially important for PyInstaller executables.\n        sys.exit(1)\n",
    "python_service/requirements-dev.txt": "#\n# Development & Build-Time Dependencies\n# This file should be used for setting up a development or CI/CD environment.\n#\n\n-r requirements.txt\n\n# --- Build Tools ---\npyinstaller==6.6.0\npip-tools\n\n# --- Testing Tools ---\npytest\npytest-asyncio\nfakeredis\nrespx\n\n# --- Linting & Auditing ---\nblack\nruff\npip-audit\nsetuptools<81\n",
    "python_service/requirements_minimal.txt": "httpx==0.25.0\nstructlog==23.2.0\npydantic==2.5.0\nuvicorn==0.24.0\nfastapi==0.104.1\ntenacity==8.2.3\n",
    "python_service/run_api.py": "# python_service/run_api.py\n\nimport uvicorn\n\n\ndef main():\n    # This entry point is for the packaged application\n    uvicorn.run(\"python_service.api:app\", host=\"127.0.0.1\", port=8000, reload=False)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "scripts/convert_to_json.py": "# convert_to_json.py\n# This script now contains the full, enlightened logic to handle all manifest formats and path styles.\n\nimport json\nimport os\nimport sys\nfrom multiprocessing import Process\nfrom multiprocessing import Queue\n\n# --- Configuration ---\nMANIFEST_FILES = [\n    \"MANIFEST_PART1_BACKEND.json\",\n    \"MANIFEST_PART2_FRONTEND.json\",\n    \"MANIFEST_PART3_SUPPORT.json\",\n    \"MANIFEST_PART4_ROOT.json\",\n]\nOUTPUT_DIR = \"ReviewableJSON\"\nFILE_PROCESSING_TIMEOUT = 10\nEXCLUDED_FILES = [\"package-lock.json\"]\nMAX_FILE_SIZE_MB = 10  # Max file size in megabytes\n\n\ndef read_json_manifest(manifest_path: str) -> list[str]:\n    \"\"\"Reads a JSON manifest file and returns a list of file paths.\"\"\"\n    try:\n        with open(manifest_path, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n    except (json.JSONDecodeError, FileNotFoundError):\n        return []\n\n\n# --- SANDBOXED FILE READ (Unchanged) ---\ndef _sandboxed_file_read(file_path, q):\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            content = f.read()\n        q.put({\"file_path\": file_path, \"content\": content})\n    except Exception as e:\n        q.put({\"error\": str(e)})\n\n\ndef convert_file_to_json_sandboxed(file_path):\n    # --- Pre-flight check: File size ---\n    try:\n        file_size = os.path.getsize(file_path)\n        if file_size > MAX_FILE_SIZE_MB * 1024 * 1024:\n            return {\"error\": f\"File exceeds {MAX_FILE_SIZE_MB}MB size limit.\"}\n    except FileNotFoundError:\n        return {\"error\": \"File not found.\"}\n    except Exception as e:\n        return {\"error\": f\"Could not check file size: {e}\"}\n\n    q = Queue()\n    p = Process(target=_sandboxed_file_read, args=(file_path, q))\n    p.start()\n    p.join(timeout=FILE_PROCESSING_TIMEOUT)\n\n    try:\n        if p.is_alive():\n            print(f\"    [WARNING] Process for {file_path} timed out. Attempting graceful termination...\")\n            p.terminate()\n            p.join(timeout=2)  # Give it a moment to terminate gracefully\n\n            if p.is_alive():\n                print(f\"    [ERROR] Graceful termination failed. Forcibly killing process...\")\n                p.kill()  # The ultimate \"just die\"\n                p.join()\n            return {\"error\": f\"Timeout: File processing took longer than {FILE_PROCESSING_TIMEOUT} seconds.\"}\n\n        if not q.empty():\n            return q.get()\n        return {\"error\": \"Unknown error in sandboxed read process.\"}\n    finally:\n        # \u2705 Properly close and flush the queue\n        try:\n            while not q.empty():\n                q.get_nowait()\n        except Exception:\n            pass\n        q.close()\n        q.join_thread()\n\n\n# --- Main Orchestrator ---\ndef main():\n    print(f\"\\n{'=' * 60}\\nStarting IRONCLAD JSON backup process... (Enlightened Scribe Edition)\\n{'=' * 60}\")\n    os.makedirs(OUTPUT_DIR, exist_ok=True)\n\n    all_local_paths = []\n    for manifest in MANIFEST_FILES:\n        print(f\"--> Parsing manifest: {manifest}\")\n        paths = read_json_manifest(manifest)\n        if paths:\n            all_local_paths.extend(paths)\n            print(f\"    --> Found {len(paths)} valid file paths.\")\n        else:\n            print(f\"    [WARNING] Manifest not found or is empty: {manifest}\")\n\n    if not all_local_paths:\n        print(\"\\n[FATAL] No valid file paths found in any manifest. Aborting.\")\n        sys.exit(1)\n\n    unique_local_paths = sorted(list(set(all_local_paths)))\n    print(f\"\\nFound a total of {len(unique_local_paths)} unique files to process.\")\n    processed_count, failed_count = 0, 0\n\n    for local_path in unique_local_paths:\n        if os.path.basename(local_path) in EXCLUDED_FILES:\n            print(f\"\\n--> Skipping excluded file: {local_path}\")\n            failed_count += 1\n            continue\n        print(f\"\\nProcessing: {local_path}\")\n        json_data = convert_file_to_json_sandboxed(local_path)\n        if json_data and \"error\" not in json_data:\n            output_path = os.path.join(OUTPUT_DIR, local_path + \".json\")\n            os.makedirs(os.path.dirname(output_path), exist_ok=True)\n            with open(output_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(json_data, f, indent=4)\n            print(f\"    [SUCCESS] Saved backup to {output_path}\")\n            processed_count += 1\n        else:\n            error_msg = json_data.get(\"error\", \"Unknown error\") if json_data else \"File not found\"\n            print(f\"    [ERROR] Failed to process {local_path}: {error_msg}\")\n            failed_count += 1\n\n    print(f\"\\n{'=' * 60}\")\n    print(\"Backup process complete.\")\n    print(f\"Successfully processed: {processed_count}/{len(unique_local_paths)}\")\n    print(f\"Failed/Skipped: {failed_count}\")\n    print(f\"{'=' * 60}\")\n\n    if failed_count > 0:\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "scripts/generate_spec_electron.py": "# scripts/generate_spec_electron.py\nimport os\nimport sys\nimport subprocess\nfrom pathlib import Path\n\ndef main():\n    \"\"\"\n    Generates a PyInstaller spec file for the Electron workflows,\n    ensures __init__.py files exist, and runs the PyInstaller build.\n    \"\"\"\n    print(\"--- \ud83d\udc0d Electron Spec Generator ---\")\n\n    # 1. Get environment variables\n    try:\n        bk_dir = os.environ['BACKEND_DIR']\n        entry = f\"{bk_dir}/main.py\"\n    except KeyError as e:\n        print(f\"\u274c Missing environment variable: {e}\")\n        sys.exit(1)\n\n    print(f\"Backend Dir: {bk_dir}\")\n    print(f\"Entry Point: {entry}\")\n\n    # 2. Validate paths\n    if not Path(entry).exists():\n        print(f\"\u274c Entry point not found: {entry}\")\n        sys.exit(1)\n\n    # 3. This build is simpler and doesn't require the dynamic __init__\n    # injection that the web service does, as it's a more controlled environment.\n    # We just need to ensure the `python_service` is on the path.\n    pathex = [str(Path.cwd().resolve())]\n    print(f\"Using pathex: {pathex}\")\n\n\n    # 4. Define the spec file content for Electron\n    # This is based on the configuration required for the Electron app,\n    # which excludes the web service components.\n    spec_content = f\"\"\"\n# -*- mode: python ; coding: utf-8 -*-\n# Generated by scripts/generate_spec_electron.py\n\nfrom PyInstaller.utils.hooks import collect_data_files\n\nblock_cipher = None\n\na = Analysis(\n    ['{entry}'],\n    pathex={pathex},\n    binaries=[],\n    datas=[],\n    hiddenimports=['uvicorn.lifespan', 'uvicorn.loops', 'uvicorn.protocols', 'win32timezone'],\n    hookspath=[],\n    runtime_hooks=[],\n    excludes=['web_service'], # Explicitly exclude the other backend\n    win_no_prefer_redirects=False,\n    win_private_assemblies=False,\n    cipher=block_cipher,\n    noarchive=False,\n)\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    [],\n    exclude_binaries=True,\n    name='fortuna-backend',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    console=True, # Electron requires a console app to manage stdio\n)\ncoll = COLLECT(\n    exe,\n    a.binaries,\n    a.zipfiles,\n    a.datas,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    name='fortuna-backend',\n)\n\"\"\"\n\n    # 5. Write the spec file\n    spec_path = \"fortuna-backend-electron.spec\"\n    print(f\"--- Writing spec file to {spec_path} ---\")\n    with open(spec_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(spec_content)\n    print(f\"\u2705 Spec file created.\")\n\n    # 6. Run PyInstaller\n    print(\"--- Running PyInstaller build ---\")\n    cmd = [\n        sys.executable,\n        \"-m\", \"PyInstaller\",\n        spec_path,\n        \"--clean\",\n        \"--noconfirm\",\n        \"--log-level\", \"WARN\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n\n    if result.returncode != 0:\n        print(\"\u274c PyInstaller build failed!\")\n        print(\"--- STDOUT ---\")\n        print(result.stdout)\n        print(\"--- STDERR ---\")\n        print(result.stderr)\n        sys.exit(1)\n\n    print(\"\u2705 PyInstaller build successful.\")\n    print(result.stdout)\n\nif __name__ == \"__main__\":\n    main()\n",
    "scripts/get_api_key.py": "# scripts/get_api_key.py\nimport os\nimport sys\n\n# This is a workaround to ensure the script can find the python_service module,\n# especially when run from the packaged Electron app.\n# It assumes this script is in `resources/app/scripts` and the service is in `resources/app/python_service`.\ntry:\n    # Get the directory of the current script.\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    # Go up one level to the `app` directory and add `python_service` to the path.\n    project_root = os.path.dirname(script_dir)\n    sys.path.append(project_root)\n    from python_service.credentials_manager import SecureCredentialsManager\nexcept ImportError as e:\n    # If the import fails, write the error to stderr and exit.\n    # This helps in debugging path issues in the production environment.\n    print(\n        f\"Error: Failed to import SecureCredentialsManager. Details: {e}\",\n        file=sys.stderr,\n    )\n    sys.exit(1)\n\n\ndef retrieve_and_print_key():\n    \"\"\"\n    Retrieves the API key using the SecureCredentialsManager and prints it to stdout.\n    If the key is not found, it prints an empty string.\n    If an error occurs, it prints the error to stderr.\n    \"\"\"\n    try:\n        api_key = SecureCredentialsManager.get_api_key()\n        if api_key:\n            print(api_key, end=\"\")  # Print the key directly to stdout\n        else:\n            print(\"\", end=\"\")  # Print empty string if no key is found\n    except Exception as e:\n        print(f\"An error occurred while retrieving the API key: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    retrieve_and_print_key()\n",
    "scripts/install_fortuna_silent.bat": "@echo off\nREM Automated deployment (no UI, minimal interaction)\n\nnet session >nul 2>&1\nif %errorlevel% neq 0 (\n    echo ERROR: Admin rights required\n    exit /b 1\n)\n\nREM Assumes the MSI is in the 'dist' subfolder relative to the project root\nmsiexec.exe /i \"..\\dist\\Fortuna-Faucet-2.1.0-x64.msi\" ^\n    /qn ^\n    /l*v \"%TEMP%\\fortuna_silent_install.log\" ^\n    /norestart ^\n    ALLUSERS=1 ^\n    INSTALLSCOPE=perMachine\n\nexit /b %errorlevel%",
    "web_platform/api_gateway/src/server.ts": "// server.ts - Complete API Gateway with Database Integration and WebSocket\n\nimport express from 'express';\nimport { createServer } from 'http';\nimport { Server as SocketServer } from 'socket.io';\nimport cors from 'cors';\nimport sqlite3 from 'sqlite3';\nimport { open, Database } from 'sqlite';\nimport path from 'path';\n\n// Types\ninterface Race {\n  race_id: string;\n  track_name: string;\n  race_number: number | null;\n  post_time: string | null;\n  checkmate_score: number;\n  qualified: boolean;\n  trifecta_factors_json: string | null;\n  raw_data_json: string | null;\n  updated_at: string;\n}\n\ninterface AdapterStatus {\n  adapter_name: string;\n  status: string;\n  last_run: string;\n  races_found: number;\n  execution_time_ms: number;\n  error_message: string | null;\n}\n\n// Database Service\nclass DatabaseService {\n  private db: Database | null = null;\n  private dbPath: string;\n\n  constructor() {\n    this.dbPath = process.env.FORTUNA_DB_PATH || path.join(process.cwd(), '..', '..', 'shared_database', 'races.db');\n  }\n\n  async connect(): Promise<void> {\n    try {\n      this.db = await open({\n        filename: this.dbPath,\n        driver: sqlite3.Database\n      });\n      console.log(`[INFO] Connected to database: ${this.dbPath}`);\n    } catch (error) {\n      console.error('[ERROR] Failed to connect to database:', error);\n      throw error;\n    }\n  }\n\n  async getQualifiedRaces(): Promise<Race[]> {\n    if (!this.db) throw new Error('Database not connected');\n    try {\n      const races = await this.db.all<Race[]>(`\n        SELECT race_id, track_name, race_number, post_time,\n               checkmate_score, qualified, trifecta_factors_json,\n               raw_data_json, updated_at\n        FROM live_races\n        WHERE qualified = 1\n        ORDER BY checkmate_score DESC, post_time ASC\n      `);\n      return races;\n    } catch (error) {\n      console.error('[ERROR] Failed to fetch qualified races:', error);\n      return [];\n    }\n  }\n\n  async getAllRaces(): Promise<Race[]> {\n    if (!this.db) throw new Error('Database not connected');\n    try {\n      const races = await this.db.all<Race[]>(`\n        SELECT race_id, track_name, race_number, post_time,\n               checkmate_score, qualified, trifecta_factors_json,\n               raw_data_json, updated_at\n        FROM live_races\n        ORDER BY post_time ASC\n      `);\n      return races;\n    } catch (error) {\n      console.error('[ERROR] Failed to fetch all races:', error);\n      return [];\n    }\n  }\n\n  async getAdapterStatuses(): Promise<AdapterStatus[]> {\n    if (!this.db) throw new Error('Database not connected');\n    try {\n      const statuses = await this.db.all<AdapterStatus[]>(`\n        SELECT adapter_name, status, last_run, races_found,\n               execution_time_ms, error_message\n        FROM adapter_status\n        ORDER BY last_run DESC\n      `);\n      return statuses;\n    } catch (error) {\n      console.error('[ERROR] Failed to fetch adapter statuses:', error);\n      return [];\n    }\n  }\n\n  async getRaceById(raceId: string): Promise<Race | null> {\n    if (!this.db) throw new Error('Database not connected');\n    try {\n      const race = await this.db.get<Race>(`\n        SELECT race_id, track_name, race_number, post_time,\n               checkmate_score, qualified, trifecta_factors_json,\n               raw_data_json, updated_at\n        FROM live_races\n        WHERE race_id = ?\n      `, raceId);\n      return race || null;\n    } catch (error) {\n      console.error('[ERROR] Failed to fetch race by ID:', error);\n      return null;\n    }\n  }\n}\n\n// Initialize Express and Socket.IO\nconst app = express();\nconst httpServer = createServer(app);\nconst io = new SocketServer(httpServer, {\n  cors: { origin: process.env.ALLOWED_ORIGINS || 'http://localhost:3000' }\n});\n\napp.use(cors());\napp.use(express.json());\n\nconst dbService = new DatabaseService();\n\n// API Endpoints\napp.get('/api/status', (req, res) => {\n  res.json({\n    status: 'online',\n    timestamp: new Date().toISOString(),\n    service: 'Checkmate API Gateway'\n  });\n});\n\napp.get('/api/races', async (req, res) => {\n  try {\n    const races = await dbService.getAllRaces();\n    res.json({ success: true, count: races.length, races });\n  } catch (error) {\n    res.status(500).json({ success: false, error: 'Failed to fetch races' });\n  }\n});\n\napp.get('/api/races/qualified', async (req, res) => {\n  try {\n    const races = await dbService.getQualifiedRaces();\n    res.json({ success: true, count: races.length, races });\n  } catch (error) {\n    res.status(500).json({ success: false, error: 'Failed to fetch qualified races' });\n  }\n});\n\napp.get('/api/races/:raceId', async (req, res) => {\n  try {\n    const race = await dbService.getRaceById(req.params.raceId);\n    if (race) {\n      res.json({ success: true, race });\n    } else {\n      res.status(404).json({ success: false, error: 'Race not found' });\n    }\n  } catch (error) {\n    res.status(500).json({ success: false, error: 'Failed to fetch race' });\n  }\n});\n\napp.get('/api/adapters/status', async (req, res) => {\n  try {\n    const statuses = await dbService.getAdapterStatuses();\n    res.json({ success: true, count: statuses.length, adapters: statuses });\n  } catch (error) {\n    res.status(500).json({ success: false, error: 'Failed to fetch adapter statuses' });\n  }\n});\n\n// WebSocket Connection Handling\nio.on('connection', (socket) => {\n  console.log(`[WebSocket] Client connected: ${socket.id}`);\n\n  dbService.getQualifiedRaces().then(races => {\n    socket.emit('races_update', { races });\n  });\n\n  dbService.getAdapterStatuses().then(statuses => {\n    socket.emit('adapters_update', { adapters: statuses });\n  });\n\n  socket.on('disconnect', () => {\n    console.log(`[WebSocket] Client disconnected: ${socket.id}`);\n  });\n\n  socket.on('request_update', async () => {\n    const races = await dbService.getQualifiedRaces();\n    const statuses = await dbService.getAdapterStatuses();\n    socket.emit('races_update', { races });\n    socket.emit('adapters_update', { adapters: statuses });\n  });\n});\n\n// Broadcast updates to all clients periodically\nasync function broadcastUpdates() {\n  try {\n    const races = await dbService.getQualifiedRaces();\n    const statuses = await dbService.getAdapterStatuses();\n\n    io.emit('races_update', { races });\n    io.emit('adapters_update', { adapters: statuses });\n  } catch (error) {\n    console.error('[ERROR] Failed to broadcast updates:', error);\n  }\n}\n\n// Start Server\nconst PORT = process.env.PORT || 8080;\n\nasync function startServer() {\n  try {\n    await dbService.connect();\n\n    httpServer.listen(PORT, () => {\n      console.log('='.repeat(70));\n      console.log(`  Checkmate API Gateway`);\n      console.log(`  Running on port ${PORT}`);\n      console.log(`  Database: ${dbService['dbPath']}`);\n      console.log('='.repeat(70));\n    });\n\n    setInterval(broadcastUpdates, 15000);\n\n  } catch (error) {\n    console.error('[FATAL] Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\n[INFO] Shutting down gracefully...');\n  httpServer.close();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.log('\\n[INFO] Shutting down gracefully...');\n  httpServer.close();\n  process.exit(0);\n});\n\nstartServer();",
    "web_platform/frontend/app/Providers.tsx": "// web_platform/frontend/app/Providers.tsx\n'use client';\n\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { queryClient } from '../src/lib/queryClient';\nimport React from 'react';\n\nexport default function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n}\n",
    "web_platform/frontend/src/components/LiveRaceDashboardNoSSR.tsx": "// web_platform/frontend/src/components/LiveRaceDashboardNoSSR.tsx\nimport dynamic from 'next/dynamic';\n\nconst LiveRaceDashboardNoSSR = dynamic(\n  () => import('./LiveRaceDashboard').then((mod) => mod.LiveRaceDashboard),\n  { ssr: false }\n);\n\nexport default LiveRaceDashboardNoSSR;\n",
    "web_platform/frontend/src/components/RaceFilters.tsx": "// web_platform/frontend/src/components/RaceFilters.tsx\n'use client';\n\nimport { useState, useCallback } from 'react';\nimport { Settings, RotateCcw } from 'lucide-react';\n\ninterface FilterParams {\n  maxFieldSize: number;\n  minFavoriteOdds: number;\n  minSecondFavoriteOdds: number;\n}\n\nexport interface RaceFiltersProps {\n  onParamsChange: (params: FilterParams) => void;\n  isLoading: boolean;\n  refetch: () => void;\n}\n\nconst DEFAULT_PARAMS: FilterParams = {\n  maxFieldSize: 10,\n  minFavoriteOdds: 2.5,\n  minSecondFavoriteOdds: 4.0,\n};\n\nexport function RaceFilters({ onParamsChange, isLoading, refetch }: RaceFiltersProps) {\n  const [params, setParams] = useState<FilterParams>(DEFAULT_PARAMS);\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  // Handle individual parameter changes\n  const handleChange = useCallback((key: keyof FilterParams, value: number) => {\n    setParams(prev => {\n      const updated = { ...prev, [key]: value };\n      onParamsChange(updated);\n      return updated;\n    });\n    // Debounce the refetch call\n    const timer = setTimeout(() => {\n      refetch();\n    }, 500);\n    return () => clearTimeout(timer);\n  }, [onParamsChange, refetch]);\n\n  // Reset to defaults\n  const handleReset = useCallback(() => {\n    setParams(DEFAULT_PARAMS);\n    onParamsChange(DEFAULT_PARAMS);\n    refetch();\n  }, [onParamsChange, refetch]);\n\n  return (\n    <div className=\"bg-gradient-to-r from-slate-800 to-slate-900 rounded-lg p-4 mb-6 border border-slate-700\">\n      <div className=\"flex items-center justify-between mb-4\">\n        <div className=\"flex items-center gap-2\">\n          <Settings className=\"w-5 h-5 text-amber-500\" />\n          <h3 className=\"text-lg font-semibold text-white\">Race Filters</h3>\n        </div>\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"text-sm text-slate-400 hover:text-slate-200 transition\"\n        >\n          {isExpanded ? 'Hide' : 'Show'}\n        </button>\n      </div>\n\n      {isExpanded && (\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 pt-4 border-t border-slate-700\">\n          {/* Max Field Size */}\n          <div className=\"space-y-2\">\n            <label className=\"block text-sm font-medium text-slate-300\">\n              Max Field Size\n              <span className=\"text-amber-500 ml-2\">{params.maxFieldSize}</span>\n            </label>\n            <input\n              type=\"range\"\n              min=\"2\"\n              max=\"20\"\n              value={params.maxFieldSize}\n              onChange={(e) => handleChange('maxFieldSize', parseInt(e.target.value))}\n              disabled={isLoading}\n              className=\"w-full accent-amber-500 cursor-pointer disabled:opacity-50\"\n            />\n            <p className=\"text-xs text-slate-500\">Filters races with larger fields</p>\n          </div>\n\n          {/* Min Favorite Odds */}\n          <div className=\"space-y-2\">\n            <label className=\"block text-sm font-medium text-slate-300\">\n              Min Favorite Odds\n              <span className=\"text-amber-500 ml-2\">{params.minFavoriteOdds.toFixed(2)}</span>\n            </label>\n            <input\n              type=\"range\"\n              min=\"1.5\"\n              max=\"5\"\n              step=\"0.1\"\n              value={params.minFavoriteOdds}\n              onChange={(e) => handleChange('minFavoriteOdds', parseFloat(e.target.value))}\n              disabled={isLoading}\n              className=\"w-full accent-amber-500 cursor-pointer disabled:opacity-50\"\n            />\n            <p className=\"text-xs text-slate-500\">Higher = pickier favorites</p>\n          </div>\n\n          {/* Min Second Favorite Odds */}\n          <div className=\"space-y-2\">\n            <label className=\"block text-sm font-medium text-slate-300\">\n              Min 2nd Favorite Odds\n              <span className=\"text-amber-500 ml-2\">{params.minSecondFavoriteOdds.toFixed(2)}</span>\n            </label>\n            <input\n              type=\"range\"\n              min=\"2.0\"\n              max=\"8\"\n              step=\"0.1\"\n              value={params.minSecondFavoriteOdds}\n              onChange={(e) => handleChange('minSecondFavoriteOdds', parseFloat(e.target.value))}\n              disabled={isLoading}\n              className=\"w-full accent-amber-500 cursor-pointer disabled:opacity-50\"\n            />\n            <p className=\"text-xs text-slate-500\">Higher = better odds separation</p>\n          </div>\n\n          {/* Reset Button */}\n          <div className=\"md:col-span-3 flex justify-end pt-4 border-t border-slate-700\">\n            <button\n              onClick={handleReset}\n              disabled={isLoading}\n              className=\"inline-flex items-center gap-2 px-4 py-2 bg-slate-700 hover:bg-slate-600 text-slate-200 rounded text-sm font-medium transition disabled:opacity-50\"\n            >\n              <RotateCcw className=\"w-4 h-4\" />\n              Reset to Defaults\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n",
    "web_platform/frontend/src/hooks/useWebSocket.ts": "// web_platform/frontend/src/hooks/useWebSocket.ts\n'use client';\n\nimport { useState, useEffect, useRef } from 'react';\n\ninterface WebSocketOptions {\n  apiKey: string | null;\n  port: number | null;\n}\n\nexport const useWebSocket = <T>(path: string, options: WebSocketOptions) => {\n  const [data, setData] = useState<T | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const webSocketRef = useRef<WebSocket | null>(null);\n\n  useEffect(() => {\n    console.log(\n      `[useWebSocket] useEffect triggered. Path: ${path}, API Key: ${options.apiKey}, Port: ${options.port}`,\n    );\n    if (!path || !options.apiKey || !options.port) {\n      console.log(\n        '[useWebSocket] Missing path, API key, or port. Aborting connection.',\n      );\n      if (webSocketRef.current) {\n        webSocketRef.current.close();\n      }\n      return;\n    }\n\n    const wsUrl = `ws://localhost:${options.port}${path}?api_key=${options.apiKey}`;\n    console.log(`[useWebSocket] Attempting to connect to: ${wsUrl}`);\n\n    const ws = new WebSocket(wsUrl);\n    webSocketRef.current = ws;\n\n    ws.onopen = () => {\n      console.log('WebSocket connection established.');\n      setIsConnected(true);\n    };\n\n    ws.onmessage = (event) => {\n      try {\n        const messageData = JSON.parse(event.data);\n        setData(messageData);\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    ws.onclose = (event) => {\n      console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n      setIsConnected(false);\n      webSocketRef.current = null;\n    };\n\n    return () => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n    };\n  }, [path, options.apiKey, options.port]);\n\n  return { data, isConnected };\n};\n",
    "web_platform/frontend/src/types/electron.d.ts": "// web_platform/frontend/src/types/electron.d.ts\n\n/**\n * This declaration file extends the global Window interface to include the\n * 'electronAPI' object exposed by the preload script. This provides\n * TypeScript with type information for the functions we're using for IPC.\n */\nexport {};\n\ndeclare global {\n  interface Window {\n    electronAPI?: {\n      /**\n       * Asynchronously fetches the secure API key from the main process.\n       * @returns {Promise<string|null>} A promise that resolves with the API key or null if not found.\n       */\n      getApiKey: () => Promise<string | null>;\n      /**\n       * Registers a callback for backend status updates from the main process.\n       * @param callback The function to execute. Receives an object with state and logs.\n       * @returns A function to unsubscribe the listener.\n       */\n      onBackendStatusUpdate: (callback: (status: { state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }) => void) => () => void;\n\n      /**\n       * Sends a command to the main process to restart the backend executable.\n       */\n      restartBackend: () => void;\n\n      /**\n       * Asynchronously fetches the current backend status from the main process.\n       * @returns {Promise<{ state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }>}\n       */\n      getBackendStatus: () => Promise<{ state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }>;\n      generateApiKey: () => Promise<string>;\n      saveApiKey: (apiKey: string) => Promise<{ success: boolean }>;\n      saveBetfairCredentials: (credentials: { appKey: string; username: string; password: string }) => Promise<{ success: boolean }>;\n      getApiPort: () => Promise<number | null>;\n    };\n  }\n}\n",
    "web_service/backend/adapters/base_adapter_v3.py": "# python_service/adapters/base_v3.py\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom typing import Any\nfrom typing import AsyncGenerator\nfrom typing import List\n\nimport httpx\nimport structlog\nfrom tenacity import RetryError\nfrom tenacity import retry\nfrom tenacity import stop_after_attempt\nfrom tenacity import wait_exponential\n\nfrom ..core.exceptions import AdapterHttpError\nfrom ..manual_override_manager import ManualOverrideManager\nfrom ..models import Race\n\n\nclass BaseAdapterV3(ABC):\n    \"\"\"\n    Abstract base class for all V3 data adapters.\n    Enforces a standardized fetch/parse pattern and includes robust request handling.\n    \"\"\"\n\n    def __init__(self, source_name: str, base_url: str, config=None, timeout: int = 20):\n        self.source_name = source_name\n        self.base_url = base_url\n        self.config = config\n        self.timeout = timeout\n        self.logger = structlog.get_logger(adapter_name=self.source_name)\n        self.http_client: httpx.AsyncClient = None  # Injected by the engine\n        self.manual_override_manager: ManualOverrideManager = None\n        self.supports_manual_override = True  # Can be overridden by subclasses\n\n    def enable_manual_override(self, manager: ManualOverrideManager):\n        \"\"\"Injects the manual override manager into the adapter.\"\"\"\n        self.manual_override_manager = manager\n\n    @abstractmethod\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"\n        Fetches the raw data (e.g., HTML, JSON) for the given date.\n        This is the only method that should perform network operations.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"\n        Parses the raw data retrieved by _fetch_data into a list of Race objects.\n        This method should be a pure function with no side effects.\n        \"\"\"\n        raise NotImplementedError\n\n    async def get_races(self, date: str) -> AsyncGenerator[Race, None]:\n        \"\"\"\n        Orchestrates the fetch-then-parse pipeline for the adapter.\n        This public method should not be overridden by subclasses.\n        \"\"\"\n        raw_data = None\n\n        if self.manual_override_manager:\n            # This is not a full URL, but a representative key for the fetch operation\n            # Subclasses might need to override get_races to provide a more specific URL if needed\n            lookup_key = f\"{self.base_url}/racecards/{date}\"\n            manual_data = self.manual_override_manager.get_manual_data(self.source_name, lookup_key)\n            if manual_data:\n                self.logger.info(\"Using manually submitted data for request\", url=lookup_key)\n                # Reconstruct a dictionary similar to what _fetch_data would return\n                # This may need adjustment based on adapter specifics\n                raw_data = {\"pages\": [manual_data[0]], \"date\": date}\n\n        if raw_data is None:\n            try:\n                raw_data = await self._fetch_data(date)\n            except AdapterHttpError as e:\n                if self.manual_override_manager and self.supports_manual_override:\n                    self.manual_override_manager.register_failure(self.source_name, e.url)\n                raise  # Reraise the exception to be handled by the OddsEngine\n\n        if raw_data is not None:\n            parsed_races = self._parse_races(raw_data)\n            for race in parsed_races:\n                yield race\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=2, max=10),\n        stop=stop_after_attempt(3),\n        reraise=True,  # Reraise the final exception to be caught by get_races\n    )\n    async def make_request(self, http_client: httpx.AsyncClient, method: str, url: str, **kwargs) -> httpx.Response:\n        \"\"\"\n        Makes a resilient HTTP request with built-in retry logic using tenacity.\n        \"\"\"\n        # Ensure the URL is correctly formed, whether it's relative or absolute\n        full_url = url if url.startswith(\"http\") else f\"{self.base_url.rstrip('/')}/{url.lstrip('/')}\"\n\n        try:\n            self.logger.info(\"Making request\", method=method.upper(), url=full_url)\n            response = await http_client.request(method, full_url, timeout=self.timeout, **kwargs)\n            response.raise_for_status()  # Raise an exception for 4xx/5xx responses\n            return response\n        except httpx.HTTPStatusError as e:\n            self.logger.error(\n                \"HTTP Status Error during request\",\n                status_code=e.response.status_code,\n                url=str(e.request.url),\n            )\n            raise AdapterHttpError(\n                adapter_name=self.source_name,\n                status_code=e.response.status_code,\n                url=str(e.request.url),\n            ) from e\n        except (httpx.RequestError, RetryError) as e:\n            self.logger.error(\"Request Error or Retry Error\", error=str(e))\n            raise AdapterHttpError(\n                adapter_name=self.source_name,\n                status_code=503,  # Service Unavailable\n                url=full_url,\n            ) from e\n\n    def get_status(self) -> dict:\n        \"\"\"\n        Returns a dictionary representing the adapter's current status.\n        Subclasses can extend this to include more specific health checks.\n        \"\"\"\n        return {\n            \"adapter_name\": self.source_name,\n            \"status\": \"OK\",  # Basic status; can be enhanced in subclasses\n        }\n",
    "web_service/backend/adapters/betfair_datascientist_adapter.py": "# python_service/adapters/betfair_datascientist_adapter.py\n\nfrom datetime import datetime\nfrom io import StringIO\nfrom typing import List\nfrom typing import Optional\n\nimport pandas as pd\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.text import normalize_venue_name\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass BetfairDataScientistAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for the Betfair Data Scientist CSV models, migrated to BaseAdapterV3.\n    \"\"\"\n\n    ADAPTER_NAME = \"BetfairDataScientist\"\n\n    def __init__(self, model_name: str, url: str, config=None):\n        source_name = f\"{self.ADAPTER_NAME}_{model_name}\"\n        super().__init__(source_name=source_name, base_url=url, config=config)\n        self.model_name = model_name\n\n    async def _fetch_data(self, date: str) -> Optional[StringIO]:\n        \"\"\"Fetches the raw CSV data from the Betfair Data Scientist model endpoint.\"\"\"\n        endpoint = f\"?date={date}&presenter=RatingsPresenter&csv=true\"\n        self.logger.info(f\"Fetching data from {self.base_url}{endpoint}\")\n        response = await self.make_request(self.http_client, \"GET\", endpoint)\n        return StringIO(response.text) if response and response.text else None\n\n    def _parse_races(self, raw_data: Optional[StringIO]) -> List[Race]:\n        \"\"\"Parses the raw CSV data into a list of Race objects.\"\"\"\n        if not raw_data:\n            return []\n        try:\n            df = pd.read_csv(raw_data)\n            if df.empty:\n                self.logger.warning(\"Received empty CSV from Betfair Data Scientist.\")\n                return []\n\n            df = df.rename(\n                columns={\n                    \"meetings.races.bfExchangeMarketId\": \"market_id\",\n                    \"meetings.races.runners.bfExchangeSelectionId\": \"selection_id\",\n                    \"meetings.races.runners.ratedPrice\": \"rated_price\",\n                    \"meetings.races.raceName\": \"race_name\",\n                    \"meetings.name\": \"meeting_name\",\n                    \"meetings.races.raceNumber\": \"race_number\",\n                    \"meetings.races.runners.runnerName\": \"runner_name\",\n                    \"meetings.races.runners.clothNumber\": \"saddle_cloth\",\n                }\n            )\n            races: List[Race] = []\n            for market_id, group in df.groupby(\"market_id\"):\n                race_info = group.iloc[0]\n                runners = []\n                for _, row in group.iterrows():\n                    rated_price = row.get(\"rated_price\")\n                    odds_data = {}\n                    if pd.notna(rated_price):\n                        odds_data[self.source_name] = OddsData(\n                            win=float(rated_price),\n                            source=self.source_name,\n                            last_updated=datetime.now(),\n                        )\n\n                    runners.append(\n                        Runner(\n                            name=str(row.get(\"runner_name\", \"Unknown\")),\n                            number=int(row.get(\"saddle_cloth\", 0)),\n                            odds=odds_data,\n                        )\n                    )\n\n                race = Race(\n                    id=str(market_id),\n                    venue=normalize_venue_name(str(race_info.get(\"meeting_name\", \"\"))),\n                    race_number=int(race_info.get(\"race_number\", 0)),\n                    start_time=datetime.now(),  # Placeholder, not provided in source\n                    runners=runners,\n                    source=self.source_name,\n                )\n                races.append(race)\n            self.logger.info(f\"Normalized {len(races)} races from {self.model_name}.\")\n            return races\n        except (pd.errors.ParserError, KeyError) as e:\n            self.logger.error(\n                \"Failed to parse Betfair Data Scientist CSV.\",\n                exc_info=True,\n                error=str(e),\n            )\n            return []\n",
    "web_service/backend/adapters/betfair_greyhound_adapter.py": "# python_service/adapters/betfair_greyhound_adapter.py\nimport re\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base_adapter_v3 import BaseAdapterV3\nfrom .betfair_auth_mixin import BetfairAuthMixin\n\n\nclass BetfairGreyhoundAdapter(BetfairAuthMixin, BaseAdapterV3):\n    \"\"\"Adapter for fetching greyhound racing data from the Betfair Exchange API, using V3 architecture.\"\"\"\n\n    SOURCE_NAME = \"BetfairGreyhounds\"\n    BASE_URL = \"https://api.betfair.com/exchange/betting/rest/v1.0/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"Fetches the raw market catalogue for greyhound races on a given date.\"\"\"\n        await self._authenticate(self.http_client)\n        if not self.session_token:\n            self.logger.error(\"Authentication failed, cannot fetch data.\")\n            return None\n\n        start_time, end_time = self._get_datetime_range(date)\n\n        response = await self.make_request(\n            self.http_client,\n            method=\"post\",\n            url=f\"{self.BASE_URL}listMarketCatalogue/\",\n            json={\n                \"filter\": {\n                    \"eventTypeIds\": [\"4339\"],  # Greyhound Racing\n                    \"marketCountries\": [\"GB\", \"IE\", \"AU\"],\n                    \"marketTypeCodes\": [\"WIN\"],\n                    \"marketStartTime\": {\n                        \"from\": start_time.isoformat(),\n                        \"to\": end_time.isoformat(),\n                    },\n                },\n                \"maxResults\": 1000,\n                \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"],\n            },\n        )\n        return response.json() if response else None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses the raw market catalogue into a list of Race objects.\"\"\"\n        if not raw_data:\n            return []\n\n        races = []\n        for market in raw_data:\n            try:\n                if race := self._parse_race(market):\n                    races.append(race)\n            except (KeyError, TypeError):\n                self.logger.warning(\n                    \"Failed to parse a Betfair Greyhound market.\",\n                    exc_info=True,\n                    market=market,\n                )\n                continue\n        return races\n\n    def _parse_race(self, market: dict) -> Optional[Race]:\n        \"\"\"Parses a single market from the Betfair API into a Race object.\"\"\"\n        market_id = market.get(\"marketId\")\n        event = market.get(\"event\", {})\n        market_start_time = market.get(\"marketStartTime\")\n\n        if not all([market_id, market_start_time]):\n            return None\n\n        start_time = datetime.fromisoformat(market_start_time.replace(\"Z\", \"+00:00\"))\n\n        runners = [\n            Runner(\n                number=runner.get(\"sortPriority\", i + 1),\n                name=runner.get(\"runnerName\"),\n                scratched=runner.get(\"status\") != \"ACTIVE\",\n                selection_id=runner.get(\"selectionId\"),\n            )\n            for i, runner in enumerate(market.get(\"runners\", []))\n            if runner.get(\"runnerName\")\n        ]\n\n        return Race(\n            id=f\"bfg_{market_id}\",\n            venue=event.get(\"venue\", \"Unknown Venue\"),\n            race_number=self._extract_race_number(market.get(\"marketName\", \"\")),\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n\n    def _extract_race_number(self, name: str) -> int:\n        \"\"\"Extracts the race number from a market name (e.g., 'R1 480m').\"\"\"\n        match = re.search(r\"\\bR(\\d{1,2})\\b\", name)\n        return int(match.group(1)) if match else 0\n\n    def _get_datetime_range(self, date_str: str):\n        # Helper to create a datetime range for the Betfair API\n        start_time = datetime.strptime(date_str, \"%Y-%m-%d\")\n        end_time = start_time + timedelta(days=1)\n        return start_time, end_time\n",
    "web_service/backend/adapters/harness_adapter.py": "# python_service/adapters/harness_adapter.py\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom zoneinfo import ZoneInfo\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass HarnessAdapter(BaseAdapterV3):\n    \"\"\"Adapter for fetching US harness racing data with manual override support.\"\"\"\n\n    SOURCE_NAME = \"USTrotting\"\n    BASE_URL = \"https://data.ustrotting.com/api/racenet/racing/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetches all harness races for a given date.\"\"\"\n        response = await self.make_request(self.http_client, \"GET\", f\"card/{date}\")\n\n        if not response:\n            return None\n\n        card_data = response.json()\n        return {\"data\": card_data, \"date\": date}\n\n    def _parse_races(self, raw_data: Optional[Dict[str, Any]]) -> List[Race]:\n        \"\"\"Parses the raw card data into a list of Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"data\") or not raw_data.get(\"data\", {}).get(\"meetings\"):\n            self.logger.warning(\"No meetings found in harness data response.\")\n            return []\n\n        all_races = []\n        date = raw_data.get(\"date\")\n        for meeting in raw_data.get(\"data\", {}).get(\"meetings\", []):\n            track_name = meeting.get(\"track\", {}).get(\"name\")\n            for race_data in meeting.get(\"races\", []):\n                try:\n                    if race := self._parse_race(race_data, track_name, date):\n                        all_races.append(race)\n                except Exception:\n                    self.logger.warning(\n                        \"Failed to parse harness race, skipping.\",\n                        race_data=race_data,\n                        exc_info=True,\n                    )\n                    continue\n        return all_races\n\n    def _parse_race(self, race_data: dict, track_name: str, date: str) -> Optional[Race]:\n        \"\"\"Parses a single race from the USTA API into a Race object.\"\"\"\n        race_number = race_data.get(\"raceNumber\")\n        post_time_str = race_data.get(\"postTime\")\n        if not all([race_number, post_time_str]):\n            return None\n\n        start_time = self._parse_post_time(date, post_time_str)\n\n        runners = []\n        for runner_data in race_data.get(\"runners\", []):\n            if runner_data.get(\"scratched\", False):\n                continue\n\n            odds_str = runner_data.get(\"morningLineOdds\", \"\")\n            if \"/\" not in odds_str and odds_str.isdigit():\n                odds_str = f\"{odds_str}/1\"\n\n            odds = {}\n            win_odds = parse_odds_to_decimal(odds_str)\n            if win_odds and win_odds < 999:\n                odds = {\n                    self.SOURCE_NAME: OddsData(\n                        win=win_odds,\n                        source=self.SOURCE_NAME,\n                        last_updated=datetime.now(),\n                    )\n                }\n\n            runners.append(\n                Runner(\n                    number=runner_data.get(\"postPosition\", 0),\n                    name=runner_data.get(\"horse\", {}).get(\"name\", \"Unknown Horse\"),\n                    odds=odds,\n                    scratched=False,\n                )\n            )\n\n        if not runners:\n            return None\n\n        return Race(\n            id=f\"ust_{track_name.lower().replace(' ', '')}_{date}_{race_number}\",\n            venue=track_name,\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n            source=self.SOURCE_NAME,\n        )\n\n    def _parse_post_time(self, date: str, post_time: str) -> datetime:\n        \"\"\"Parses a time string like '07:00 PM' into a timezone-aware datetime object.\"\"\"\n        dt_str = f\"{date} {post_time}\"\n        naive_dt = datetime.strptime(dt_str, \"%Y-%m-%d %I:%M %p\")\n        # Assume Eastern Time for USTA data, a common standard for US racing.\n        eastern = ZoneInfo(\"America/New_York\")\n        return naive_dt.replace(tzinfo=eastern)\n",
    "web_service/backend/adapters/oddschecker_adapter.py": "# python_service/adapters/oddschecker_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass OddscheckerAdapter(BaseAdapterV3):\n    \"\"\"Adapter for scraping horse racing odds from Oddschecker, migrated to BaseAdapterV3.\"\"\"\n\n    SOURCE_NAME = \"Oddschecker\"\n    BASE_URL = \"https://www.oddschecker.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"\n        Fetches the raw HTML for all race pages for a given date. This involves a multi-level fetch.\n        \"\"\"\n        # Note: Oddschecker doesn't seem to support historical dates well in its main nav,\n        # but we build the URL as if it does for future compatibility.\n        index_url = f\"/horse-racing/{date}\"\n        index_response = await self.make_request(self.http_client, \"GET\", index_url)\n        if not index_response:\n            self.logger.warning(\"Failed to fetch Oddschecker index page\", url=index_url)\n            return None\n\n        index_soup = BeautifulSoup(index_response.text, \"html.parser\")\n        # Find all links to individual race pages\n        race_links = {a[\"href\"] for a in index_soup.select(\"a.race-time-link[href]\")}\n\n        async def fetch_single_html(url_path: str):\n            response = await self.make_request(self.http_client, \"GET\", url_path)\n            return response.text if response else \"\"\n\n        tasks = [fetch_single_html(link) for link in race_links]\n        html_pages = await asyncio.gather(*tasks)\n        return {\"pages\": html_pages, \"date\": date}\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of raw HTML strings from different races into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"pages\"):\n            return []\n\n        try:\n            race_date = datetime.strptime(raw_data[\"date\"], \"%Y-%m-%d\").date()\n        except ValueError:\n            self.logger.error(\n                \"Invalid date format provided to OddscheckerAdapter\",\n                date=raw_data.get(\"date\"),\n            )\n            return []\n\n        all_races = []\n        for html in raw_data[\"pages\"]:\n            if not html:\n                continue\n            try:\n                soup = BeautifulSoup(html, \"html.parser\")\n                race = self._parse_race_page(soup, race_date)\n                if race:\n                    all_races.append(race)\n            except (AttributeError, IndexError, ValueError):\n                self.logger.warning(\n                    \"Error parsing a race from Oddschecker, skipping race.\",\n                    exc_info=True,\n                )\n                continue\n        return all_races\n\n    def _parse_race_page(self, soup: BeautifulSoup, race_date) -> Optional[Race]:\n        track_name_node = soup.select_one(\"h1.meeting-name\")\n        if not track_name_node:\n            return None\n        track_name = track_name_node.get_text(strip=True)\n\n        race_time_node = soup.select_one(\"span.race-time\")\n        if not race_time_node:\n            return None\n        race_time_str = race_time_node.get_text(strip=True)\n\n        # Heuristic to find race number from navigation\n        active_link = soup.select_one(\"a.race-time-link.active\")\n        race_number = 1\n        if active_link:\n            all_links = soup.select(\"a.race-time-link\")\n            try:\n                race_number = all_links.index(active_link) + 1\n            except ValueError:\n                pass  # Keep default race number if active link not in all links\n\n        start_time = datetime.combine(race_date, datetime.strptime(race_time_str, \"%H:%M\").time())\n        runners = [runner for row in soup.select(\"tr.race-card-row\") if (runner := self._parse_runner_row(row))]\n\n        if not runners:\n            return None\n\n        return Race(\n            id=f\"oc_{track_name.lower().replace(' ', '')}_{start_time.strftime('%Y%m%d')}_r{race_number}\",\n            venue=track_name,\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n\n    def _parse_runner_row(self, row: Tag) -> Optional[Runner]:\n        try:\n            name_node = row.select_one(\"span.selection-name\")\n            if not name_node:\n                return None\n            name = name_node.get_text(strip=True)\n\n            odds_node = row.select_one(\"span.bet-button-odds-desktop, span.best-price\")\n            if not odds_node:\n                return None\n            odds_str = odds_node.get_text(strip=True)\n\n            number_node = row.select_one(\"td.runner-number\")\n            if not number_node or not number_node.get_text(strip=True).isdigit():\n                return None\n            number = int(number_node.get_text(strip=True))\n\n            if not name or not odds_str:\n                return None\n\n            win_odds = parse_odds_to_decimal(odds_str)\n            odds_dict = {}\n            if win_odds and win_odds < 999:\n                odds_dict[self.source_name] = OddsData(\n                    win=win_odds, source=self.source_name, last_updated=datetime.now()\n                )\n\n            return Runner(number=number, name=name, odds=odds_dict)\n        except (AttributeError, ValueError):\n            self.logger.warning(\"Failed to parse a runner on Oddschecker, skipping runner.\")\n            return None\n",
    "web_service/backend/adapters/racingpost_adapter.py": "# python_service/adapters/racingpost_adapter.py\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom selectolax.parser import HTMLParser\nfrom selectolax.parser import Node\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom ..utils.text import normalize_venue_name\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass RacingPostAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for scraping Racing Post racecards, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"RacingPost\"\n    BASE_URL = \"https://www.racingpost.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"\n        Fetches the raw HTML content for all races on a given date.\n        \"\"\"\n        index_url = f\"/racecards/{date}\"\n        index_response = await self.make_request(self.http_client, \"GET\", index_url, headers=self._get_headers())\n        if not index_response:\n            self.logger.warning(\"Failed to fetch RacingPost index page\", url=index_url)\n            return None\n\n        index_parser = HTMLParser(index_response.text)\n        links = index_parser.css('a[data-test-selector^=\"RC-meetingItem__link_race\"]')\n        race_card_urls = [link.attributes[\"href\"] for link in links]\n\n        async def fetch_single_html(url: str):\n            response = await self.make_request(self.http_client, \"GET\", url, headers=self._get_headers())\n            return response.text if response else \"\"\n\n        tasks = [fetch_single_html(url) for url in race_card_urls]\n        html_contents = await asyncio.gather(*tasks)\n        return {\"date\": date, \"html_contents\": html_contents}\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of raw HTML strings into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"html_contents\"):\n            return []\n\n        date = raw_data[\"date\"]\n        html_contents = raw_data[\"html_contents\"]\n        all_races: List[Race] = []\n\n        for html in html_contents:\n            if not html:\n                continue\n            try:\n                parser = HTMLParser(html)\n\n                venue_node = parser.css_first('a[data-test-selector=\"RC-course__name\"]')\n                if not venue_node:\n                    continue\n                venue_raw = venue_node.text(strip=True)\n                venue = normalize_venue_name(venue_raw)\n\n                race_time_node = parser.css_first('span[data-test-selector=\"RC-course__time\"]')\n                if not race_time_node:\n                    continue\n                race_time_str = race_time_node.text(strip=True)\n\n                race_datetime_str = f\"{date} {race_time_str}\"\n                start_time = datetime.strptime(race_datetime_str, \"%Y-%m-%d %H:%M\")\n\n                runners = self._parse_runners(parser)\n\n                if venue and runners:\n                    race_number = self._get_race_number(parser, start_time)\n                    race = Race(\n                        id=f\"rp_{venue.lower().replace(' ', '')}_{date}_{race_number}\",\n                        venue=venue,\n                        race_number=race_number,\n                        start_time=start_time,\n                        runners=runners,\n                        source=self.source_name,\n                    )\n                    all_races.append(race)\n            except (AttributeError, ValueError):\n                self.logger.error(\"Failed to parse RacingPost race from HTML content.\", exc_info=True)\n                continue\n        return all_races\n\n    def _get_race_number(self, parser: HTMLParser, start_time: datetime) -> int:\n        \"\"\"Derives the race number by finding the active time in the nav bar.\"\"\"\n        time_str_to_find = start_time.strftime(\"%H:%M\")\n        time_links = parser.css('a[data-test-selector=\"RC-raceTime\"]')\n        for i, link in enumerate(time_links):\n            if link.text(strip=True) == time_str_to_find:\n                return i + 1\n        return 1\n\n    def _parse_runners(self, parser: HTMLParser) -> list[Runner]:\n        \"\"\"Parses all runners from a single race card page.\"\"\"\n        runners = []\n        runner_nodes = parser.css('div[data-test-selector=\"RC-runnerCard\"]')\n        for node in runner_nodes:\n            if runner := self._parse_runner(node):\n                runners.append(runner)\n        return runners\n\n    def _parse_runner(self, node: Node) -> Optional[Runner]:\n        try:\n            number_node = node.css_first('span[data-test-selector=\"RC-runnerNumber\"]')\n            name_node = node.css_first('a[data-test-selector=\"RC-runnerName\"]')\n            odds_node = node.css_first('span[data-test-selector=\"RC-runnerPrice\"]')\n\n            if not all([number_node, name_node, odds_node]):\n                return None\n\n            number_str = clean_text(number_node.text())\n            number = int(number_str) if number_str and number_str.isdigit() else 0\n            name = clean_text(name_node.text())\n            odds_str = clean_text(odds_node.text())\n            scratched = \"NR\" in odds_str.upper() or not odds_str\n\n            odds = {}\n            if not scratched:\n                win_odds = parse_odds_to_decimal(odds_str)\n                if win_odds and win_odds < 999:\n                    odds = {\n                        self.source_name: OddsData(\n                            win=win_odds,\n                            source=self.source_name,\n                            last_updated=datetime.now(),\n                        )\n                    }\n\n            return Runner(number=number, name=name, odds=odds, scratched=scratched)\n        except (ValueError, AttributeError):\n            self.logger.warning(\"Could not parse RacingPost runner, skipping.\", exc_info=True)\n            return None\n\n    def _get_headers(self) -> dict:\n        return {\n            \"User-Agent\": (\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                \"Chrome/107.0.0.0 Safari/537.36\"\n            )\n        }\n",
    "web_service/backend/adapters/the_racing_api_adapter.py": "# python_service/adapters/the_racing_api_adapter.py\n\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nfrom ..core.exceptions import AdapterConfigError\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass TheRacingApiAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for The Racing API, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"TheRacingAPI\"\n    BASE_URL = \"https://api.theracingapi.com/v1/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n        if not hasattr(config, \"THE_RACING_API_KEY\") or not config.THE_RACING_API_KEY:\n            raise AdapterConfigError(self.source_name, \"THE_RACING_API_KEY is not configured.\")\n        self.api_key = config.THE_RACING_API_KEY\n\n    async def _fetch_data(self, date: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetches the raw racecard data from The Racing API.\"\"\"\n        endpoint = f\"racecards?date={date}&course=all&region=gb,ire\"\n        headers = {\"Authorization\": f\"Bearer {self.api_key}\"}\n        response = await self.make_request(self.http_client, \"GET\", endpoint, headers=headers)\n        return response.json() if response else None\n\n    def _parse_races(self, raw_data: Optional[Dict[str, Any]]) -> List[Race]:\n        \"\"\"Parses the raw JSON response into a list of Race objects.\"\"\"\n        if not raw_data or \"racecards\" not in raw_data:\n            self.logger.warning(\"'racecards' key missing in TheRacingAPI response.\")\n            return []\n\n        races = []\n        for race_data in raw_data.get(\"racecards\", []):\n            try:\n                race_id = race_data.get(\"race_id\")\n                off_time = race_data.get(\"off_time\")\n                course = race_data.get(\"course\")\n                race_no = race_data.get(\"race_no\")\n\n                if not all([race_id, off_time, course, race_no]):\n                    continue\n\n                start_time = datetime.fromisoformat(off_time.replace(\"Z\", \"+00:00\"))\n\n                race = Race(\n                    id=f\"tra_{race_id}\",\n                    venue=course,\n                    race_number=race_no,\n                    start_time=start_time,\n                    runners=self._parse_runners(race_data.get(\"runners\", [])),\n                    source=self.source_name,\n                    race_name=race_data.get(\"race_name\"),\n                    distance=race_data.get(\"distance_f\"),\n                )\n                races.append(race)\n            except Exception:\n                self.logger.error(\n                    \"Error parsing TheRacingAPI race\",\n                    race_id=race_data.get(\"race_id\"),\n                    exc_info=True,\n                )\n        return races\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]]) -> List[Runner]:\n        runners = []\n        for i, runner_data in enumerate(runners_data):\n            try:\n                horse = runner_data.get(\"horse\")\n                if not horse:\n                    continue\n\n                odds_data = {}\n                odds_list = runner_data.get(\"odds\", [])\n                if odds_list:\n                    odds_decimal_str = odds_list[0].get(\"odds_decimal\")\n                    if odds_decimal_str:\n                        win_odds = Decimal(str(odds_decimal_str))\n                        odds_data[self.source_name] = OddsData(\n                            win=win_odds,\n                            source=self.source_name,\n                            last_updated=datetime.now(),\n                        )\n\n                runners.append(\n                    Runner(\n                        number=runner_data.get(\"number\", i + 1),\n                        name=horse,\n                        odds=odds_data,\n                        jockey=runner_data.get(\"jockey\"),\n                        trainer=runner_data.get(\"trainer\"),\n                    )\n                )\n            except Exception:\n                self.logger.error(\n                    \"Error parsing TheRacingAPI runner\",\n                    runner_name=runner_data.get(\"horse\"),\n                    exc_info=True,\n                )\n        return runners\n",
    "web_service/backend/adapters/timeform_adapter.py": "# python_service/adapters/timeform_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass TimeformAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for timeform.com, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"Timeform\"\n    BASE_URL = \"https://www.timeform.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"\n        Fetches the raw HTML for all race pages for a given date.\n        \"\"\"\n        index_url = f\"/horse-racing/racecards/{date}\"\n        index_response = await self.make_request(self.http_client, \"GET\", index_url)\n        if not index_response:\n            self.logger.warning(\"Failed to fetch Timeform index page\", url=index_url)\n            return None\n\n        index_soup = BeautifulSoup(index_response.text, \"html.parser\")\n        links = {a[\"href\"] for a in index_soup.select(\"a.rp-racecard-off-link[href]\")}\n\n        async def fetch_single_html(url_path: str):\n            response = await self.make_request(self.http_client, \"GET\", url_path)\n            return response.text if response else \"\"\n\n        tasks = [fetch_single_html(link) for link in links]\n        html_pages = await asyncio.gather(*tasks)\n        return {\"pages\": html_pages, \"date\": date}\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of raw HTML strings into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"pages\"):\n            return []\n\n        try:\n            race_date = datetime.strptime(raw_data[\"date\"], \"%Y-%m-%d\").date()\n        except ValueError:\n            self.logger.error(\n                \"Invalid date format provided to TimeformAdapter\",\n                date=raw_data.get(\"date\"),\n            )\n            return []\n\n        all_races = []\n        for html in raw_data[\"pages\"]:\n            if not html:\n                continue\n            try:\n                soup = BeautifulSoup(html, \"html.parser\")\n\n                track_name_node = soup.select_one(\"h1.rp-raceTimeCourseName_name\")\n                if not track_name_node:\n                    continue\n                track_name = clean_text(track_name_node.get_text())\n\n                race_time_node = soup.select_one(\"span.rp-raceTimeCourseName_time\")\n                if not race_time_node:\n                    continue\n                race_time_str = clean_text(race_time_node.get_text())\n\n                start_time = datetime.combine(race_date, datetime.strptime(race_time_str, \"%H:%M\").time())\n\n                all_times = [clean_text(a.get_text()) for a in soup.select(\"a.rp-racecard-off-link\")]\n                race_number = all_times.index(race_time_str) + 1 if race_time_str in all_times else 1\n\n                runner_rows = soup.select(\"div.rp-horseTable_mainRow\")\n                if not runner_rows:\n                    continue\n\n                runners = [self._parse_runner(row) for row in runner_rows]\n                race = Race(\n                    id=f\"tf_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\",\n                    venue=track_name,\n                    race_number=race_number,\n                    start_time=start_time,\n                    runners=[r for r in runners if r],  # Filter out None values\n                    source=self.source_name,\n                )\n                all_races.append(race)\n            except (AttributeError, ValueError, TypeError):\n                self.logger.warning(\"Error parsing a race from Timeform, skipping race.\", exc_info=True)\n                continue\n        return all_races\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name_node = row.select_one(\"a.rp-horseTable_horse-name\")\n            if not name_node:\n                return None\n            name = clean_text(name_node.get_text())\n\n            num_node = row.select_one(\"span.rp-horseTable_horse-number\")\n            if not num_node:\n                return None\n            num_str = clean_text(num_node.get_text())\n            number_part = \"\".join(filter(str.isdigit, num_str.strip(\"()\")))\n            number = int(number_part)\n\n            odds_data = {}\n            if odds_tag := row.select_one(\"button.rp-bet-placer-btn__odds\"):\n                odds_str = clean_text(odds_tag.get_text())\n                if win_odds := parse_odds_to_decimal(odds_str):\n                    if win_odds < 999:\n                        odds_data = {\n                            self.source_name: OddsData(\n                                win=win_odds,\n                                source=self.source_name,\n                                last_updated=datetime.now(),\n                            )\n                        }\n\n            return Runner(number=number, name=name, odds=odds_data)\n        except (AttributeError, ValueError, TypeError):\n            self.logger.warning(\"Failed to parse a runner from Timeform, skipping runner.\")\n            return None\n",
    "web_service/backend/adapters/xpressbet_adapter.py": "# python_service/adapters/xpressbet_adapter.py\nfrom typing import Any\nfrom typing import List\n\nfrom ..models import Race\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass XpressbetAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for xpressbet.com.\n    This adapter is a non-functional stub and has not been implemented.\n    \"\"\"\n\n    SOURCE_NAME = \"Xpressbet\"\n    BASE_URL = \"https://www.xpressbet.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"This is a stub and does not fetch any data.\"\"\"\n        self.logger.warning(\n            f\"{self.source_name} is a non-functional stub and has not been implemented. It will not fetch any data.\"\n        )\n        return None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"This is a stub and does not parse any data.\"\"\"\n        return []\n",
    "web_service/backend/analyzer.py": "from abc import ABC\nfrom abc import abstractmethod\nfrom decimal import Decimal\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Type\n\nimport structlog\n\nfrom python_service.models import Race\nfrom python_service.models import Runner\n\ntry:\n    # winsound is a built-in Windows library\n    import winsound\nexcept ImportError:\n    winsound = None\ntry:\n    from win10toast_py3 import ToastNotifier\nexcept (ImportError, RuntimeError):\n    # Fails gracefully on non-Windows systems\n    ToastNotifier = None\n\nlog = structlog.get_logger(__name__)\n\n\ndef _get_best_win_odds(runner: Runner) -> Optional[Decimal]:\n    \"\"\"Gets the best win odds for a runner, filtering out invalid or placeholder values.\"\"\"\n    if not runner.odds:\n        return None\n\n    # Filter out invalid or placeholder odds (e.g., > 999)\n    valid_odds = [o.win for o in runner.odds.values() if o.win is not None and o.win > 0 and o.win < 999]\n\n    if not valid_odds:\n        return None\n\n    return min(valid_odds)\n\n\nclass BaseAnalyzer(ABC):\n    \"\"\"The abstract interface for all future analyzer plugins.\"\"\"\n\n    def __init__(self, **kwargs):\n        pass\n\n    @abstractmethod\n    def qualify_races(self, races: List[Race]) -> Dict[str, Any]:\n        \"\"\"The core method every analyzer must implement.\"\"\"\n        pass\n\n\nclass TrifectaAnalyzer(BaseAnalyzer):\n    \"\"\"Analyzes races and assigns a qualification score based on the 'Trifecta of Factors'.\"\"\"\n\n    @property\n    def name(self) -> str:\n        return \"trifecta_analyzer\"\n\n    def __init__(\n        self,\n        max_field_size: int = 10,\n        min_favorite_odds: float = 2.5,\n        min_second_favorite_odds: float = 4.0,\n    ):\n        self.max_field_size = max_field_size\n        self.min_favorite_odds = Decimal(str(min_favorite_odds))\n        self.min_second_favorite_odds = Decimal(str(min_second_favorite_odds))\n        self.notifier = RaceNotifier()\n\n    def is_race_qualified(self, race: Race) -> bool:\n        \"\"\"A race is qualified for a trifecta if it has at least 3 non-scratched runners.\"\"\"\n        if not race or not race.runners:\n            return False\n\n        active_runners = sum(1 for r in race.runners if not r.scratched)\n        return active_runners >= 3\n\n    def qualify_races(self, races: List[Race]) -> Dict[str, Any]:\n        \"\"\"Scores all races and returns a dictionary with criteria and a sorted list.\"\"\"\n        qualified_races = []\n        for race in races:\n            score = self._evaluate_race(race)\n            if score > 0:\n                race.qualification_score = score\n                qualified_races.append(race)\n\n        qualified_races.sort(key=lambda r: r.qualification_score, reverse=True)\n\n        criteria = {\n            \"max_field_size\": self.max_field_size,\n            \"min_favorite_odds\": float(self.min_favorite_odds),\n            \"min_second_favorite_odds\": float(self.min_second_favorite_odds),\n        }\n\n        log.info(\n            \"Universal scoring complete\",\n            total_races_scored=len(qualified_races),\n            criteria=criteria,\n        )\n\n        for race in qualified_races:\n            if race.qualification_score and race.qualification_score >= 85:\n                self.notifier.notify_qualified_race(race)\n\n        return {\"criteria\": criteria, \"races\": qualified_races}\n\n    def _evaluate_race(self, race: Race) -> float:\n        \"\"\"Evaluates a single race and returns a qualification score.\"\"\"\n        # --- Constants for Scoring Logic ---\n        FAV_ODDS_NORMALIZATION = 10.0\n        SEC_FAV_ODDS_NORMALIZATION = 15.0\n        FAV_ODDS_WEIGHT = 0.6\n        SEC_FAV_ODDS_WEIGHT = 0.4\n        FIELD_SIZE_SCORE_WEIGHT = 0.3\n        ODDS_SCORE_WEIGHT = 0.7\n\n        active_runners = [r for r in race.runners if not r.scratched]\n\n        runners_with_odds = []\n        for runner in active_runners:\n            best_odds = _get_best_win_odds(runner)\n            if best_odds is not None:\n                runners_with_odds.append((runner, best_odds))\n\n        if len(runners_with_odds) < 2:\n            return 0.0\n\n        runners_with_odds.sort(key=lambda x: x[1])\n        favorite_odds = runners_with_odds[0][1]\n        second_favorite_odds = runners_with_odds[1][1]\n\n        # --- Calculate Qualification Score (as inspired by the TypeScript Genesis) ---\n        field_score = (self.max_field_size - len(active_runners)) / self.max_field_size\n\n        # Normalize odds scores - cap influence of extremely high odds\n        fav_odds_score = min(float(favorite_odds) / FAV_ODDS_NORMALIZATION, 1.0)\n        sec_fav_odds_score = min(float(second_favorite_odds) / SEC_FAV_ODDS_NORMALIZATION, 1.0)\n\n        # Weighted average\n        odds_score = (fav_odds_score * FAV_ODDS_WEIGHT) + (sec_fav_odds_score * SEC_FAV_ODDS_WEIGHT)\n        final_score = (field_score * FIELD_SIZE_SCORE_WEIGHT) + (odds_score * ODDS_SCORE_WEIGHT)\n\n        # --- Apply a penalty if hard filters are not met, instead of returning None ---\n        if (\n            len(active_runners) > self.max_field_size\n            or favorite_odds < self.min_favorite_odds\n            or second_favorite_odds < self.min_second_favorite_odds\n        ):\n            # Assign a score of 0 to races that would have been filtered out\n            return 0.0\n\n        score = round(final_score * 100, 2)\n        race.qualification_score = score\n        return score\n\n\nclass AnalyzerEngine:\n    \"\"\"Discovers and manages all available analyzer plugins.\"\"\"\n\n    def __init__(self):\n        self.analyzers: Dict[str, Type[BaseAnalyzer]] = {}\n        self._discover_analyzers()\n\n    def _discover_analyzers(self):\n        # In a real plugin system, this would inspect a folder.\n        # For now, we register them manually.\n        self.register_analyzer(\"trifecta\", TrifectaAnalyzer)\n        log.info(\n            \"AnalyzerEngine discovered plugins\",\n            available_analyzers=list(self.analyzers.keys()),\n        )\n\n    def register_analyzer(self, name: str, analyzer_class: Type[BaseAnalyzer]):\n        self.analyzers[name] = analyzer_class\n\n    def get_analyzer(self, name: str, **kwargs) -> BaseAnalyzer:\n        analyzer_class = self.analyzers.get(name)\n        if not analyzer_class:\n            log.error(\"Requested analyzer not found\", requested_analyzer=name)\n            raise ValueError(f\"Analyzer '{name}' not found.\")\n        return analyzer_class(**kwargs)\n\n\nclass AudioAlertSystem:\n    \"\"\"Plays sound alerts for important events.\"\"\"\n\n    def __init__(self):\n        self.sounds = {\n            \"high_value\": Path(__file__).parent.parent.parent / \"assets\" / \"sounds\" / \"alert_premium.wav\",\n        }\n        self.enabled = winsound is not None\n\n    def play(self, sound_type: str):\n        if not self.enabled:\n            return\n\n        sound_file = self.sounds.get(sound_type)\n        if sound_file and sound_file.exists():\n            try:\n                winsound.PlaySound(str(sound_file), winsound.SND_FILENAME | winsound.SND_ASYNC)\n            except Exception as e:\n                log.warning(\"Could not play sound\", file=sound_file, error=e)\n\n\nclass RaceNotifier:\n    \"\"\"Handles sending native Windows notifications and audio alerts for high-value races.\"\"\"\n\n    def __init__(self):\n        self.toaster = ToastNotifier(\"Fortuna\") if ToastNotifier else None\n        self.audio_system = AudioAlertSystem()\n        self.notified_races = set()\n\n    def notify_qualified_race(self, race):\n        if not self.toaster or race.id in self.notified_races:\n            return\n\n        title = \"\ud83c\udfc7 High-Value Opportunity!\"\n        message = f\"\"\"{race.venue} - Race {race.race_number}\nScore: {race.qualification_score:.0f}%\nPost Time: {race.start_time.strftime(\"%I:%M %p\")}\"\"\"\n\n        try:\n            # The `threaded=True` argument is crucial to prevent blocking the main application thread.\n            self.toaster.show_toast(title, message, duration=10, threaded=True)\n            self.notified_races.add(race.id)\n            self.audio_system.play(\"high_value\")\n            log.info(\"Notification and audio alert sent for high-value race\", race_id=race.id)\n        except Exception as e:\n            # Catch potential exceptions from the notification library itself\n            log.error(\"Failed to send notification\", error=str(e), exc_info=True)\n",
    "web_service/backend/api.py": "# web_service/backend/api.py\n# Reconstructed by Jules to merge features from python_service with web_service structure.\n\nimport asyncio\nimport os\nimport sys\nfrom contextlib import asynccontextmanager\nfrom typing import List, Optional\n\nimport structlog\nfrom fastapi import Depends, FastAPI, HTTPException, Query, Request, WebSocket\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\nfrom slowapi.middleware import SlowAPIMiddleware\nfrom slowapi.util import get_remote_address\nfrom starlette.websockets import WebSocketDisconnect\n\n# Corrected imports for web_service.backend\nfrom .config import get_settings\nfrom .engine import OddsEngine\nfrom .health import router as health_router\nfrom .logging_config import configure_logging\nfrom .middleware.error_handler import UserFriendlyException, user_friendly_exception_handler, validation_exception_handler\nfrom .models import AggregatedResponse, QualifiedRacesResponse, Race\nfrom .security import verify_api_key\n\nlog = structlog.get_logger()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manages application startup and shutdown events.\"\"\"\n    configure_logging()\n    log.info(\"Lifespan: Startup sequence initiated.\")\n\n    settings = get_settings()\n    engine = OddsEngine(config=settings)\n    app.state.engine = engine\n\n    log.info(\"Lifespan: Engine initialized successfully. Startup complete.\")\n    yield\n    log.info(\"Lifespan: Shutdown sequence initiated.\")\n    if hasattr(app.state, \"engine\") and app.state.engine:\n        await app.state.engine.close()\n    log.info(\"Lifespan: Shutdown sequence complete.\")\n\n# --- FastAPI App Initialization ---\nlimiter = Limiter(key_func=get_remote_address)\napp = FastAPI(\n    title=\"Fortuna Faucet Web Service API\",\n    version=\"3.0\",\n    lifespan=lifespan,\n    docs_url=\"/api/docs\",\n    redoc_url=\"/api/redoc\",\n    openapi_url=\"/api/openapi.json\",\n)\n\napp.state.limiter = limiter\napp.add_middleware(SlowAPIMiddleware)\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\napp.add_exception_handler(RequestValidationError, validation_exception_handler)\napp.add_exception_handler(UserFriendlyException, user_friendly_exception_handler)\napp.include_router(health_router)\n\n# Add CORS middleware for frontend development\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=get_settings().ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# --- Robust Pathing for Frozen Executables ---\ndef resource_path(relative_path: str) -> str:\n    \"\"\" Get absolute path to resource, works for dev and for PyInstaller \"\"\"\n    if getattr(sys, 'frozen', False):\n        # PyInstaller creates a temp folder and stores path in _MEIPASS\n        base_path = sys._MEIPASS\n    else:\n        # In development, the base path is the project root.\n        # This assumes the script is run from the project root.\n        base_path = os.path.abspath(\".\")\n\n    return os.path.join(base_path, relative_path)\n\n\n# --- Static File Serving Logic (Corrected for PyInstaller) ---\nif os.getenv(\"FORTUNA_MODE\") == \"webservice\":\n    log.info(\"Application starting in 'webservice' mode, attempting to serve static files.\")\n\n    # Use the robust resource_path function to find the 'ui' directory.\n    # The spec file bundles 'web_service/frontend/out' into the 'ui' folder in the executable's root.\n    static_dir_key = \"ui\" if getattr(sys, 'frozen', False) else \"web_service/frontend/out\"\n    static_dir = resource_path(static_dir_key)\n    log.info(\"Resolved static files directory\", path=static_dir)\n\n    if not os.path.isdir(static_dir):\n        log.error(\"Static files directory not found! Frontend will not be served.\", path=static_dir)\n    else:\n        log.info(\"Mounting StaticFiles to serve the frontend.\")\n        app.mount(\"/\", StaticFiles(directory=static_dir, html=True), name=\"static\")\nelse:\n    log.info(\"FORTUNA_MODE is not 'webservice', static files will not be served by this API.\")\n\n\n# --- Dependency Injection ---\ndef get_engine(request: Request) -> OddsEngine:\n    if not hasattr(request.app.state, \"engine\") or request.app.state.engine is None:\n        raise HTTPException(status_code=503, detail=\"The OddsEngine is not available.\")\n    return request.app.state.engine\n\n# --- API Endpoints (Restored and Adapted) ---\n\n@app.get(\"/api/races\", response_model=AggregatedResponse)\n@limiter.limit(\"30/minute\")\nasync def get_races(\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    source: Optional[str] = None,\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n):\n    \"\"\"Fetches all race data for a given date from all or a specific source.\"\"\"\n    return await engine.fetch_all_odds(race_date, source)\n\n@app.get(\"/api/races/qualified/{analyzer_name}\", response_model=QualifiedRacesResponse)\n@limiter.limit(\"120/minute\")\nasync def get_qualified_races(\n    analyzer_name: str,\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n    # Example query parameters for an analyzer\n    max_field_size: int = Query(10, ge=3, le=20),\n    min_odds: float = Query(2.0, ge=1.0),\n):\n    \"\"\"Fetches all race data and runs a specific analyzer to find qualified races.\"\"\"\n    # This is a simplified version; a real implementation would have a dynamic analyzer engine.\n    # For now, we'll just fetch and return all races as \"qualified\".\n    response = await engine.fetch_all_odds(race_date)\n    races = [Race(**r) for r in response.get(\"races\", [])]\n    return QualifiedRacesResponse(qualified_races=races, analysis_metadata={\"analyzer\": analyzer_name})\n\n@app.get(\"/api/adapters/status\")\n@limiter.limit(\"60/minute\")\nasync def get_all_adapter_statuses(\n    request: Request,\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n):\n    \"\"\"Gets the current status of all configured data adapters.\"\"\"\n    return engine.get_all_adapter_statuses()\n\n# Add other endpoints as needed, following the pattern above.\n",
    "web_service/backend/etl.py": "# python_service/etl.py\n# ETL pipeline for populating the historical data warehouse\n\nimport json\nimport logging\nimport os\nfrom datetime import date\n\nimport requests\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import text\nfrom sqlalchemy.exc import SQLAlchemyError\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass ScribesArchivesETL:\n    def __init__(self):\n        self.postgres_url = os.getenv(\"POSTGRES_URL\")\n        self.api_key = os.getenv(\"API_KEY\")\n        self.api_base_url = \"http://localhost:8000\"\n        self.engine = self._get_db_engine()\n\n    def _get_db_engine(self):\n        if not self.postgres_url:\n            logger.warning(\"POSTGRES_URL not set. ETL will be skipped.\")\n            return None\n        try:\n            return create_engine(self.postgres_url)\n        except Exception as e:\n            logger.error(f\"Failed to create database engine: {e}\", exc_info=True)\n            return None\n\n    def _fetch_race_data(self, target_date: date) -> list:\n        \"\"\"Fetches aggregated race data from the local API.\"\"\"\n        if not self.api_key:\n            raise ValueError(\"API_KEY not found in environment.\")\n\n        url = f\"{self.api_base_url}/api/races?race_date={target_date.isoformat()}\"\n        headers = {\"X-API-KEY\": self.api_key}\n        response = requests.get(url, headers=headers, timeout=120)\n        response.raise_for_status()\n        return response.json().get(\"races\", [])\n\n    def _validate_and_transform(self, race: dict) -> tuple:\n        \"\"\"Validates a race dictionary and transforms it for insertion.\"\"\"\n        if not all(k in race for k in [\"id\", \"venue\", \"race_number\", \"start_time\", \"runners\"]):\n            return (\n                None,\n                \"Missing core fields (id, venue, race_number, start_time, runners)\",\n            )\n\n        active_runners = [r for r in race.get(\"runners\", []) if not r.get(\"scratched\")]\n\n        transformed = {\n            \"race_id\": race[\"id\"],\n            \"venue\": race[\"venue\"],\n            \"race_number\": race[\"race_number\"],\n            \"start_time\": race[\"start_time\"],\n            \"source\": race.get(\"source\"),\n            \"qualification_score\": race.get(\"qualification_score\"),\n            \"field_size\": len(active_runners),\n        }\n        return transformed, None\n\n    def run(self, target_date: date):\n        if not self.engine:\n            return\n\n        logger.info(f\"Starting ETL process for {target_date.isoformat()}...\")\n        try:\n            races = self._fetch_race_data(target_date)\n        except (requests.RequestException, ValueError) as e:\n            logger.error(f\"Failed to fetch race data: {e}\", exc_info=True)\n            return\n\n        clean_records = []\n        quarantined_records = []\n\n        for race in races:\n            transformed, reason = self._validate_and_transform(race)\n            if transformed:\n                clean_records.append(transformed)\n            else:\n                quarantined_records.append(\n                    {\n                        \"race_id\": race.get(\"id\"),\n                        \"source\": race.get(\"source\"),\n                        \"payload\": json.dumps(race),\n                        \"reason\": reason,\n                    }\n                )\n\n        with self.engine.connect() as connection:\n            try:\n                with connection.begin():  # Transaction block\n                    if clean_records:\n                        # Using ON CONFLICT to prevent duplicates\n                        stmt = text(\n                            \"\"\"\n                            INSERT INTO historical_races (\n                                race_id, venue, race_number, start_time, source,\n                                qualification_score, field_size\n                            )\n                            VALUES (\n                                :race_id, :venue, :race_number, :start_time, :source,\n                                :qualification_score, :field_size\n                            )\n                            ON CONFLICT (race_id) DO NOTHING;\n                        \"\"\"\n                        )\n                        connection.execute(stmt, clean_records)\n                        logger.info(f\"Inserted/updated {len(clean_records)} records into historical_races.\")\n\n                    if quarantined_records:\n                        stmt = text(\n                            \"\"\"\n                            INSERT INTO quarantined_races (race_id, source, payload, reason)\n                            VALUES (:race_id, :source, :payload::jsonb, :reason);\n                        \"\"\"\n                        )\n                        connection.execute(stmt, quarantined_records)\n                        logger.warning(f\"Moved {len(quarantined_records)} records to quarantine.\")\n            except SQLAlchemyError as e:\n                logger.error(f\"Database transaction failed: {e}\", exc_info=True)\n\n        logger.info(\"ETL process finished.\")\n\n\ndef run_etl_for_yesterday():\n    from datetime import timedelta\n\n    yesterday = date.today() - timedelta(days=1)\n    etl = ScribesArchivesETL()\n    etl.run(yesterday)\n",
    "web_service/backend/fortuna_watchman.py": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: The Watchman (v2 - Score-Aware)\n# ==============================================================================\n# This is the master orchestrator for the Fortuna Faucet project.\n# It executes the full, end-to-end handicapping strategy autonomously.\n# ==============================================================================\n\nimport asyncio\nfrom datetime import datetime\nfrom datetime import timezone\nfrom typing import List\n\nimport structlog\n\nfrom .analyzer import AnalyzerEngine\nfrom .config import get_settings\nfrom .engine import OddsEngine\nfrom .etl import run_etl_for_yesterday\nfrom .models import Race\n\nlog = structlog.get_logger(__name__)\n\n\nclass Watchman:\n    \"\"\"Orchestrates the daily operation of the Fortuna Faucet.\"\"\"\n\n    def __init__(self):\n        self.settings = get_settings()\n        self.odds_engine = OddsEngine(config=self.settings)\n        self.analyzer_engine = AnalyzerEngine()\n\n    async def get_initial_targets(self) -> List[Race]:\n        \"\"\"Uses the OddsEngine and AnalyzerEngine to get the day's ranked targets.\"\"\"\n        log.info(\"Watchman: Acquiring and ranking initial targets for the day...\")\n        today_str = datetime.now(timezone.utc).strftime(\"%Y-%m-%d\")\n        try:\n            background_tasks = set()  # Create a dummy set for background tasks\n            aggregated_data = await self.odds_engine.fetch_all_odds(today_str, background_tasks)\n            all_races = aggregated_data.get(\"races\", [])\n            if not all_races:\n                log.warning(\"Watchman: No races returned from OddsEngine.\")\n                return []\n\n            analyzer = self.analyzer_engine.get_analyzer(\"trifecta\")\n            qualified_races_result = analyzer.qualify_races(all_races)\n            qualified_races_list = qualified_races_result.get(\"races\", [])\n            log.info(\n                \"Watchman: Initial target acquisition and ranking complete\",\n                target_count=len(qualified_races_list),\n            )\n\n            # Log the top targets for better observability\n            for race in qualified_races_list[:5]:\n                log.info(\n                    \"Top Target Found\",\n                    score=race.qualification_score,\n                    venue=race.venue,\n                    race_number=race.race_number,\n                    post_time=race.start_time.isoformat(),\n                )\n            return qualified_races_list\n        except Exception as e:\n            log.error(\"Watchman: Failed to get initial targets\", error=str(e), exc_info=True)\n            return []\n\n    async def run_tactical_monitoring(self, targets: List[Race]):\n        \"\"\"Uses the LiveOddsMonitor on each target as it approaches post time.\"\"\"\n        log.info(\"Watchman: Entering tactical monitoring loop.\")\n        # active_targets = list(targets)\n\n        # from python_service.adapters.betfair_adapter import BetfairAdapter\n        # async with LiveOddsMonitor(betfair_adapter=BetfairAdapter(config=self.settings)) as live_monitor:\n        #     async with httpx.AsyncClient() as client:\n        #         while active_targets:\n        #             now = datetime.now(timezone.utc)\n\n        #             # Find races that are within the 5-minute monitoring window\n        #             races_to_monitor = [\n        #                 r\n        #                 for r in active_targets\n        #                 if r.start_time.replace(tzinfo=timezone.utc) > now\n        #                 and r.start_time.replace(tzinfo=timezone.utc)\n        #                 < now + timedelta(minutes=5)\n        #             ]\n\n        #             if races_to_monitor:\n        #                 for race in races_to_monitor:\n        #                     log.info(\"Watchman: Deploying Live Monitor for approaching target\",\n        #                         race_id=race.id,\n        #                         venue=race.venue,\n        #                         score=race.qualification_score\n        #                     )\n        #                     updated_race = await live_monitor.monitor_race(race, client)\n        #                     log.info(\"Watchman: Live monitoring complete for race\", race_id=updated_race.id)\n        #                     # Remove from target list to prevent re-monitoring\n        #                     active_targets = [t for t in active_targets if t.id != race.id]\n\n        #             if not active_targets:\n        #                 break # Exit loop if all targets are processed\n\n        #             await asyncio.sleep(30) # Check for upcoming races every 30 seconds\n\n        log.info(\"Watchman: All targets for the day have been monitored. Mission complete.\")\n\n    async def execute_daily_protocol(self):\n        \"\"\"The main, end-to-end orchestration method.\"\"\"\n        log.info(\"--- Fortuna Watchman Daily Protocol: ACTIVE ---\")\n        try:\n            initial_targets = await self.get_initial_targets()\n            if initial_targets:\n                await self.run_tactical_monitoring(initial_targets)\n            else:\n                log.info(\"Watchman: No initial targets found. Shutting down for the day.\")\n        finally:\n            await self.odds_engine.close()\n\n        # Run ETL for yesterday's data after all other operations are complete\n        try:\n            log.info(\"Starting daily ETL process for Scribe's Archives...\")\n            run_etl_for_yesterday()\n            log.info(\"Daily ETL process completed successfully.\")\n        except Exception:\n            log.error(\"Daily ETL process failed.\", exc_info=True)\n        log.info(\"--- Fortuna Watchman Daily Protocol: COMPLETE ---\")\n\n\nasync def main():\n    from .logging_config import configure_logging\n\n    configure_logging()\n    watchman = Watchman()\n    await watchman.execute_daily_protocol()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
    "web_service/backend/fortuna_windows_service.py": "# fortuna_windows_service.py\n\nimport logging\nimport os\nimport sys\n\nimport servicemanager\nimport win32event\nimport win32service\nimport win32serviceutil\n\n# Ensure the script's directory is at the front of the path\nscript_dir = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, script_dir)\n\ntry:\n    from fortuna_service import FortunaBackgroundService\nexcept ImportError as e:\n    # Log a detailed error to the Windows Event Log if the import fails\n    servicemanager.LogErrorMsg(f\"FATAL: Could not import FortunaBackgroundService. Error: {e}\")\n    sys.exit(1)  # Exit with an error code\n\n\nclass FortunaWindowsService(win32serviceutil.ServiceFramework):\n    _svc_name_ = \"FortunaV8Service\"\n    _svc_display_name_ = \"Fortuna V8 Racing Analysis Service\"\n    _svc_description_ = \"Continuously fetches and analyzes horse racing data.\"\n\n    def __init__(self, args):\n        win32serviceutil.ServiceFramework.__init__(self, args)\n        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)\n        self.fortuna_service = FortunaBackgroundService()\n        # Configure logging to use the Windows Event Log\n        logging.basicConfig(\n            level=logging.INFO,\n            format=\"%(name)s - %(levelname)s - %(message)s\",\n            handlers=[servicemanager.LogHandler()],\n        )\n\n    def SvcStop(self):\n        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\n        self.fortuna_service.stop()\n        win32event.SetEvent(self.hWaitStop)\n        self.ReportServiceStatus(win32service.SERVICE_STOPPED)\n\n    def SvcDoRun(self):\n        servicemanager.LogMsg(\n            servicemanager.EVENTLOG_INFORMATION_TYPE,\n            servicemanager.PYS_SERVICE_STARTED,\n            (self._svc_name_, \"\"),\n        )\n        self.main()\n\n    def main(self):\n        self.fortuna_service.start()\n        win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) == 1:\n        servicemanager.Initialize()\n        servicemanager.PrepareToHostSingle(FortunaWindowsService)\n        servicemanager.StartServiceCtrlDispatcher()\n    else:\n        win32serviceutil.HandleCommandLine(FortunaWindowsService)\n",
    "web_service/backend/requirements.in": "#\n# Fortuna Faucet - High-Level Backend Dependencies\n# This is the source of truth. Run 'pip-compile' to generate requirements.txt.\n#\n\n# --- Core Application Framework (Hard Pins) ---\nfastapi\nuvicorn==0.30.1\ncryptography\n\n# --- Core Application Dependencies (Flexible) ---\ntenacity\npydantic-settings\nhttpx[http2]\nselectolax==0.4.0\nbeautifulsoup4\nslowapi\nredis\npandas\nnumpy\nscipy\naiosqlite\nSQLAlchemy\npsycopg2-binary\nstructlog\ncertifi\n\n# --- Desktop & OS Integration (Flexible) ---\npsutil\npywin32 ; sys_platform == 'win32'\nwindows-toasts ; sys_platform == 'win32'\nkeyring\npynput ; sys_platform == 'win32'\n\n# --- Development & Testing Dependencies ---\npytest\npytest-asyncio\nblack\n\n# --- Build Dependencies (Hard Pins) ---\n# THE FIX: Upgraded to 6.6.0 for official Python 3.12 support.\npyinstaller==6.6.0\nwheel\nsetuptools>=78.1.1,<81\npip-tools\nrequests>=2.32.4\nurllib3>=2.5.0\n",
    "web_service/backend/requirements.txt": "#\n# This file is autogenerated by pip-compile with Python 3.12\n# by the following command:\n#\n#    pip-compile --output-file=python_service/requirements.txt python_service/requirements.in\n#\naiosqlite==0.21.0\n    # via -r python_service/requirements.in\naltgraph==0.17.4\n    # via pyinstaller\nannotated-doc==0.0.4\n    # via fastapi\nannotated-types==0.7.0\n    # via pydantic\nanyio==4.11.0\n    # via\n    #   httpx\n    #   starlette\nbeautifulsoup4==4.14.2\n    # via -r python_service/requirements.in\nblack==25.11.0\n    # via -r python_service/requirements.in\nbuild==1.3.0\n    # via pip-tools\ncertifi==2025.10.5\n    # via\n    #   -r python_service/requirements.in\n    #   httpcore\n    #   httpx\n    #   requests\ncffi==2.0.0\n    # via cryptography\ncharset-normalizer==3.4.4\n    # via requests\nclick==8.3.0\n    # via\n    #   black\n    #   pip-tools\n    #   uvicorn\ncryptography==46.0.3\n    # via\n    #   -r python_service/requirements.in\n    #   secretstorage\ndeprecated==1.3.1\n    # via limits\nfastapi==0.121.1\n    # via -r python_service/requirements.in\ngreenlet==3.2.4\n    # via sqlalchemy\nh11==0.16.0\n    # via\n    #   httpcore\n    #   uvicorn\nh2==4.3.0\n    # via httpx\nhpack==4.1.0\n    # via h2\nhttpcore==1.0.9\n    # via httpx\nhttpx[http2]==0.28.1\n    # via -r python_service/requirements.in\nhyperframe==6.1.0\n    # via h2\nidna==3.11\n    # via\n    #   anyio\n    #   httpx\n    #   requests\niniconfig==2.3.0\n    # via pytest\njaraco-classes==3.4.0\n    # via keyring\njaraco-context==6.0.1\n    # via keyring\njaraco-functools==4.3.0\n    # via keyring\njeepney==0.9.0\n    # via\n    #   keyring\n    #   secretstorage\nkeyring==25.6.0\n    # via -r python_service/requirements.in\nlimits==5.6.0\n    # via slowapi\nmore-itertools==10.8.0\n    # via\n    #   jaraco-classes\n    #   jaraco-functools\nmypy-extensions==1.1.0\n    # via black\nnumpy==2.3.4\n    # via\n    #   -r python_service/requirements.in\n    #   pandas\n    #   scipy\npackaging==25.0\n    # via\n    #   black\n    #   build\n    #   limits\n    #   pyinstaller\n    #   pyinstaller-hooks-contrib\n    #   pytest\npandas==2.3.3\n    # via -r python_service/requirements.in\npathspec==0.12.1\n    # via black\npip-tools==7.5.1\n    # via -r python_service/requirements.in\nplatformdirs==4.5.0\n    # via black\npluggy==1.6.0\n    # via pytest\npsutil==7.1.3\n    # via -r python_service/requirements.in\npsycopg2-binary==2.9.11\n    # via -r python_service/requirements.in\npycparser==2.23\n    # via cffi\npydantic==2.12.4\n    # via\n    #   fastapi\n    #   pydantic-settings\npydantic-core==2.41.5\n    # via pydantic\npydantic-settings==2.12.0\n    # via -r python_service/requirements.in\npygments==2.19.2\n    # via pytest\npyinstaller==6.6.0\n    # via -r python_service/requirements.in\npyinstaller-hooks-contrib==2025.9\n    # via pyinstaller\npyproject-hooks==1.2.0\n    # via\n    #   build\n    #   pip-tools\npytest==9.0.0\n    # via\n    #   -r python_service/requirements.in\n    #   pytest-asyncio\npytest-asyncio==1.3.0\n    # via -r python_service/requirements.in\npython-dateutil==2.9.0.post0\n    # via pandas\npython-dotenv==1.2.1\n    # via pydantic-settings\npytokens==0.3.0\n    # via black\npytz==2025.2\n    # via pandas\nredis==7.0.1\n    # via -r python_service/requirements.in\nrequests==2.32.5\n    # via -r python_service/requirements.in\nscipy==1.16.3\n    # via -r python_service/requirements.in\nsecretstorage==3.4.1\n    # via keyring\nselectolax==0.4.0\n    # via -r python_service/requirements.in\nsix==1.17.0\n    # via python-dateutil\nslowapi==0.1.9\n    # via -r python_service/requirements.in\nsniffio==1.3.1\n    # via anyio\nsoupsieve==2.8\n    # via beautifulsoup4\nsqlalchemy==2.0.44\n    # via -r python_service/requirements.in\nstarlette==0.49.3\n    # via fastapi\nstructlog==25.5.0\n    # via -r python_service/requirements.in\ntenacity==8.5.0\n    # via -r python_service/requirements.in\ntyping-extensions==4.15.0\n    # via\n    #   aiosqlite\n    #   anyio\n    #   beautifulsoup4\n    #   fastapi\n    #   limits\n    #   pydantic\n    #   pydantic-core\n    #   pytest-asyncio\n    #   sqlalchemy\n    #   starlette\n    #   typing-inspection\ntyping-inspection==0.4.2\n    # via\n    #   pydantic\n    #   pydantic-settings\ntzdata==2025.2\n    # via pandas\nurllib3>=2.6.0\n    # via\n    #   -r python_service/requirements.in\n    #   requests\nuvicorn==0.30.1\n    # via -r python_service/requirements.in\nwheel==0.45.1\n    # via\n    #   -r python_service/requirements.in\n    #   pip-tools\nwrapt==2.0.1\n    # via deprecated\n\n# The following packages are considered to be unsafe in a requirements file:\n# pip\n# setuptools\npywin32==306; sys_platform == 'win32'\n",
    "web_service/backend/security.py": "# python_service/security.py\n\nimport secrets\n\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom fastapi import Security\nfrom fastapi import status\nfrom fastapi.security import APIKeyHeader\n\nfrom .config import Settings\nfrom .config import get_settings\n\nAPI_KEY_NAME = \"X-API-Key\"\napi_key_header = APIKeyHeader(name=API_KEY_NAME, auto_error=True)\n\n\nasync def verify_api_key(key: str = Security(api_key_header), settings: Settings = Depends(get_settings)):\n    \"\"\"\n    Verifies the provided API key against the one in settings using a\n    timing-attack resistant comparison.\n    \"\"\"\n    if secrets.compare_digest(key, settings.API_KEY):\n        return True\n    else:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Invalid or missing API Key\")\n",
    "web_service/backend/utils/text.py": "# python_service/utils/text.py\n# Centralized text and name normalization utilities\nimport re\nfrom typing import Optional\n\n\ndef clean_text(text: Optional[str]) -> Optional[str]:\n    \"\"\"Strips leading/trailing whitespace and collapses internal whitespace.\"\"\"\n    if not text:\n        return None\n    return \" \".join(text.strip().split())\n\n\ndef normalize_venue_name(name: Optional[str]) -> Optional[str]:\n    \"\"\"\n    Normalizes a UK or Irish racecourse name to a standard format.\n    Handles common abbreviations and variations.\n    \"\"\"\n    if not name:\n        return None\n\n    # Use a temporary variable for matching, but return the properly cased name\n    cleaned_name_upper = clean_text(name).upper()\n\n    VENUE_MAP = {\n        \"ASCOT\": \"Ascot\",\n        \"AYR\": \"Ayr\",\n        \"BANGOR-ON-DEE\": \"Bangor-on-Dee\",\n        \"CATTERICK BRIDGE\": \"Catterick\",\n        \"CHELMSFORD CITY\": \"Chelmsford\",\n        \"EPSOM DOWNS\": \"Epsom\",\n        \"FONTWELL\": \"Fontwell Park\",\n        \"HAYDOCK\": \"Haydock Park\",\n        \"KEMPTON\": \"Kempton Park\",\n        \"LINGFIELD\": \"Lingfield Park\",\n        \"NEWMARKET (ROWLEY)\": \"Newmarket\",\n        \"NEWMARKET (JULY)\": \"Newmarket\",\n        \"SANDOWN\": \"Sandown Park\",\n        \"STRATFORD\": \"Stratford-on-Avon\",\n        \"YARMOUTH\": \"Great Yarmouth\",\n        \"CURRAGH\": \"Curragh\",\n        \"DOWN ROYAL\": \"Down Royal\",\n    }\n\n    # Check primary map first\n    if cleaned_name_upper in VENUE_MAP:\n        return VENUE_MAP[cleaned_name_upper]\n\n    # Handle cases where the key is the desired output but needs to be mapped from a variation\n    # e.g. CHELMSFORD maps to Chelmsford\n    # Title case the cleaned name for a sensible default\n    title_cased_name = clean_text(name).title()\n    if title_cased_name in VENUE_MAP.values():\n        return title_cased_name\n\n    # Return the title-cased cleaned name as a fallback\n    return title_cased_name\n\n\ndef normalize_course_name(name: str) -> str:\n    if not name:\n        return \"\"\n    name = name.lower().strip()\n    name = re.sub(r\"[^a-z0-9\\s-]\", \"\", name)\n    name = re.sub(r\"[\\s-]+\", \"_\", name)\n    return name\n",
    "web_service/frontend/app/components/LiveModeToggle.tsx": "// web_platform/frontend/src/components/LiveModeToggle.tsx\n'use client';\n\nimport React from 'react';\n\ninterface LiveModeToggleProps {\n  isLive: boolean;\n  onToggle: (isLive: boolean) => void;\n  isDisabled: boolean;\n}\n\nexport const LiveModeToggle: React.FC<LiveModeToggleProps> = ({ isLive, onToggle, isDisabled }) => {\n  const handleToggle = () => {\n    if (!isDisabled) {\n      onToggle(!isLive);\n    }\n  };\n\n  return (\n    <button\n      onClick={handleToggle}\n      disabled={isDisabled}\n      className={`relative inline-flex items-center h-8 rounded-full w-32 transition-colors duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800 focus:ring-blue-500 ${\n        isDisabled ? 'cursor-not-allowed bg-slate-700' : 'cursor-pointer'\n      } ${isLive ? 'bg-green-600' : 'bg-slate-600'}`}\n    >\n      <span className=\"sr-only\">Toggle Live Mode</span>\n      <span\n        className={`absolute left-1 top-1 inline-block w-6 h-6 rounded-full bg-white transform transition-transform duration-300 ease-in-out ${\n          isLive ? 'translate-x-[104px]' : 'translate-x-0'\n        }`}\n      />\n      <span\n        className={`absolute left-8 transition-opacity duration-200 ease-in-out ${\n          !isLive && !isDisabled ? 'opacity-100' : 'opacity-50'\n        }`}\n      >\n        Poll\n      </span>\n      <span\n        className={`absolute right-4 transition-opacity duration-200 ease-in-out ${\n          isLive && !isDisabled ? 'opacity-100' : 'opacity-50'\n        }`}\n      >\n        \u26a1 Live\n      </span>\n    </button>\n  );\n};\n",
    "web_service/frontend/app/components/LiveRaceDashboard.tsx": "// web_platform/frontend/src/components/LiveRaceDashboard.tsx\n'use client';\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { RaceFilters } from './RaceFilters';\nimport { RaceCard } from './RaceCard';\nimport { RaceCardSkeleton } from './RaceCardSkeleton';\nimport { EmptyState } from './EmptyState';\nimport { ErrorDisplay } from './ErrorDisplay';\nimport { Race, SourceInfo, AdapterError, AggregatedRacesResponse } from '../types/racing';\nimport { useWebSocket } from '../hooks/useWebSocket';\nimport { StatusDetailModal } from './StatusDetailModal';\nimport ManualOverridePanel from './ManualOverridePanel';\nimport { LiveModeToggle } from './LiveModeToggle';\nimport { AdapterStatusPanel } from './AdapterStatusPanel';\n\n// Type for the backend process status received from Electron main\ntype BackendState = 'starting' | 'running' | 'error' | 'stopped';\ninterface BackendStatus {\n  state: BackendState;\n  logs: string[];\n}\n\ninterface RaceFilterParams {\n  maxFieldSize: number;\n  minFavoriteOdds: number;\n  minSecondFavoriteOdds: number;\n}\n\nconst fetchAdapterStatuses = async (apiKey: string | null): Promise<SourceInfo[]> => {\n  if (!apiKey) {\n    throw new Error('API key not available.');\n  }\n  const response = await fetch(`/api/adapters/status`, {\n    headers: { 'X-API-Key': apiKey, 'Content-Type': 'application/json' },\n  });\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(JSON.stringify(errorData));\n  }\n  return response.json();\n};\n\nconst fetchQualifiedRaces = async (apiKey: string | null, params: RaceFilterParams): Promise<AggregatedRacesResponse> => {\n  if (!apiKey) {\n    throw new Error('API key not available');\n  }\n  // In web service mode, API calls are relative to the current origin.\n  const response = await fetch(`/api/races`, {\n    headers: { 'X-API-Key': apiKey },\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(JSON.stringify(errorData));\n  }\n\n  return response.json();\n};\n\n\nconst BackendErrorPanel = ({ logs }: { logs: string[] }) => (\n  <div className=\"bg-slate-800 p-6 rounded-lg border border-red-500/50 text-white\">\n    <h2 className=\"text-2xl font-bold text-red-400 mb-4\">Backend Service Error</h2>\n    <p className=\"text-slate-400 mb-4\">The backend data service failed to start or has crashed. Below are the most recent diagnostic messages.</p>\n    <div className=\"bg-black p-4 rounded-md font-mono text-sm text-slate-300 h-64 overflow-y-auto mb-4\">\n      {logs.map((log, index) => (\n        <p key={index} className=\"whitespace-pre-wrap\">{`> ${log}`}</p>\n      ))}\n    </div>\n    <p className=\"text-sm text-slate-500 text-center mt-4\">Please check the server logs for more information.</p>\n  </div>\n);\n\n// New Sub-Component to display an error from a specific adapter\nconst ErrorCard = ({ source, message }: { source: string; message: string }) => (\n  <div className=\"bg-slate-800 rounded-lg p-4 border border-red-500/50 flex flex-col justify-between\">\n    <div>\n      <h3 className=\"font-bold text-red-400 text-lg\">{source} Failed</h3>\n      <p className=\"text-slate-400 text-sm mt-2\">{message}</p>\n    </div>\n    <div className=\"mt-4 text-xs text-slate-500\">\n      <p>This adapter failed to fetch data. This is not a critical error; other adapters may provide the necessary data.</p>\n    </div>\n  </div>\n);\n\n// New Sub-Component to render the grid of races or error cards\nconst RaceGrid = ({ races }: { races: Race[] }) => (\n  <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\">\n    {races.map(race =>\n      race.isErrorPlaceholder ? (\n        <ErrorCard key={race.id} source={race.venue} message={race.errorMessage || 'An unknown error occurred.'} />\n      ) : (\n        <RaceCard key={race.id} race={race} />\n      )\n    )}\n  </div>\n);\n\n// In a pure web service, the frontend cannot know the backend's process status.\n// We assume it's always running if the frontend is served.\nconst useBackendStatus = (): BackendStatus => {\n  return { state: 'running', logs: ['Running in web service mode. Backend status is assumed to be active.'] };\n};\n\nexport const LiveRaceDashboard = React.memo(() => {\n  const [races, setRaces] = useState<Race[]>([]);\n  const [adapterErrors, setAdapterErrors] = useState<AdapterError[]>([]);\n  const backendStatus = useBackendStatus();\n  // In a web service, the API key might be hardcoded, come from a meta tag, or an auth flow.\n  // For this version, we'll rely on the backend not requiring one from the same origin or use a known key.\n  const [apiKey, setApiKey] = useState<string | null>(\"a_secure_test_api_key_that_is_long_enough\");\n  const queryClient = useQueryClient();\n\n  const [params, setParams] = useState<RaceFilterParams>({\n    maxFieldSize: 10,\n    minFavoriteOdds: 2.5,\n    minSecondFavoriteOdds: 4.0,\n  });\n\n  const {\n    data,\n    status: connectionStatus,\n    error: errorDetails,\n    refetch,\n  } = useQuery({\n    queryKey: ['aggregatedRaces', apiKey],\n    queryFn: () => fetchQualifiedRaces(apiKey, params),\n    enabled: backendStatus.state === 'running' && !!apiKey,\n    refetchOnWindowFocus: true,\n  });\n\n  // Update state when data is successfully fetched\n  useEffect(() => {\n    if (data) {\n      setRaces(data.races || []);\n      setAdapterErrors(data.errors || []);\n      setLastUpdate(new Date());\n    }\n  }, [data]);\n\n  const { data: liveData, isConnected: isLiveConnected } = useWebSocket<AggregatedRacesResponse>(\n    '/ws/live-updates',\n    { apiKey } // Port is not needed for same-origin WebSockets\n  );\n\n  // Effect to update state when new live data arrives\n  useEffect(() => {\n    if (liveData) {\n      console.log('Received live data update:', liveData);\n      // Update the query cache and local state with the new data\n      queryClient.setQueryData(['aggregatedRaces', apiKey], liveData);\n      setRaces(liveData.races || []);\n      setAdapterErrors(liveData.errors || []);\n      setLastUpdate(new Date());\n    }\n  }, [liveData, queryClient, apiKey]);\n\n  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n\n  const handleParamsChange = useCallback((newParams: RaceFilterParams) => {\n    setParams(newParams);\n  }, []);\n\n  const handleParseSuccess = (adapterName: string, parsedRaces: Race[]) => {\n    queryClient.setQueryData(['qualifiedRaces', apiKey, params], (oldData: { races: Race[], source_info: SourceInfo[] } | undefined) => {\n      if (!oldData) return { races: parsedRaces, source_info: [] };\n\n      // 1. Remove the placeholder error card for this adapter\n      const otherRaces = oldData.races.filter(race => race.source !== adapterName);\n\n      // 2. Merge the new races in\n      const updatedRaces = [...otherRaces, ...parsedRaces].sort(\n        (a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime()\n      );\n\n      // 3. Update source_info to remove the failed source\n      const updatedSourceInfo = oldData.source_info.filter(s => s.name !== adapterName);\n\n      return { races: updatedRaces, source_info: updatedSourceInfo };\n    });\n  };\n\n  const renderContent = () => {\n    // Priority 1: Backend process has failed.\n    if (backendStatus.state === 'error') {\n      return <BackendErrorPanel logs={backendStatus.logs} />;\n    }\n\n    if (backendStatus.state === 'stopped') {\n        return <EmptyState\n            title=\"Backend Service Stopped\"\n            message=\"The backend data service is not running. Please start it to see live race data.\"\n        />;\n    }\n\n    // Priority 2: Backend is starting or initial fetch is happening.\n    const isLoading = backendStatus.state === 'starting' || (connectionStatus === 'pending' && !data);\n    if (isLoading) {\n        return (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\">\n                {[...Array(8)].map((_, i) => <RaceCardSkeleton key={i} />)}\n            </div>\n        );\n    }\n\n    // Priority 3: API connection is offline.\n    if (connectionStatus === 'error') {\n      try {\n        const errorInfo = JSON.parse((errorDetails as Error).message);\n        return <ErrorDisplay error={errorInfo.error} />;\n      } catch (e) {\n        return <EmptyState\n            title=\"API Connection Offline\"\n            message={(errorDetails as Error)?.message || \"The backend is running, but the dashboard could not connect to its API.\"}\n            actionButton={<button onClick={() => refetch()} className=\"mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\">Retry Connection</button>}\n        />;\n      }\n    }\n\n    // Priority 4: No races found after a successful fetch.\n    if (!races || races.length === 0) {\n      return <EmptyState\n          title=\"No Races Found\"\n          message=\"No races matched the specified criteria for the selected date. Please try different filters.\"\n      />;\n    }\n\n    // Priority 5: Display the races (and any error placeholders).\n    return <RaceGrid races={races} />;\n  };\n\n  const getStatusIndicator = () => {\n    if (backendStatus.state === 'error') {\n      return { color: 'bg-red-500', text: 'Backend Error' };\n    }\n    if (backendStatus.state === 'stopped') {\n        return { color: 'bg-gray-500', text: 'Stopped' };\n    }\n    if (backendStatus.state === 'starting') {\n      return { color: 'bg-yellow-500', text: 'Backend Starting...' };\n    }\n    if (isLiveConnected) {\n      return { color: 'bg-cyan-500', text: 'Live' };\n    }\n    return { color: 'bg-yellow-500', text: 'Connecting...' };\n  };\n\n  const { color: statusColor, text: statusText } = getStatusIndicator();\n\n  return (\n    <>\n      <div className=\"space-y-6\">\n        <div className=\"flex justify-between items-start\">\n            <div className=\"text-left space-y-2\">\n                <h1 className=\"text-4xl font-bold text-white\">\ud83c\udfc7 Fortuna Faucet</h1>\n                <p className=\"text-slate-400\">\n                Last updated: {lastUpdate ? lastUpdate.toLocaleTimeString() : 'N/A'}\n                </p>\n            </div>\n            <div className=\"flex items-center gap-4\">\n                <button\n                    onClick={() => (connectionStatus === 'error' || backendStatus.state === 'error') && setIsModalOpen(true)}\n                    className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium text-white ${statusColor} ${(connectionStatus === 'error' || backendStatus.state === 'error') ? 'cursor-pointer hover:opacity-80' : 'cursor-default'}`}\n                    data-testid=\"status-indicator\"\n                >\n                    <span className={`w-2.5 h-2.5 rounded-full bg-white ${isLiveConnected ? 'animate-pulse' : ''}`}></span>\n                    {statusText}\n                </button>\n            </div>\n        </div>\n\n        <RaceFilters onParamsChange={handleParamsChange} isLoading={connectionStatus === 'pending'} refetch={refetch} />\n\n        {adapterErrors.map(error => (\n          <ManualOverridePanel\n            key={error.adapterName}\n            adapterName={error.adapterName}\n            attemptedUrl={error.attemptedUrl || 'URL not available'}\n            apiKey={apiKey}\n            onParseSuccess={handleParseSuccess}\n          />\n        ))}\n\n        {renderContent()}\n      </div>\n\n      <StatusDetailModal\n        isOpen={isModalOpen}\n        onClose={() => setIsModalOpen(false)}\n        status={{ title: 'Connection Error', details: (errorDetails as Error)?.message || 'No specific error message was provided.' }}\n      />\n    </>\n  );\n});\n",
    "web_service/frontend/app/components/RaceCard.tsx": "// web_platform/frontend/src/components/RaceCard.tsx\n'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport type { Race, Runner } from '../types/racing';\n\n// Local types removed, now importing from '../types/racing'\n\ninterface RaceCardProps {\n  race: Race;\n}\n\nconst Countdown: React.FC<{ startTime: string }> = ({ startTime }) => {\n  const [currentTime, setCurrentTime] = useState(new Date());\n\n  useEffect(() => {\n    const timer = setInterval(() => setCurrentTime(new Date()), 1000);\n    return () => clearInterval(timer);\n  }, []);\n\n  const getCountdown = (startTimeStr: string) => {\n    const postTime = new Date(startTimeStr);\n    const diff = postTime.getTime() - currentTime.getTime();\n\n    if (diff <= 0) return { text: \"RACE COMPLETE\", color: \"text-gray-500\" };\n\n    const minutes = Math.floor(diff / 60000);\n    const seconds = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');\n\n    let color = \"text-green-400\";\n    if (minutes < 2) color = \"text-red-500 font-bold animate-pulse\";\n    else if (minutes < 10) color = \"text-yellow-400\";\n\n    return { text: `${minutes}:${seconds} to post`, color };\n  };\n\n  const countdown = getCountdown(startTime);\n\n  return (\n    <span className={`font-mono text-sm ${countdown.color}`}>{countdown.text}</span>\n  );\n};\n\nexport const RaceCard: React.FC<RaceCardProps> = ({ race }) => {\n  const activeRunners = race.runners.filter(r => !r.scratched);\n  activeRunners.sort((a, b) => a.number - b.number);\n\n  const getUniqueSourcesCount = (runners: Runner[]): number => {\n    const sources = new Set();\n    runners.forEach(runner => {\n      if (runner.odds) {\n        Object.keys(runner.odds).forEach(source => sources.add(source));\n      }\n    });\n    return sources.size;\n  };\n\n  const getBestOdds = (runner: Runner): { odds: number, source: string } | null => {\n    if (!runner.odds) return null;\n  const validOdds = Object.values(runner.odds).filter(o => o.win !== null && o.win !== undefined && o.win < 999);\n    if (validOdds.length === 0) return null;\n  const best = validOdds.reduce((min, o) => (o.win ?? 999) < (min.win ?? 999) ? o : min);\n    return { odds: best.win!, source: best.source };\n  };\n\n  return (\n    <div className={`race-card-enhanced border rounded-lg p-4 bg-gray-800 shadow-lg hover:border-purple-500 transition-all ${race.qualification_score && race.qualification_score >= 80 ? 'card-premium' : 'border-gray-700'}`}>\n      {/* Header with Smart Status Indicators */}\n      <div className=\"flex items-center justify-between mb-4\">\n        <div className=\"flex items-center gap-3\">\n          <div>\n            <h2 className=\"text-2xl font-bold text-white\">{race.venue}</h2>\n            <div className=\"flex gap-2 text-sm text-gray-400\">\n              <span>Race {race.race_number}</span>\n              <span>\u2022</span>\n              <Countdown startTime={race.start_time} />\n            </div>\n            {race.favorite && (\n              <div className=\"flex items-center gap-2 mt-2 text-sm text-yellow-400\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path d=\"M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z\" />\n                </svg>\n                <span className=\"font-semibold\">Favorite: {race.favorite.name}</span>\n              </div>\n            )}\n          </div>\n        </div>\n\n        {race.qualification_score && (\n          <div className={`px-4 py-2 rounded-full text-center ${\n            race.qualification_score >= 80 ? 'bg-red-500/20 text-red-400 border border-red-500/30' :\n            race.qualification_score >= 60 ? 'bg-yellow-500/20 text-yellow-400 border border-yellow-500/30' :\n            'bg-green-500/20 text-green-400 border border-green-500/30'\n          }`}>\n            <div className=\"font-bold text-lg\">{race.qualification_score.toFixed(0)}%</div>\n            <div className=\"text-xs\">Score</div>\n          </div>\n        )}\n      </div>\n\n      {/* Race Conditions Grid */}\n      <div className=\"grid grid-cols-4 gap-2 mb-4 p-3 bg-gray-800/50 rounded-lg\">\n        <div className=\"text-center\">\n          <div className=\"text-xs text-gray-400\">Distance</div>\n          <div className=\"text-sm font-semibold text-white\">{race.distance || 'N/A'}</div>\n        </div>\n        <div className=\"text-center\">\n          <div className=\"text-xs text-gray-400\">Surface</div>\n          <div className=\"text-sm font-semibold text-white\">{race.surface || 'Dirt'}</div>\n        </div>\n        <div className=\"text-center\">\n          <div className=\"text-xs text-gray-400\">Field</div>\n          <div className=\"text-sm font-semibold text-white\">{activeRunners.length}</div>\n        </div>\n        <div className=\"text-center\">\n          <div className=\"text-xs text-gray-400\">Sources</div>\n          <div className=\"text-sm font-semibold text-white\">{getUniqueSourcesCount(race.runners)}</div>\n        </div>\n      </div>\n\n      {/* Interactive Runner Rows */}\n      <div className=\"runners-table space-y-2\">\n        {activeRunners.map((runner, idx) => {\n          const bestOddsInfo = getBestOdds(runner);\n          return (\n            <div key={runner.number} className=\"runner-row group hover:bg-purple-500/10 transition-all rounded-md p-3\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-4 flex-1\">\n                  <div className={`w-10 h-10 rounded-full flex items-center justify-center font-bold transition-all group-hover:scale-110 text-gray-900 shadow-lg ${idx === 0 ? 'bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-yellow-500/50' : idx === 1 ? 'bg-gradient-to-br from-gray-300 to-gray-500 shadow-gray-400/50' : idx === 2 ? 'bg-gradient-to-br from-orange-400 to-orange-600 shadow-orange-500/50' : 'bg-gray-700 text-gray-300'}`}>\n                    {runner.number}\n                  </div>\n                  <div className=\"flex flex-col\">\n                    <span className=\"font-bold text-white text-lg\">{runner.name}</span>\n                    <div className=\"flex gap-3 text-sm text-gray-400\">\n                      {runner.jockey && <span>J: {runner.jockey}</span>}\n                      {runner.trainer && <span>T: {runner.trainer}</span>}\n                    </div>\n                  </div>\n                </div>\n                {bestOddsInfo && (\n                  <div className=\"text-right\">\n                    <div className=\"text-2xl font-bold text-emerald-400\">{bestOddsInfo.odds.toFixed(2)}</div>\n                    <div className=\"text-xs text-gray-500\">via {bestOddsInfo.source}</div>\n                  </div>\n                )}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};",
    "web_service/frontend/app/components/StatusDetailModal.tsx": "// web_platform/frontend/src/components/StatusDetailModal.tsx\nimport React from 'react';\n\ninterface StatusDetailModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  status: {\n      title: string;\n      details: string | Record<string, any>;\n  };\n}\n\nexport const StatusDetailModal: React.FC<StatusDetailModalProps> = ({ isOpen, onClose, status }) => {\n  if (!isOpen) {\n    return null;\n  }\n\n  const { title, details } = status;\n  const isDetailsString = typeof details === 'string';\n\n  // Determine status color only if details is an object with a status property\n  const statusColor = !isDetailsString && (details.status === 'SUCCESS' || details.status === 'OK')\n    ? 'text-green-400'\n    : 'text-gray-300'; // Default color\n\n  return (\n    <div className=\"fixed inset-0 bg-black/60 flex items-center justify-center z-50\" onClick={onClose}>\n      <div className=\"bg-gray-800 border border-gray-700 rounded-lg shadow-xl p-6 max-w-lg w-full\" onClick={e => e.stopPropagation()}>\n        <div className=\"flex justify-between items-start mb-4\">\n          <h3 className=\"text-xl font-bold text-white\">{title}</h3>\n          <button onClick={onClose} className=\"text-gray-400 hover:text-white\">&times;</button>\n        </div>\n        <div className=\"space-y-2 text-sm max-h-96 overflow-y-auto pr-2\">\n            {isDetailsString ? (\n                <div className=\"text-gray-300 whitespace-pre-wrap bg-gray-900/50 p-4 rounded-md\">{details}</div>\n            ) : (\n                Object.entries(details).map(([key, value]) => (\n                    <div key={key} className=\"grid grid-cols-3 gap-4 border-b border-gray-700/50 py-2\">\n                    <span className=\"font-semibold text-gray-400 capitalize\">{key.replace(/_/g, ' ')}</span>\n                    <span className={`col-span-2 break-words ${key === 'status' ? statusColor : 'text-gray-300'}`}>\n                        {typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value)}\n                    </span>\n                    </div>\n                ))\n            )}\n        </div>\n        <button\n          onClick={onClose}\n          className=\"bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded w-full mt-6\"\n        >\n          Close\n        </button>\n      </div>\n    </div>\n  );\n};\n",
    "web_service/frontend/app/components/Tabs.tsx": "// src/components/Tabs.tsx\n'use client';\n\nimport React, { useState } from 'react';\n\ntype Tab = {\n  label: string;\n  content: React.ReactNode;\n};\n\ntype TabsProps = {\n  tabs: Tab[];\n};\n\nexport function Tabs({ tabs }: TabsProps) {\n  const [activeTab, setActiveTab] = useState(0);\n\n  return (\n    <div>\n      <div className=\"border-b border-slate-700\">\n        <nav className=\"-mb-px flex space-x-8\" aria-label=\"Tabs\">\n          {tabs.map((tab, index) => (\n            <button\n              key={tab.label}\n              onClick={() => setActiveTab(index)}\n              className={`${\n                activeTab === index\n                  ? 'border-blue-500 text-blue-400'\n                  : 'border-transparent text-slate-400 hover:text-slate-200 hover:border-slate-500'\n              } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors focus:outline-none`}\n            >\n              {tab.label}\n            </button>\n          ))}\n        </nav>\n      </div>\n      <div className=\"mt-8\">{tabs[activeTab].content}</div>\n    </div>\n  );\n}\n",
    "web_service/frontend/app/globals.css": "@tailwind base;\n@tailwind components;\n@tailwind utilities;",
    "web_service/frontend/app/hooks/useRealTimeRaces.ts": "import { useState, useEffect } from 'react';\nimport { io, Socket } from 'socket.io-client';\nimport { Race } from '../types/racing';\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';\n\nexport function useRealTimeRaces() {\n  const [races, setRaces] = useState<Race[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n\n  useEffect(() => {\n    const socket: Socket = io(API_URL);\n\n    socket.on('connect', () => setIsConnected(true));\n    socket.on('disconnect', () => setIsConnected(false));\n\n    socket.on('races_update', (data: { races: Race[] }) => {\n      if (data && Array.isArray(data.races)) {\n        setRaces(data.races);\n      }\n    });\n\n    // Cleanup on component unmount\n    return () => {\n      socket.disconnect();\n    };\n  }, []);\n\n  return { races, isConnected };\n}",
    "web_service/frontend/app/hooks/useWebSocket.ts": "// web_platform/frontend/src/hooks/useWebSocket.ts\n'use client';\n\nimport { useState, useEffect, useRef } from 'react';\n\ninterface WebSocketOptions {\n  apiKey: string | null;\n  port?: number | null; // Port is now optional\n}\n\nexport const useWebSocket = <T>(path: string, options: WebSocketOptions) => {\n  const [data, setData] = useState<T | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const webSocketRef = useRef<WebSocket | null>(null);\n\n  useEffect(() => {\n    if (!path || !options.apiKey) {\n      console.log('[useWebSocket] Missing path or API key. Aborting connection.');\n      if (webSocketRef.current) {\n        webSocketRef.current.close();\n      }\n      return;\n    }\n\n    // Use relative URL for same-origin, or build full URL if port is provided\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = options.port ? `localhost:${options.port}` : window.location.host;\n    const wsUrl = `${protocol}//${host}${path}?api_key=${options.apiKey}`;\n\n    console.log(`[useWebSocket] Attempting to connect to: ${wsUrl}`);\n\n    const ws = new WebSocket(wsUrl);\n    webSocketRef.current = ws;\n\n    ws.onopen = () => {\n      console.log('WebSocket connection established.');\n      setIsConnected(true);\n    };\n\n    ws.onmessage = (event) => {\n      try {\n        const messageData = JSON.parse(event.data);\n        setData(messageData);\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n      }\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    ws.onclose = (event) => {\n      console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n      setIsConnected(false);\n      webSocketRef.current = null;\n    };\n\n    return () => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n    };\n  }, [path, options.apiKey, options.port]);\n\n  return { data, isConnected };\n};\n",
    "web_service/frontend/app/layout.tsx": "// web_platform/frontend/app/layout.tsx\nimport './globals.css';\nimport type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport Providers from './Providers';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'Fortuna',\n  description: 'Real-time horse racing analysis.',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body className={`${inter.className} bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100`}>\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  );\n}",
    "web_service/frontend/postcss.config.js": "module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};",
    "web_service/frontend/public/manifest.json": "{\n  \"name\": \"Fortuna Faucet Command Deck\",\n  \"short_name\": \"Fortuna\",\n  \"description\": \"Real-time racing analysis.\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#1a202c\",\n  \"theme_color\": \"#1a202c\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n",
    "web_service/frontend/public/workbox-4754cb34.js": "define([\"exports\"],function(t){\"use strict\";try{self[\"workbox:core:6.5.4\"]&&_()}catch(t){}const e=(t,...e)=>{let s=t;return e.length>0&&(s+=` :: ${JSON.stringify(e)}`),s};class s extends Error{constructor(t,s){super(e(t,s)),this.name=t,this.details=s}}try{self[\"workbox:routing:6.5.4\"]&&_()}catch(t){}const n=t=>t&&\"object\"==typeof t?t:{handle:t};class r{constructor(t,e,s=\"GET\"){this.handler=n(e),this.match=t,this.method=s}setCatchHandler(t){this.catchHandler=n(t)}}class i extends r{constructor(t,e,s){super(({url:e})=>{const s=t.exec(e.href);if(s&&(e.origin===location.origin||0===s.index))return s.slice(1)},e,s)}}class a{constructor(){this.t=new Map,this.i=new Map}get routes(){return this.t}addFetchListener(){self.addEventListener(\"fetch\",t=>{const{request:e}=t,s=this.handleRequest({request:e,event:t});s&&t.respondWith(s)})}addCacheListener(){self.addEventListener(\"message\",t=>{if(t.data&&\"CACHE_URLS\"===t.data.type){const{payload:e}=t.data,s=Promise.all(e.urlsToCache.map(e=>{\"string\"==typeof e&&(e=[e]);const s=new Request(...e);return this.handleRequest({request:s,event:t})}));t.waitUntil(s),t.ports&&t.ports[0]&&s.then(()=>t.ports[0].postMessage(!0))}})}handleRequest({request:t,event:e}){const s=new URL(t.url,location.href);if(!s.protocol.startsWith(\"http\"))return;const n=s.origin===location.origin,{params:r,route:i}=this.findMatchingRoute({event:e,request:t,sameOrigin:n,url:s});let a=i&&i.handler;const o=t.method;if(!a&&this.i.has(o)&&(a=this.i.get(o)),!a)return;let c;try{c=a.handle({url:s,request:t,event:e,params:r})}catch(t){c=Promise.reject(t)}const h=i&&i.catchHandler;return c instanceof Promise&&(this.o||h)&&(c=c.catch(async n=>{if(h)try{return await h.handle({url:s,request:t,event:e,params:r})}catch(t){t instanceof Error&&(n=t)}if(this.o)return this.o.handle({url:s,request:t,event:e});throw n})),c}findMatchingRoute({url:t,sameOrigin:e,request:s,event:n}){const r=this.t.get(s.method)||[];for(const i of r){let r;const a=i.match({url:t,sameOrigin:e,request:s,event:n});if(a)return r=a,(Array.isArray(r)&&0===r.length||a.constructor===Object&&0===Object.keys(a).length||\"boolean\"==typeof a)&&(r=void 0),{route:i,params:r}}return{}}setDefaultHandler(t,e=\"GET\"){this.i.set(e,n(t))}setCatchHandler(t){this.o=n(t)}registerRoute(t){this.t.has(t.method)||this.t.set(t.method,[]),this.t.get(t.method).push(t)}unregisterRoute(t){if(!this.t.has(t.method))throw new s(\"unregister-route-but-not-found-with-method\",{method:t.method});const e=this.t.get(t.method).indexOf(t);if(!(e>-1))throw new s(\"unregister-route-route-not-registered\");this.t.get(t.method).splice(e,1)}}let o;const c=()=>(o||(o=new a,o.addFetchListener(),o.addCacheListener()),o);function h(t,e,n){let a;if(\"string\"==typeof t){const s=new URL(t,location.href);a=new r(({url:t})=>t.href===s.href,e,n)}else if(t instanceof RegExp)a=new i(t,e,n);else if(\"function\"==typeof t)a=new r(t,e,n);else{if(!(t instanceof r))throw new s(\"unsupported-route-type\",{moduleName:\"workbox-routing\",funcName:\"registerRoute\",paramName:\"capture\"});a=t}return c().registerRoute(a),a}try{self[\"workbox:strategies:6.5.4\"]&&_()}catch(t){}const u={cacheWillUpdate:async({response:t})=>200===t.status||0===t.status?t:null},l={googleAnalytics:\"googleAnalytics\",precache:\"precache-v2\",prefix:\"workbox\",runtime:\"runtime\",suffix:\"undefined\"!=typeof registration?registration.scope:\"\"},f=t=>[l.prefix,t,l.suffix].filter(t=>t&&t.length>0).join(\"-\"),w=t=>t||f(l.precache),d=t=>t||f(l.runtime);function p(t,e){const s=new URL(t);for(const t of e)s.searchParams.delete(t);return s.href}class y{constructor(){this.promise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}}const g=new Set;function m(t){return\"string\"==typeof t?new Request(t):t}class v{constructor(t,e){this.h={},Object.assign(this,e),this.event=e.event,this.u=t,this.l=new y,this.p=[],this.m=[...t.plugins],this.v=new Map;for(const t of this.m)this.v.set(t,{});this.event.waitUntil(this.l.promise)}async fetch(t){const{event:e}=this;let n=m(t);if(\"navigate\"===n.mode&&e instanceof FetchEvent&&e.preloadResponse){const t=await e.preloadResponse;if(t)return t}const r=this.hasCallback(\"fetchDidFail\")?n.clone():null;try{for(const t of this.iterateCallbacks(\"requestWillFetch\"))n=await t({request:n.clone(),event:e})}catch(t){if(t instanceof Error)throw new s(\"plugin-error-request-will-fetch\",{thrownErrorMessage:t.message})}const i=n.clone();try{let t;t=await fetch(n,\"navigate\"===n.mode?void 0:this.u.fetchOptions);for(const s of this.iterateCallbacks(\"fetchDidSucceed\"))t=await s({event:e,request:i,response:t});return t}catch(t){throw r&&await this.runCallbacks(\"fetchDidFail\",{error:t,event:e,originalRequest:r.clone(),request:i.clone()}),t}}async fetchAndCachePut(t){const e=await this.fetch(t),s=e.clone();return this.waitUntil(this.cachePut(t,s)),e}async cacheMatch(t){const e=m(t);let s;const{cacheName:n,matchOptions:r}=this.u,i=await this.getCacheKey(e,\"read\"),a=Object.assign(Object.assign({},r),{cacheName:n});s=await caches.match(i,a);for(const t of this.iterateCallbacks(\"cachedResponseWillBeUsed\"))s=await t({cacheName:n,matchOptions:r,cachedResponse:s,request:i,event:this.event})||void 0;return s}async cachePut(t,e){const n=m(t);var r;await(r=0,new Promise(t=>setTimeout(t,r)));const i=await this.getCacheKey(n,\"write\");if(!e)throw new s(\"cache-put-with-no-response\",{url:(a=i.url,new URL(String(a),location.href).href.replace(new RegExp(`^${location.origin}`),\"\"))});var a;const o=await this.R(e);if(!o)return!1;const{cacheName:c,matchOptions:h}=this.u,u=await self.caches.open(c),l=this.hasCallback(\"cacheDidUpdate\"),f=l?await async function(t,e,s,n){const r=p(e.url,s);if(e.url===r)return t.match(e,n);const i=Object.assign(Object.assign({},n),{ignoreSearch:!0}),a=await t.keys(e,i);for(const e of a)if(r===p(e.url,s))return t.match(e,n)}(u,i.clone(),[\"__WB_REVISION__\"],h):null;try{await u.put(i,l?o.clone():o)}catch(t){if(t instanceof Error)throw\"QuotaExceededError\"===t.name&&await async function(){for(const t of g)await t()}(),t}for(const t of this.iterateCallbacks(\"cacheDidUpdate\"))await t({cacheName:c,oldResponse:f,newResponse:o.clone(),request:i,event:this.event});return!0}async getCacheKey(t,e){const s=`${t.url} | ${e}`;if(!this.h[s]){let n=t;for(const t of this.iterateCallbacks(\"cacheKeyWillBeUsed\"))n=m(await t({mode:e,request:n,event:this.event,params:this.params}));this.h[s]=n}return this.h[s]}hasCallback(t){for(const e of this.u.plugins)if(t in e)return!0;return!1}async runCallbacks(t,e){for(const s of this.iterateCallbacks(t))await s(e)}*iterateCallbacks(t){for(const e of this.u.plugins)if(\"function\"==typeof e[t]){const s=this.v.get(e),n=n=>{const r=Object.assign(Object.assign({},n),{state:s});return e[t](r)};yield n}}waitUntil(t){return this.p.push(t),t}async doneWaiting(){let t;for(;t=this.p.shift();)await t}destroy(){this.l.resolve(null)}async R(t){let e=t,s=!1;for(const t of this.iterateCallbacks(\"cacheWillUpdate\"))if(e=await t({request:this.request,response:e,event:this.event})||void 0,s=!0,!e)break;return s||e&&200!==e.status&&(e=void 0),e}}class R{constructor(t={}){this.cacheName=d(t.cacheName),this.plugins=t.plugins||[],this.fetchOptions=t.fetchOptions,this.matchOptions=t.matchOptions}handle(t){const[e]=this.handleAll(t);return e}handleAll(t){t instanceof FetchEvent&&(t={event:t,request:t.request});const e=t.event,s=\"string\"==typeof t.request?new Request(t.request):t.request,n=\"params\"in t?t.params:void 0,r=new v(this,{event:e,request:s,params:n}),i=this.q(r,s,e);return[i,this.D(i,r,s,e)]}async q(t,e,n){let r;await t.runCallbacks(\"handlerWillStart\",{event:n,request:e});try{if(r=await this.U(e,t),!r||\"error\"===r.type)throw new s(\"no-response\",{url:e.url})}catch(s){if(s instanceof Error)for(const i of t.iterateCallbacks(\"handlerDidError\"))if(r=await i({error:s,event:n,request:e}),r)break;if(!r)throw s}for(const s of t.iterateCallbacks(\"handlerWillRespond\"))r=await s({event:n,request:e,response:r});return r}async D(t,e,s,n){let r,i;try{r=await t}catch(i){}try{await e.runCallbacks(\"handlerDidRespond\",{event:n,request:s,response:r}),await e.doneWaiting()}catch(t){t instanceof Error&&(i=t)}if(await e.runCallbacks(\"handlerDidComplete\",{event:n,request:s,response:r,error:i}),e.destroy(),i)throw i}}function b(t){t.then(()=>{})}function q(){return q=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var n in s)({}).hasOwnProperty.call(s,n)&&(t[n]=s[n])}return t},q.apply(null,arguments)}let D,U;const x=new WeakMap,L=new WeakMap,I=new WeakMap,C=new WeakMap,E=new WeakMap;let N={get(t,e,s){if(t instanceof IDBTransaction){if(\"done\"===e)return L.get(t);if(\"objectStoreNames\"===e)return t.objectStoreNames||I.get(t);if(\"store\"===e)return s.objectStoreNames[1]?void 0:s.objectStore(s.objectStoreNames[0])}return k(t[e])},set:(t,e,s)=>(t[e]=s,!0),has:(t,e)=>t instanceof IDBTransaction&&(\"done\"===e||\"store\"===e)||e in t};function O(t){return t!==IDBDatabase.prototype.transaction||\"objectStoreNames\"in IDBTransaction.prototype?(U||(U=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(t)?function(...e){return t.apply(B(this),e),k(x.get(this))}:function(...e){return k(t.apply(B(this),e))}:function(e,...s){const n=t.call(B(this),e,...s);return I.set(n,e.sort?e.sort():[e]),k(n)}}function T(t){return\"function\"==typeof t?O(t):(t instanceof IDBTransaction&&function(t){if(L.has(t))return;const e=new Promise((e,s)=>{const n=()=>{t.removeEventListener(\"complete\",r),t.removeEventListener(\"error\",i),t.removeEventListener(\"abort\",i)},r=()=>{e(),n()},i=()=>{s(t.error||new DOMException(\"AbortError\",\"AbortError\")),n()};t.addEventListener(\"complete\",r),t.addEventListener(\"error\",i),t.addEventListener(\"abort\",i)});L.set(t,e)}(t),e=t,(D||(D=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])).some(t=>e instanceof t)?new Proxy(t,N):t);var e}function k(t){if(t instanceof IDBRequest)return function(t){const e=new Promise((e,s)=>{const n=()=>{t.removeEventListener(\"success\",r),t.removeEventListener(\"error\",i)},r=()=>{e(k(t.result)),n()},i=()=>{s(t.error),n()};t.addEventListener(\"success\",r),t.addEventListener(\"error\",i)});return e.then(e=>{e instanceof IDBCursor&&x.set(e,t)}).catch(()=>{}),E.set(e,t),e}(t);if(C.has(t))return C.get(t);const e=T(t);return e!==t&&(C.set(t,e),E.set(e,t)),e}const B=t=>E.get(t);const P=[\"get\",\"getKey\",\"getAll\",\"getAllKeys\",\"count\"],M=[\"put\",\"add\",\"delete\",\"clear\"],W=new Map;function j(t,e){if(!(t instanceof IDBDatabase)||e in t||\"string\"!=typeof e)return;if(W.get(e))return W.get(e);const s=e.replace(/FromIndex$/,\"\"),n=e!==s,r=M.includes(s);if(!(s in(n?IDBIndex:IDBObjectStore).prototype)||!r&&!P.includes(s))return;const i=async function(t,...e){const i=this.transaction(t,r?\"readwrite\":\"readonly\");let a=i.store;return n&&(a=a.index(e.shift())),(await Promise.all([a[s](...e),r&&i.done]))[0]};return W.set(e,i),i}N=(t=>q({},t,{get:(e,s,n)=>j(e,s)||t.get(e,s,n),has:(e,s)=>!!j(e,s)||t.has(e,s)}))(N);try{self[\"workbox:expiration:6.5.4\"]&&_()}catch(t){}const S=\"cache-entries\",K=t=>{const e=new URL(t,location.href);return e.hash=\"\",e.href};class A{constructor(t){this._=null,this.L=t}I(t){const e=t.createObjectStore(S,{keyPath:\"id\"});e.createIndex(\"cacheName\",\"cacheName\",{unique:!1}),e.createIndex(\"timestamp\",\"timestamp\",{unique:!1})}C(t){this.I(t),this.L&&function(t,{blocked:e}={}){const s=indexedDB.deleteDatabase(t);e&&s.addEventListener(\"blocked\",t=>e(t.oldVersion,t)),k(s).then(()=>{})}(this.L)}async setTimestamp(t,e){const s={url:t=K(t),timestamp:e,cacheName:this.L,id:this.N(t)},n=(await this.getDb()).transaction(S,\"readwrite\",{durability:\"relaxed\"});await n.store.put(s),await n.done}async getTimestamp(t){const e=await this.getDb(),s=await e.get(S,this.N(t));return null==s?void 0:s.timestamp}async expireEntries(t,e){const s=await this.getDb();let n=await s.transaction(S).store.index(\"timestamp\").openCursor(null,\"prev\");const r=[];let i=0;for(;n;){const s=n.value;s.cacheName===this.L&&(t&&s.timestamp<t||e&&i>=e?r.push(n.value):i++),n=await n.continue()}const a=[];for(const t of r)await s.delete(S,t.id),a.push(t.url);return a}N(t){return this.L+\"|\"+K(t)}async getDb(){return this._||(this._=await function(t,e,{blocked:s,upgrade:n,blocking:r,terminated:i}={}){const a=indexedDB.open(t,e),o=k(a);return n&&a.addEventListener(\"upgradeneeded\",t=>{n(k(a.result),t.oldVersion,t.newVersion,k(a.transaction),t)}),s&&a.addEventListener(\"blocked\",t=>s(t.oldVersion,t.newVersion,t)),o.then(t=>{i&&t.addEventListener(\"close\",()=>i()),r&&t.addEventListener(\"versionchange\",t=>r(t.oldVersion,t.newVersion,t))}).catch(()=>{}),o}(\"workbox-expiration\",1,{upgrade:this.C.bind(this)})),this._}}class F{constructor(t,e={}){this.O=!1,this.T=!1,this.k=e.maxEntries,this.B=e.maxAgeSeconds,this.P=e.matchOptions,this.L=t,this.M=new A(t)}async expireEntries(){if(this.O)return void(this.T=!0);this.O=!0;const t=this.B?Date.now()-1e3*this.B:0,e=await this.M.expireEntries(t,this.k),s=await self.caches.open(this.L);for(const t of e)await s.delete(t,this.P);this.O=!1,this.T&&(this.T=!1,b(this.expireEntries()))}async updateTimestamp(t){await this.M.setTimestamp(t,Date.now())}async isURLExpired(t){if(this.B){const e=await this.M.getTimestamp(t),s=Date.now()-1e3*this.B;return void 0===e||e<s}return!1}async delete(){this.T=!1,await this.M.expireEntries(1/0)}}try{self[\"workbox:range-requests:6.5.4\"]&&_()}catch(t){}async function H(t,e){try{if(206===e.status)return e;const n=t.headers.get(\"range\");if(!n)throw new s(\"no-range-header\");const r=function(t){const e=t.trim().toLowerCase();if(!e.startsWith(\"bytes=\"))throw new s(\"unit-must-be-bytes\",{normalizedRangeHeader:e});if(e.includes(\",\"))throw new s(\"single-range-only\",{normalizedRangeHeader:e});const n=/(\\d*)-(\\d*)/.exec(e);if(!n||!n[1]&&!n[2])throw new s(\"invalid-range-values\",{normalizedRangeHeader:e});return{start:\"\"===n[1]?void 0:Number(n[1]),end:\"\"===n[2]?void 0:Number(n[2])}}(n),i=await e.blob(),a=function(t,e,n){const r=t.size;if(n&&n>r||e&&e<0)throw new s(\"range-not-satisfiable\",{size:r,end:n,start:e});let i,a;return void 0!==e&&void 0!==n?(i=e,a=n+1):void 0!==e&&void 0===n?(i=e,a=r):void 0!==n&&void 0===e&&(i=r-n,a=r),{start:i,end:a}}(i,r.start,r.end),o=i.slice(a.start,a.end),c=o.size,h=new Response(o,{status:206,statusText:\"Partial Content\",headers:e.headers});return h.headers.set(\"Content-Length\",String(c)),h.headers.set(\"Content-Range\",`bytes ${a.start}-${a.end-1}/${i.size}`),h}catch(t){return new Response(\"\",{status:416,statusText:\"Range Not Satisfiable\"})}}function $(t,e){const s=e();return t.waitUntil(s),s}try{self[\"workbox:precaching:6.5.4\"]&&_()}catch(t){}function z(t){if(!t)throw new s(\"add-to-cache-list-unexpected-type\",{entry:t});if(\"string\"==typeof t){const e=new URL(t,location.href);return{cacheKey:e.href,url:e.href}}const{revision:e,url:n}=t;if(!n)throw new s(\"add-to-cache-list-unexpected-type\",{entry:t});if(!e){const t=new URL(n,location.href);return{cacheKey:t.href,url:t.href}}const r=new URL(n,location.href),i=new URL(n,location.href);return r.searchParams.set(\"__WB_REVISION__\",e),{cacheKey:r.href,url:i.href}}class G{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:t,state:e})=>{e&&(e.originalRequest=t)},this.cachedResponseWillBeUsed=async({event:t,state:e,cachedResponse:s})=>{if(\"install\"===t.type&&e&&e.originalRequest&&e.originalRequest instanceof Request){const t=e.originalRequest.url;s?this.notUpdatedURLs.push(t):this.updatedURLs.push(t)}return s}}}class V{constructor({precacheController:t}){this.cacheKeyWillBeUsed=async({request:t,params:e})=>{const s=(null==e?void 0:e.cacheKey)||this.W.getCacheKeyForURL(t.url);return s?new Request(s,{headers:t.headers}):t},this.W=t}}let J,Q;async function X(t,e){let n=null;if(t.url){n=new URL(t.url).origin}if(n!==self.location.origin)throw new s(\"cross-origin-copy-response\",{origin:n});const r=t.clone(),i={headers:new Headers(r.headers),status:r.status,statusText:r.statusText},a=e?e(i):i,o=function(){if(void 0===J){const t=new Response(\"\");if(\"body\"in t)try{new Response(t.body),J=!0}catch(t){J=!1}J=!1}return J}()?r.body:await r.blob();return new Response(o,a)}class Y extends R{constructor(t={}){t.cacheName=w(t.cacheName),super(t),this.j=!1!==t.fallbackToNetwork,this.plugins.push(Y.copyRedirectedCacheableResponsesPlugin)}async U(t,e){const s=await e.cacheMatch(t);return s||(e.event&&\"install\"===e.event.type?await this.S(t,e):await this.K(t,e))}async K(t,e){let n;const r=e.params||{};if(!this.j)throw new s(\"missing-precache-entry\",{cacheName:this.cacheName,url:t.url});{const s=r.integrity,i=t.integrity,a=!i||i===s;n=await e.fetch(new Request(t,{integrity:\"no-cors\"!==t.mode?i||s:void 0})),s&&a&&\"no-cors\"!==t.mode&&(this.A(),await e.cachePut(t,n.clone()))}return n}async S(t,e){this.A();const n=await e.fetch(t);if(!await e.cachePut(t,n.clone()))throw new s(\"bad-precaching-response\",{url:t.url,status:n.status});return n}A(){let t=null,e=0;for(const[s,n]of this.plugins.entries())n!==Y.copyRedirectedCacheableResponsesPlugin&&(n===Y.defaultPrecacheCacheabilityPlugin&&(t=s),n.cacheWillUpdate&&e++);0===e?this.plugins.push(Y.defaultPrecacheCacheabilityPlugin):e>1&&null!==t&&this.plugins.splice(t,1)}}Y.defaultPrecacheCacheabilityPlugin={cacheWillUpdate:async({response:t})=>!t||t.status>=400?null:t},Y.copyRedirectedCacheableResponsesPlugin={cacheWillUpdate:async({response:t})=>t.redirected?await X(t):t};class Z{constructor({cacheName:t,plugins:e=[],fallbackToNetwork:s=!0}={}){this.F=new Map,this.H=new Map,this.$=new Map,this.u=new Y({cacheName:w(t),plugins:[...e,new V({precacheController:this})],fallbackToNetwork:s}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this.u}precache(t){this.addToCacheList(t),this.G||(self.addEventListener(\"install\",this.install),self.addEventListener(\"activate\",this.activate),this.G=!0)}addToCacheList(t){const e=[];for(const n of t){\"string\"==typeof n?e.push(n):n&&void 0===n.revision&&e.push(n.url);const{cacheKey:t,url:r}=z(n),i=\"string\"!=typeof n&&n.revision?\"reload\":\"default\";if(this.F.has(r)&&this.F.get(r)!==t)throw new s(\"add-to-cache-list-conflicting-entries\",{firstEntry:this.F.get(r),secondEntry:t});if(\"string\"!=typeof n&&n.integrity){if(this.$.has(t)&&this.$.get(t)!==n.integrity)throw new s(\"add-to-cache-list-conflicting-integrities\",{url:r});this.$.set(t,n.integrity)}if(this.F.set(r,t),this.H.set(r,i),e.length>0){const t=`Workbox is precaching URLs without revision info: ${e.join(\", \")}\\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(t)}}}install(t){return $(t,async()=>{const e=new G;this.strategy.plugins.push(e);for(const[e,s]of this.F){const n=this.$.get(s),r=this.H.get(e),i=new Request(e,{integrity:n,cache:r,credentials:\"same-origin\"});await Promise.all(this.strategy.handleAll({params:{cacheKey:s},request:i,event:t}))}const{updatedURLs:s,notUpdatedURLs:n}=e;return{updatedURLs:s,notUpdatedURLs:n}})}activate(t){return $(t,async()=>{const t=await self.caches.open(this.strategy.cacheName),e=await t.keys(),s=new Set(this.F.values()),n=[];for(const r of e)s.has(r.url)||(await t.delete(r),n.push(r.url));return{deletedURLs:n}})}getURLsToCacheKeys(){return this.F}getCachedURLs(){return[...this.F.keys()]}getCacheKeyForURL(t){const e=new URL(t,location.href);return this.F.get(e.href)}getIntegrityForCacheKey(t){return this.$.get(t)}async matchPrecache(t){const e=t instanceof Request?t.url:t,s=this.getCacheKeyForURL(e);if(s){return(await self.caches.open(this.strategy.cacheName)).match(s)}}createHandlerBoundToURL(t){const e=this.getCacheKeyForURL(t);if(!e)throw new s(\"non-precached-url\",{url:t});return s=>(s.request=new Request(t),s.params=Object.assign({cacheKey:e},s.params),this.strategy.handle(s))}}const tt=()=>(Q||(Q=new Z),Q);class et extends r{constructor(t,e){super(({request:s})=>{const n=t.getURLsToCacheKeys();for(const r of function*(t,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:s=\"index.html\",cleanURLs:n=!0,urlManipulation:r}={}){const i=new URL(t,location.href);i.hash=\"\",yield i.href;const a=function(t,e=[]){for(const s of[...t.searchParams.keys()])e.some(t=>t.test(s))&&t.searchParams.delete(s);return t}(i,e);if(yield a.href,s&&a.pathname.endsWith(\"/\")){const t=new URL(a.href);t.pathname+=s,yield t.href}if(n){const t=new URL(a.href);t.pathname+=\".html\",yield t.href}if(r){const t=r({url:i});for(const e of t)yield e.href}}(s.url,e)){const e=n.get(r);if(e){return{cacheKey:e,integrity:t.getIntegrityForCacheKey(e)}}}},t.strategy)}}t.CacheFirst=class extends R{async U(t,e){let n,r=await e.cacheMatch(t);if(!r)try{r=await e.fetchAndCachePut(t)}catch(t){t instanceof Error&&(n=t)}if(!r)throw new s(\"no-response\",{url:t.url,error:n});return r}},t.ExpirationPlugin=class{constructor(t={}){this.cachedResponseWillBeUsed=async({event:t,request:e,cacheName:s,cachedResponse:n})=>{if(!n)return null;const r=this.V(n),i=this.J(s);b(i.expireEntries());const a=i.updateTimestamp(e.url);if(t)try{t.waitUntil(a)}catch(t){}return r?n:null},this.cacheDidUpdate=async({cacheName:t,request:e})=>{const s=this.J(t);await s.updateTimestamp(e.url),await s.expireEntries()},this.X=t,this.B=t.maxAgeSeconds,this.Y=new Map,t.purgeOnQuotaError&&function(t){g.add(t)}(()=>this.deleteCacheAndMetadata())}J(t){if(t===d())throw new s(\"expire-custom-caches-only\");let e=this.Y.get(t);return e||(e=new F(t,this.X),this.Y.set(t,e)),e}V(t){if(!this.B)return!0;const e=this.Z(t);if(null===e)return!0;return e>=Date.now()-1e3*this.B}Z(t){if(!t.headers.has(\"date\"))return null;const e=t.headers.get(\"date\"),s=new Date(e).getTime();return isNaN(s)?null:s}async deleteCacheAndMetadata(){for(const[t,e]of this.Y)await self.caches.delete(t),await e.delete();this.Y=new Map}},t.NetworkFirst=class extends R{constructor(t={}){super(t),this.plugins.some(t=>\"cacheWillUpdate\"in t)||this.plugins.unshift(u),this.tt=t.networkTimeoutSeconds||0}async U(t,e){const n=[],r=[];let i;if(this.tt){const{id:s,promise:a}=this.et({request:t,logs:n,handler:e});i=s,r.push(a)}const a=this.st({timeoutId:i,request:t,logs:n,handler:e});r.push(a);const o=await e.waitUntil((async()=>await e.waitUntil(Promise.race(r))||await a)());if(!o)throw new s(\"no-response\",{url:t.url});return o}et({request:t,logs:e,handler:s}){let n;return{promise:new Promise(e=>{n=setTimeout(async()=>{e(await s.cacheMatch(t))},1e3*this.tt)}),id:n}}async st({timeoutId:t,request:e,logs:s,handler:n}){let r,i;try{i=await n.fetchAndCachePut(e)}catch(t){t instanceof Error&&(r=t)}return t&&clearTimeout(t),!r&&i||(i=await n.cacheMatch(e)),i}},t.RangeRequestsPlugin=class{constructor(){this.cachedResponseWillBeUsed=async({request:t,cachedResponse:e})=>e&&t.headers.has(\"range\")?await H(t,e):e}},t.StaleWhileRevalidate=class extends R{constructor(t={}){super(t),this.plugins.some(t=>\"cacheWillUpdate\"in t)||this.plugins.unshift(u)}async U(t,e){const n=e.fetchAndCachePut(t).catch(()=>{});e.waitUntil(n);let r,i=await e.cacheMatch(t);if(i);else try{i=await n}catch(t){t instanceof Error&&(r=t)}if(!i)throw new s(\"no-response\",{url:t.url,error:r});return i}},t.cleanupOutdatedCaches=function(){self.addEventListener(\"activate\",t=>{const e=w();t.waitUntil((async(t,e=\"-precache-\")=>{const s=(await self.caches.keys()).filter(s=>s.includes(e)&&s.includes(self.registration.scope)&&s!==t);return await Promise.all(s.map(t=>self.caches.delete(t))),s})(e).then(t=>{}))})},t.clientsClaim=function(){self.addEventListener(\"activate\",()=>self.clients.claim())},t.precacheAndRoute=function(t,e){!function(t){tt().precache(t)}(t),function(t){const e=tt();h(new et(e,t))}(e)},t.registerRoute=h});\n",
    "wix/WixUI_CustomInstallDir.wxs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\"\n     xmlns:WixUI=\"http://schemas.microsoft.com/wix/WixUIExtension\">\n  <Fragment>\n    <UI Id=\"WixUI_CustomInstallDir\">\n        <DialogRef Id=\"BrowseDlg\" />\n        <DialogRef Id=\"DiskCostDlg\" />\n        <DialogRef Id=\"ErrorDlg\" />\n        <DialogRef Id=\"FatalError\" />\n        <DialogRef Id=\"FilesInUse\" />\n        <DialogRef Id=\"MsiRMFilesInUse\" />\n        <DialogRef Id=\"PrepareDlg\" />\n        <DialogRef Id=\"UserExit\" />\n        <DialogRef Id=\"WelcomeDlg\" />\n        <DialogRef Id=\"InstallDirDlg\" />\n        <DialogRef Id=\"VerifyReadyDlg\" />\n\n        <!-- Use our custom progress dialog instead of the default -->\n        <DialogRef Id=\"InstallProgressDlg\" />\n\n        <Publish Dialog=\"WelcomeDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"InstallDirDlg\">1</Publish>\n        <Publish Dialog=\"InstallDirDlg\" Control=\"Back\" Event=\"NewDialog\" Value=\"WelcomeDlg\">1</Publish>\n        <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"SetTargetPath\" Value=\"[WIXUI_INSTALLDIR]\" Order=\"1\" />\n        <Publish Dialog=\"InstallDirDlg\" Control=\"Next\" Event=\"NewDialog\" Value=\"VerifyReadyDlg\" Order=\"2\">1</Publish>\n        <Publish Dialog=\"VerifyReadyDlg\" Control=\"Back\" Event=\"NewDialog\" Value=\"InstallDirDlg\" Order=\"1\">NOT Installed</Publish>\n        <Publish Dialog=\"VerifyReadyDlg\" Control=\"Back\" Event=\"NewDialog\" Value=\"MaintenanceTypeDlg\" Order=\"2\">Installed</Publish>\n    </UI>\n  </Fragment>\n</Wix>\n",
    "wix/product_webservice.wxs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\"\n     xmlns:fire=\"http://schemas.microsoft.com/wix/FirewallExtension\"\n     xmlns:util=\"http://schemas.microsoft.com/wix/UtilExtension\">\n\n  <Product Id=\"*\"\n           Name=\"Fortuna Web Service\"\n           Language=\"1033\"\n           Version=\"$(var.Version)\"\n           Manufacturer=\"Fortuna Development Team\"\n           UpgradeCode=\"A3A4A3B6-2313-4375-9A97-15206C81454A\">\n\n    <Package InstallerVersion=\"200\" Compressed=\"yes\" InstallScope=\"perMachine\" />\n    <MajorUpgrade DowngradeErrorMessage=\"A newer version of [ProductName] is already installed.\" />\n    <MediaTemplate EmbedCab=\"yes\" />\n\n    <Property Id=\"ARPNOREPAIR\" Value=\"no\" />\n    <Property Id=\"ARPNOMODIFY\" Value=\"yes\" />\n\n    <UI>\n      <UIRef Id=\"WixUI_Minimal\" />\n    </UI>\n\n    <WixVariable Id=\"WixUILicenseRtf\" Value=\"electron\\assets\\license.rtf\"/>\n    <WixVariable Id=\"WixUIBannerBmp\"  Value=\"electron\\assets\\banner.bmp\"/>\n    <WixVariable Id=\"WixUIDialogBmp\"  Value=\"electron\\assets\\dialog.bmp\"/>\n\n    <Feature Id=\"ProductFeature\" Title=\"Fortuna Web Service\" Level=\"1\">\n      <ComponentGroupRef Id=\"WebServiceComponents\" />\n      <ComponentRef Id=\"ApplicationShortcut\" />\n    </Feature>\n  </Product>\n\n  <Fragment>\n    <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n      <Directory Id=\"ProgramFilesFolder\">\n        <Directory Id=\"INSTALLDIR\" Name=\"FortunaWebService\"/>\n      </Directory>\n      <Directory Id=\"ProgramMenuFolder\">\n        <Directory Id=\"ApplicationProgramsFolder\" Name=\"Fortuna Web Service\"/>\n      </Directory>\n      <Directory Id=\"CommonAppDataFolder\">\n        <Directory Id=\"FortunaData\" Name=\"FortunaWebService\"/>\n      </Directory>\n    </Directory>\n  </Fragment>\n\n  <Fragment>\n    <ComponentGroup Id=\"WebServiceComponents\" Directory=\"INSTALLDIR\">\n      <Component Id=\"WebServiceExecutable\" Guid=\"3F2A4A9C-4055-4D62-812E-B715A0123594\">\n        <File Id=\"WebServiceExe\" Source=\"staging/fortuna-webservice.exe\" KeyPath=\"yes\"/>\n        <ServiceInstall Id=\"FortunaWebService\"\n                        Name=\"FortunaWebService\"\n                        DisplayName=\"Fortuna Web Service\"\n                        Description=\"Provides live odds and race data via a web interface.\"\n                        Start=\"auto\"\n                        Type=\"ownProcess\"\n                        ErrorControl=\"normal\"\n                        Account=\"NetworkService\"/>\n        <ServiceControl Id=\"StartFortunaWebService\"\n                        Name=\"FortunaWebService\"\n                        Start=\"install\"\n                        Stop=\"both\"\n                        Remove=\"uninstall\"\n                        Wait=\"yes\"/>\n        <fire:FirewallException Id=\"FortunaFirewall\"\n                                Name=\"FortunaWebService\"\n                                Port=\"8088\"\n                                Protocol=\"tcp\"\n                                Scope=\"any\"/>\n      </Component>\n    </ComponentGroup>\n  </Fragment>\n\n  <Fragment>\n    <DirectoryRef Id=\"ApplicationProgramsFolder\">\n      <Component Id=\"ApplicationShortcut\" Guid=\"5E95E5B9-4F3D-4B9A-819B-9149C5E4700F\">\n        <util:InternetShortcut Id=\"DashboardShortcut\"\n                               Name=\"Fortuna Dashboard\"\n                               Target=\"http://localhost:8088\"/>\n        <Shortcut Id=\"UninstallProduct\"\n                  Name=\"Uninstall Fortuna Web Service\"\n                  Target=\"[SystemFolder]msiexec.exe\"\n                  Arguments=\"/x [ProductCode]\"\n                  Description=\"Uninstalls Fortuna Web Service\"/>\n        <RemoveFolder Id=\"ApplicationProgramsFolder\" On=\"uninstall\"/>\n        <RegistryValue Root=\"HKCU\"\n                       Key=\"Software\\FortunaWebService\"\n                       Name=\"installed\"\n                       Type=\"integer\"\n                       Value=\"1\"\n                       KeyPath=\"yes\"/>\n      </Component>\n    </DirectoryRef>\n  </Fragment>\n</Wix>\n"
}