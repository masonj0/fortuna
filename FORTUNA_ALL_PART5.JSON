{
    ".dockerignore": ".git\n.gitignore\n.github\n__pycache__\n*.pyc\n.pytest_cache\n.venv\nvenv\n# Keep node_modules out of the build context\nnode_modules/\n\n# Keep build caches out of the build context\nweb_service/frontend/.next/\n\n# Allow frontend build artifacts\n# dist/\n# build/\n*.egg-info\n.DS_Store\n.env\n*.log\n.coverage\n.vscode\n.idea\n",
    ".github/scripts/generate_sbom.py": "import json\nfrom datetime import datetime\nfrom pathlib import Path\n\nfreeze = Path('backend/backend-freeze.txt')\npackages = []\nif freeze.exists():\n    for line in freeze.read_text().splitlines():\n        if '==' in line:\n            packages.append({\n                'name': line.split('==')[0],\n                'version': line.split('==')[1]\n            })\n\nsbom = {\n    'spdxVersion': 'SPDX-2.3',\n    'name': 'HatTrick Fusion Backend',\n    'packages': packages\n}\n\nPath('sbom.json').write_text(json.dumps(sbom, indent=2))\n",
    ".gitignore": "\n# Node.js\nnode_modules\nnpm-debug.log\nyarn-error.log\n\n# Python\n__pycache__/\n*.pyc\n*.pyo\n*.pyd\n.Python\nenv/\nvenv/\npip-selfcheck.json\n.eggs/\ndist/\nbuild/\n*.egg-info/\n\n# IDEs and Editors\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# OS-specific\n.DS_Store\nThumbs.db\n\n# Project-specific\n/web_service/frontend/public\n/web_service/frontend/build\n/web_service/frontend/.next\n",
    "JSON_BACKUP_MANIFEST.md": "# Checkmate Ultimate Solo: JSON Backup Manifest (Total Recall Edition)\n\n**Purpose:** To provide a single, complete, and verified list of direct links to the JSON backups of all CORE and Operational files. This is the definitive entry point for external AI code review.\n\n---\n\n## 1.0 CORE Architecture (JSON Backups)\n\n### Python Backend\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/api.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/engine.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/models.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/__init__.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/base.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/utils.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/betfair_adapter.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/pointsbet_adapter.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/racing_and_sports_adapter.py.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/adapters/tvg_adapter.py.json\n\n### TypeScript Frontend\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/package.json.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/package-lock.json.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/next.config.mjs.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/tailwind.config.ts.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/tsconfig.json.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/src/app/page.tsx.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/src/app/layout.tsx.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/web_platform/frontend/src/app/globals.css.json\n\n---\n\n## 2.0 Operational & Tooling (JSON Backups)\n\n### Project Tooling\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/.gitignore.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/convert_to_json.py.json\n\n### Environment & Setup\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/setup_windows.bat.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/.env.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/python_service/requirements.txt.json\n\n### Strategic Blueprints\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/README.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/ARCHITECTURAL_MANDATE.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/HISTORY.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/STATUS.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/WISDOM.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/PROJECT_MANIFEST.md.json\nhttps://raw.githubusercontent.com/masonj0/fortuna/refs/heads/main/ReviewableJSON/ROADMAP_APPENDICES.md.json",
    "README_WINDOWS.md": "# \ud83d\udc34 Fortuna Faucet - User Guide for Windows\n\nWelcome to Fortuna Faucet! This guide provides simple, step-by-step instructions to get you up and running.\n\n## Installation\n\nInstalling the application is a straightforward process using our official installer.\n\n1.  **Download the Installer:**\n    *   Go to the [**Latest Release Page**](https://github.com/masonj0/fortuna/releases/latest) on GitHub.\n    *   Download the file ending in `.msi` (e.g., `JBMason's 1st App-X.X.X.msi`).\n\n2.  **Run the Installer:**\n    *   Double-click the downloaded `.msi` file to launch the setup wizard.\n    *   Follow the on-screen instructions to complete the installation.\n\n## What to Expect After Installation\n\nOnce the setup is complete, you will find a new folder in your Start Menu named **\"JBMason's 1st App\"**.\n\n*   **Launching the App:** Inside this folder, click on the **\"JBMason's 1st App\"** shortcut to start the application.\n*   **How it Works:** The shortcut launches the main application window (the dashboard). The backend data engine starts automatically in the background and will close when you exit the application.\n\nThat's it! All previous installation methods are now obsolete. Enjoy using the application!\n",
    "USER_GUIDE.MD": "# Fortuna Faucet - User Guide\n\nThis document provides instructions for users of the Fortuna Faucet application.\n\n## Installation\n\n1.  Download the `Fortuna-Faucet-Installer.msi` file from the latest release.\n2.  Run the installer and follow the on-screen instructions.\n3.  The application will be installed to `C:\\Program Files\\Fortuna Faucet` by default.\n\n## Usage\n\n1.  Launch the application from the Start Menu or desktop shortcut.\n2.  The main window will display the live race dashboard.\n3.  Use the settings page to configure your preferences.\n",
    "assets/sounds/.gitkeep": "# This directory is for audio alert sound files (e.g., alert_premium.wav)",
    "e2e/jules-smoke-test.py": "import asyncio\nfrom playwright.async_api import async_playwright, expect\n\nasync def main():\n    async with async_playwright() as p:\n        browser = await p.chromium.launch()\n        page = await browser.new_page()\n        try:\n            await page.goto(\"http://127.0.0.1:8000\")\n            await expect(page.get_by_test_id(\"main-heading\")).to_be_visible()\n        finally:\n            await page.screenshot(path=\"playwright-screenshot.png\")\n            await browser.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
    "electron/electron-builder-config.yml": "appId: com.jules.fortunafaucet\nproductName: \"Fortuna Faucet\"\n\ndirectories:\n  output: dist\n  buildResources: assets\n\nfiles:\n  - \"**/*\"\n  - \"!build_wix/**/*\"\n  - \"resources/**\"\n\n\nwin:\n  target: msi\n  icon: \"assets/icon.ico\"\n\nmsi:\n  oneClick: false\n  perMachine: true\n  runAfterFinish: true\n  # Explicitly pointing to the file ensures WiX picks it up\n  shortcutName: \"Fortuna Faucet\"\n  warningsAsErrors: false\n  template: \"build_wix/Product_Electron.wxs\"\n",
    "electron/main.js": "// electron/main.js - CORRECTED VERSION\nconst { app, BrowserWindow, Tray, Menu, nativeImage, ipcMain, dialog } = require('electron');\nconst { autoUpdater } = require('electron-updater');\nconst { spawn } = require('child_process');\nconst net = require('net');\nconst path = require('path');\nconst fs = require('fs');\nconst SecureSettingsManager = require('./secure-settings-manager');\n\nclass FortunaDesktopApp {\n constructor() {\n this.backendProcess = null;\n this.mainWindow = null;\n this.tray = null;\n this.backendState = 'stopped'; // \"stopped\", \"starting\", \"running\", \"error\"\n this.backendLogs = [];\n this.isBackendStarting = false;\n }\n\n sendBackendStatusUpdate() {\n if (this.mainWindow) {\n this.mainWindow.webContents.send('backend-status-update', {\n state: this.backendState,\n logs: this.backendLogs.slice(-20) // Send last 20 log entries\n });\n }\n }\n\n stopBackend() {\n if (this.backendProcess && !this.backendProcess.killed) {\n console.log('Stopping backend process...');\n this.backendProcess.kill();\n this.backendState = 'stopped';\n this.isBackendStarting = false; // Ensure lock is released on stop\n this.backendLogs.push('Backend process stopped by user.');\n this.sendBackendStatusUpdate();\n }\n }\n\n  checkPortInUse(port) {\n    return new Promise((resolve, reject) => {\n      const server = net.createServer();\n      server.once('error', (err) => {\n        if (err.code === 'EADDRINUSE') {\n          resolve(true); // Port is in use\n        } else {\n          reject(err);\n        }\n      });\n      server.once('listening', () => {\n        server.close(() => {\n          resolve(false); // Port is free\n        });\n      });\n      server.listen(port, '127.0.0.1');\n    });\n  }\n\n  async waitForBackend(maxRetries = 30) {\n    const port = process.env.FORTUNA_PORT || 8000;\n    const url = `http://127.0.0.1:${port}/health`;\n\n    console.log(`[Backend Check] Starting health check at: ${url}`);\n\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        const response = await fetch(url, { timeout: 3000 });\n        console.log(`[Backend Check] Attempt ${i}: Status ${response.status}`);\n\n        if (response.ok) {\n          console.log('\u2705 Backend is healthy and responding');\n          return true;\n        }\n      } catch (e) {\n        console.log(`[Backend Check] Attempt ${i} failed: ${e.message}`);\n\n        // Check if process is still alive\n        if (this.backendProcess && !this.backendProcess.killed) {\n          console.log(`[Backend Check] Process still running (PID: ${this.backendProcess.pid})`);\n        } else {\n          console.error(`[Backend Check] \u26a0\ufe0f  Backend process is DEAD!`);\n          console.error(`[Backend Check] Last logs:`, this.backendLogs.slice(-5));\n          throw new Error(`Backend process died. Last logs:\\\\n${this.backendLogs.slice(-5).join('\\\\n')}`);\n        }\n\n        await new Promise(r => setTimeout(r, 1000));\n      }\n    }\n\n    throw new Error(`Backend failed to respond at ${url} after 30 seconds`);\n  }\n\n  async startBackend() {\n    const isDev = !app.isPackaged;\n    let backendCommand;\n    let backendCwd;\n\n    if (isDev) {\n      console.log('[DEV MODE] Configuring backend...');\n      backendCommand = path.join(__dirname, '..', '.venv', 'Scripts', 'python.exe');\n      backendCwd = path.join(__dirname, '..', 'web_service', 'backend');\n    } else {\n      // CORRECTED PATH: In production, the backend executable is at the root of the resources directory.\n      backendCommand = path.join(process.resourcesPath, 'fortuna-backend.exe');\n      backendCwd = process.resourcesPath;\n\n      console.log(`[Backend] Looking for executable at: ${backendCommand}`);\n      console.log(`[Backend] Executable exists: ${fs.existsSync(backendCommand)}`);\n    }\n\n    if (!fs.existsSync(backendCommand)) {\n      const errorMsg = `Backend executable not found at: ${backendCommand}`;\n      console.error(`[Backend] ${errorMsg}`);\n      this.backendLogs.push(`ERROR: ${errorMsg}`);\n      this.backendState = 'error';\n      dialog.showErrorBox(\n        'Backend Launch Failed',\n        `Could not find backend executable.\\\\n\\\\nExpected location:\\\\n${backendCommand}`\n      );\n      return;\n    }\n\n    console.log(`[Backend] Executable found, attempting to spawn...`);\n\n    this.backendProcess = spawn(backendCommand, [], {\n      cwd: backendCwd,\n      windowsHide: true,\n      env: {\n        ...process.env,\n        FORTUNA_MODE: 'electron',\n        PYTHONPATH: backendCwd\n      }\n    });\n\n    this.backendState = 'starting';\n    this.isBackendStarting = true;\n\n    this.backendProcess.stdout.on('data', (data) => {\n      const output = data.toString().trim();\n      console.log(`[Backend STDOUT] ${output}`);\n      this.backendLogs.push(output);\n\n      // Detect successful startup from log messages\n      if (output.includes('Application startup complete') || output.includes('Uvicorn running')) {\n        if (this.backendState !== 'running') {\n          console.log('\u2705 Backend reported successful startup');\n          this.backendState = 'running';\n          this.isBackendStarting = false;\n        }\n      }\n\n      this.sendBackendStatusUpdate();\n    });\n\n    this.backendProcess.stderr.on('data', (data) => {\n      const errorOutput = data.toString().trim();\n      console.error(`[Backend STDERR] ${errorOutput}`);\n      this.backendLogs.push(`ERROR: ${errorOutput}`);\n\n      if (this.backendState === 'starting') {\n        this.backendState = 'error';\n        this.isBackendStarting = false;\n      }\n\n      this.sendBackendStatusUpdate();\n    });\n\n    this.backendProcess.on('error', (err) => {\n      const errorMsg = `Failed to spawn backend process: ${err.message}`;\n      console.error(`[Backend] ${errorMsg}`);\n      this.backendLogs.push(`ERROR: ${errorMsg}`);\n      this.backendState = 'error';\n      this.isBackendStarting = false;\n      this.sendBackendStatusUpdate();\n    });\n\n    this.backendProcess.on('exit', (code) => {\n      if (code !== 0 && this.backendState !== 'stopped') {\n        console.error(`[CRITICAL] Backend process exited with code: ${code}`);\n        console.error(`[CRITICAL] Last 10 logs:`, this.backendLogs.slice(-10));\n\n        // Save logs for debugging\n        const logFile = path.join(require('os').homedir(), '.fortuna', 'backend_crash.log');\n        fs.mkdirSync(path.dirname(logFile), { recursive: true });\n        fs.writeFileSync(logFile, this.backendLogs.join('\\\\n'));\n        console.error(`[CRITICAL] Full logs saved to: ${logFile}`);\n\n        this.backendState = 'error';\n        this.isBackendStarting = false;\n        this.sendBackendStatusUpdate();\n      }\n    });\n  }\n\n  getFrontendPath() {\n    // UNIFIED: Always serve from the backend\n    const port = process.env.FORTUNA_PORT || 8000;\n    return `http://127.0.0.1:${port}/`;\n  }\n\n createMainWindow() {\n this.mainWindow = new BrowserWindow({\n width: 1600,\n height: 1000,\n title: 'Fortuna Faucet - Racing Analysis',\n icon: path.join(__dirname, 'assets', 'icon.ico'),\n webPreferences: {\n nodeIntegration: false,\n contextIsolation: true,\n preload: path.join(__dirname, 'preload.js')\n },\n autoHideMenuBar: true,\n backgroundColor: '#1a1a2e'\n });\n\n if (!app.isPackaged) {\n this.mainWindow.webContents.openDevTools();\n }\n\n this.mainWindow.on('close', (event) => {\n if (!app.isQuitting) {\n event.preventDefault();\n this.mainWindow.hide();\n }\n });\n }\n\n createSystemTray() {\n // ... (rest of the file is unchanged)\n }\n\n  initialize() {\n    console.log('[Electron] Initializing Fortuna application...');\n\n    this.createMainWindow();\n    this.createSystemTray();\n    this.startBackend();\n\n    // Wait for backend to be ready, then load the unified frontend\n    this.waitForBackend()\n      .then(() => {\n        console.log('[Electron] Backend is ready, loading frontend...');\n        const frontendUrl = this.getFrontendPath();\n        console.log(`[Electron] Loading frontend from: ${frontendUrl}`);\n        this.mainWindow.loadURL(frontendUrl);\n      })\n      .catch((err) => {\n        console.error('[Electron] Backend startup failed:', err);\n        dialog.showErrorBox(\n          'Backend Error',\n          'Failed to start backend service:\\\\n\\\\n' + err.message\n        );\n      });\n\n    // Check for updates\n    autoUpdater.checkForUpdatesAndNotify();\n\n    autoUpdater.on('update-downloaded', (info) => {\n      const dialogOpts = {\n        type: 'info',\n        buttons: ['Restart', 'Later'],\n        title: 'Application Update',\n        message: process.platform === 'win32' ? info.releaseName : info.releaseName,\n        detail: 'A new version has been downloaded. Restart the application to apply the updates.'\n      };\n\n      dialog.showMessageBox(dialogOpts).then((returnValue) => {\n        if (returnValue.response === 0) autoUpdater.quitAndInstall();\n      });\n    });\n\n    ipcMain.on('restart-backend', () => this.startBackend());\n    ipcMain.on('stop-backend', () => this.stopBackend());\n    ipcMain.handle('get-backend-status', async () => ({\n      state: this.backendState,\n      logs: this.backendLogs.slice(-20)\n    }));\n\n    ipcMain.handle('get-api-key', async () => {\n      return SecureSettingsManager.getApiKey();\n    });\n\n    ipcMain.handle('generate-api-key', async () => {\n      const crypto = require('node:crypto');\n      const newKey = crypto.randomBytes(16).toString('hex');\n      SecureSettingsManager.saveApiKey(newKey);\n      return newKey;\n    });\n\n    ipcMain.handle('save-api-key', async (event, apiKey) => {\n      return SecureSettingsManager.saveApiKey(apiKey);\n    });\n\n    ipcMain.handle('save-betfair-credentials', async (event, credentials) => {\n      return SecureSettingsManager.saveBetfairCredentials(credentials);\n    });\n\n    ipcMain.handle('get-api-port', () => {\n      return process.env.FORTUNA_PORT || 8000;\n    });\n  }\n\n cleanup() {\n if (this.backendProcess && !this.backendProcess.killed) {\n this.backendProcess.kill();\n }\n }\n}\n\nlet fortunaApp;\n\napp.whenReady().then(() => {\n  // Harden the session for security\n  const { session } = require('electron');\n  const ses = session.defaultSession;\n\n  // 1. Content-Security-Policy\n  ses.webRequest.onHeadersReceived((details, callback) => {\n    callback({\n      responseHeaders: {\n        ...details.responseHeaders,\n        'Content-Security-Policy': [\n          \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; connect-src 'self' http://127.0.0.1:*\"\n        ]\n      }\n    });\n  });\n\n  // 2. Permission Request Handler\n  ses.setPermissionRequestHandler((webContents, permission, callback) => {\n    const allowedPermissions = ['clipboard-read', 'clipboard-sanitized-write'];\n    if (allowedPermissions.includes(permission)) {\n      callback(true); // Grant allowed permissions\n    } else {\n      console.warn(`[SECURITY] Denied permission request for: ${permission}`);\n      callback(false); // Deny all others by default\n    }\n  });\n\n  // 3. Certificate Pinning (TODO)\n  // Certificate pinning would be implemented here. It is commented out\n  // because it requires a known certificate hash and would break local dev.\n  // ses.setCertificateVerifyProc((request, callback) => {\n  //   const { hostname, certificate, verificationResult } = request;\n  //   if (hostname === 'api.fortuna.faucet') {\n  //     // TODO: Replace with actual certificate fingerprint\n  //     const expectedFingerprint = '...';\n  //     if (certificate.fingerprint === expectedFingerprint) {\n  //       callback(0); // 0 means success\n  //     } else {\n  //       callback(-2); // -2 means failure\n  //     }\n  //   } else {\n  //     callback(0); // Allow other domains\n  //   }\n  // });\n\n  fortunaApp = new FortunaDesktopApp();\n  fortunaApp.initialize();\n});\n\napp.on('window-all-closed', () => {\n if (process.platform !== 'darwin') {\n // Do nothing, keep app running in tray\n }\n});\n\napp.on('activate', () => {\n if (BrowserWindow.getAllWindows().length === 0) {\n fortunaApp.createMainWindow();\n } else {\n fortunaApp.mainWindow.show();\n }\n});\n\napp.on('before-quit', () => {\n app.isQuitting = true;\n if (fortunaApp) {\n fortunaApp.cleanup();\n }\n});\n",
    "file_version_info.txt": "# UTF-8\n#\n# For more details about fixed file info 'ffi' see:\\\n# http://msdn.microsoft.com/en-us/library/ms646997.aspx\nVSVersionInfo(\n  ffi=FixedFileInfo(\n    # filevers and prodvers should be always a tuple with four items: (1, 2, 3, 4)\n    # Set not needed items to zero 0.\n    filevers=(1, 0, 0, 0),\n    prodvers=(1, 0, 0, 0),\n    # Contains a bitmask that specifies the valid bits 'flags'r\n    mask=0x3f,\n    # Contains a bitmask that specifies the Boolean attributes of the file.\n    flags=0x0,\n    # The operating system for which this file was designed.\n    # 0x4 - NT and there is no need to change it.\n    OS=0x40004,\n    # The general type of file.\n    # 0x1 - application\n    fileType=0x1,\n    # The function of the file.\n    # 0x0 - the function is not defined for this fileType\n    subtype=0x0,\n    # Creation date and time stamp.\n    date=(0, 0)\n    ),\n  kids=[\n    StringFileInfo(\n      [\n      StringTable(\n        '000004b0',\n        [StringStruct('CompanyName', 'Fortuna Technologies'),\n        StringStruct('FileDescription', 'Fortuna Faucet - Racing Analysis Engine'),\n        StringStruct('FileVersion', '1.0.0.0'),\n        StringStruct('InternalName', 'Fortuna-WebService'),\n        StringStruct('LegalCopyright', '\u00a9 2026 Fortuna Technologies. All rights reserved.'),\n        StringStruct('OriginalFilename', 'Fortuna-WebService.exe'),\n        StringStruct('ProductName', 'Fortuna Faucet'),\n        StringStruct('ProductVersion', '1.0.0.0')])\n      ]),\n    VarFileInfo([VarStruct('Translation', [1033, 1200])])\n  ]\n)",
    "fortuna-backend-hooks/hook-tenacity.py": "\"\"\"\nPyInstaller hook for tenacity.\n\nTenacity uses dynamic imports for async support and retry strategies that\nPyInstaller cannot automatically detect. This hook ensures all tenacity\nsubmodules are collected into the bundle.\n\nThis is especially critical for tenacity 8.2.3+ which includes async retry support.\n\"\"\"\n\nfrom PyInstaller.utils.hooks import collect_submodules\n\n# Collect all tenacity submodules recursively\nhiddenimports = collect_submodules('tenacity')\n\n# Explicitly add critical submodules that might be missed\n# These are the modules tenacity dynamically imports for retry strategies and async support\ncritical_submodules = [\n    'tenacity.retry',\n    'tenacity.stop',\n    'tenacity.wait',\n    'tenacity.retry_if_result',\n    'tenacity.retry_if_exception',\n    'tenacity.before_sleep',\n    'tenacity.after',\n    'tenacity.before',\n    'tenacity.retry_error',\n    'tenacity.compat',\n    'tenacity.future',\n    'tenacity.asyncio',  # Critical for async retry support\n]\n\n# Merge and deduplicate\nhiddenimports = list(set(hiddenimports + critical_submodules))\n",
    "fortuna-desktop-tinyfield.spec": "# fortuna-desktop.spec\n# This spec file is for creating a windowed, GUI-based application\n# using pywebview. It is based on fortuna-monolith.spec.\n\nfrom PyInstaller.utils.hooks import collect_submodules\nfrom pathlib import Path\nimport sys\nimport os\n\nblock_cipher = None\n\n# ===== GET PROJECT ROOT =====\nspec_path = Path(SPECPATH) if 'SPECPATH' in dir() else Path(os.path.dirname(os.path.abspath(__file__)))\nproject_root = spec_path.parent if spec_path.name == 'fortuna-desktop-tinyfield.spec' else spec_path\n\n# ===== FRONTEND VALIDATION =====\nfrontend_out = project_root / 'web_service' / 'frontend' / 'public'\nif not frontend_out.exists() or not (frontend_out / 'index.html').exists():\n    print(\"[ERROR] FATAL: Frontend 'public' directory with index.html not found!\")\n    sys.exit(1)\n\n# ===== BACKEND VALIDATION =====\nbackend_root = project_root / 'web_service' / 'backend'\nmain_script = project_root / 'run_desktop_app.py'\nif not main_script.exists():\n    print(f\"[ERROR] FATAL: Main script not found at {main_script}!\")\n    sys.exit(1)\n\n# ===== DATA FILES =====\ndatas = [\n    (str(frontend_out), 'public')\n]\n\n# ===== HIDDEN IMPORTS =====\nhiddenimports = list(set(\n    collect_submodules('web_service.backend') +\n    [\n        'uvicorn', 'uvicorn.logging', 'uvicorn.loops', 'uvicorn.loops.auto',\n        'uvicorn.protocols', 'uvicorn.protocols.http', 'uvicorn.protocols.http.auto',\n        'uvicorn.protocols.http.h11_impl', 'uvicorn.lifespan', 'uvicorn.lifespan.on',\n        'fastapi', 'starlette', 'pydantic', 'anyio', 'structlog', 'tenacity',\n        'sqlalchemy', 'greenlet', 'win32timezone'\n    ]\n))\n\n# ===== ANALYSIS =====\na = Analysis(\n    [str(main_script)],\n    pathex=[str(project_root), str(backend_root)],\n    binaries=[],\n    datas=datas,\n    hiddenimports=hiddenimports,\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    cipher=block_cipher,\n    noarchive=False,\n)\n\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\n# ===== BUILD EXECUTABLE (WINDOWED) =====\nexe = EXE(\n    pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],\n    name='Fortuna-Desktop-TinyField',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    runtime_tmpdir=None,\n    console=False,  # This creates a windowed application\n    disable_windowed_traceback=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n    icon=None # Consider adding an icon here later\n)\n\ncoll = COLLECT(\n    exe, a.binaries, a.zipfiles, a.datas,\n    strip=False,\n    upx=True,\n    name='Fortuna-Desktop-TinyField'\n)\n",
    "pg_schemas/quarantined_races.sql": "-- Schema for storing race data that fails validation\nCREATE TABLE IF NOT EXISTS quarantined_races (\n    quarantine_id SERIAL PRIMARY KEY,\n    race_id VARCHAR(255),\n    source VARCHAR(50),\n    payload JSONB NOT NULL,\n    reason VARCHAR(255) NOT NULL,\n    quarantined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"paddock-parser-ng\"\nversion = \"0.1.0\"\ndescription = \"A toolkit to identify the best racecards for betting.\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\n[project.scripts]\npaddock_parser_ui = \"paddock_parser.entry_points:run_terminal_ui\"\npaddock_parser_dashboard = \"paddock_parser.entry_points:run_dashboard\"\npaddock_parser_predict = \"paddock_parser.entry_points:run_prediction_engine\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n# Configuration for the Ruff linter\n[tool.ruff]\n# Allow lines to be up to 120 characters long.\nline-length = 120\n\n[tool.ruff.lint]\n# Enable Pyflakes (F), pycodestyle (E, W), and isort (I) rules.\nselect = [\"E\", \"F\", \"W\", \"I\"]\nignore = []\n\n[tool.ruff.lint.isort]\n# Sort imports within their sections alphabetically.\nforce-single-line = true\n",
    "run_desktop_app.py": "\nimport webview\nimport uvicorn\nimport threading\nimport sys\nfrom web_service.backend.api import app\nfrom web_service.backend.config import get_settings\n\ndef run_server():\n    settings = get_settings()\n    uvicorn.run(app, host=settings.UVICORN_HOST, port=settings.FORTUNA_PORT)\n\nif __name__ == '__main__':\n    server_thread = threading.Thread(target=run_server)\n    server_thread.daemon = True\n    server_thread.start()\n\n    webview.create_window('Fortuna Faucet', 'http://127.0.0.1:8000', width=1200, height=800)\n    webview.start()\n    sys.exit()\n",
    "scripts/generate_spec_dual.py": "# scripts/generate_spec_dual.py\n# A unified, intelligent spec generator by Jules 1221\n# This script generates distinct PyInstaller specs for different build modes.\n\nimport argparse\nimport os\nimport sys\nimport subprocess\nfrom pathlib import Path\n\n# Fix for UnicodeEncodeError on Windows runners with special characters in logs\nif sys.platform == 'win32':\n    try:\n        # This is the most reliable way to ensure UTF-8 output on Windows\n        sys.stdout.reconfigure(encoding='utf-8')\n        sys.stderr.reconfigure(encoding='utf-8')\n    except TypeError:\n        # In some environments (like older Python versions or certain terminals),\n        # reconfigure might not be available. We fall back to a less ideal but\n        # still helpful method.\n        import codecs\n        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')\n        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')\n\ndef generate_spec(mode: str):\n    \"\"\"\n    Generates a PyInstaller spec file based on the specified mode ('ui' or 'svc').\n    \"\"\"\n    print(f\"--- \ud83d\udc0d Unified Spec Generator (Mode: {mode}) ---\")\n\n    # 1. Determine configuration based on mode\n    if mode == 'ui':\n        binary_name = 'fortuna-ui-bridge'\n        entry_point_name = 'main.py'\n        is_console = True  # Electron bridge needs console for stdio\n        datas = f\"[('{frontend_dist.as_posix()}', 'frontend_dist')]\"\n        hidden_imports = \"\"\"[\n        'uvicorn',\n        'fastapi',\n        'starlette',\n        'anyio',\n        'pydantic',\n        'uvicorn.logging',\n        'uvicorn.loops.auto',\n        'uvicorn.protocols.http.auto',\n        'win32timezone'\n    ]\"\"\"\n    elif mode == 'svc':\n        binary_name = 'fortuna-core-service'\n        entry_point_name = 'service_entry.py' # Dedicated Windows Service entry\n        is_console = False # Windows Service should be a GUI app\n        datas = \"[]\" # Service does not bundle the UI\n        hidden_imports = \"\"\"[\n        'uvicorn',\n        'fastapi',\n        'starlette',\n        'anyio',\n        'pydantic',\n        'uvicorn.logging',\n        'uvicorn.loops.auto',\n        'uvicorn.protocols.http.auto',\n        'win32timezone',\n        'win32serviceutil',\n        'win32service',\n        'win32event'\n    ]\"\"\"\n    else:\n        print(f\"\u274c Invalid mode specified: {mode}. Use 'ui' or 'svc'.\")\n        sys.exit(1)\n\n    print(f\"Binary Name: {binary_name}\")\n    print(f\"Entry Point: {entry_point_name}\")\n\n    # 2. Path Validation\n    script_dir = Path(__file__).parent.resolve()\n    project_root = script_dir.parent.resolve()\n    entry_point = project_root / \"web_service\" / \"backend\" / entry_point_name\n    frontend_dist = project_root / \"web_platform\" / \"frontend\" / \"out\"\n\n    if not entry_point.exists():\n        print(f\"\u274c Entry point not found: {entry_point}\")\n        sys.exit(1)\n\n    # 3. Locate critical DLLs\n    python_home = Path(sys.base_prefix)\n    dlls_to_bundle = [\n        python_home / 'python311.dll',\n        python_home / 'vcruntime140.dll'\n    ]\n    binaries = []\n    for dll_path in dlls_to_bundle:\n        if dll_path.exists():\n            binaries.append((str(dll_path).replace('\\\\\\\\', '/'), '.'))\n            print(f\"\u2705 Found required DLL: {dll_path}\")\n        else:\n             print(f\"\u26a0\ufe0f Could not find optional DLL, skipping: {dll_path}\")\n\n    # 4. Define the spec file content\n    spec_content = f\"\"\"\n# -*- mode: python ; coding: utf-8 -*-\n# Generated by scripts/generate_spec_dual.py (Mode: {mode})\n\nblock_cipher = None\n\na = Analysis(\n    ['{entry_point.as_posix()}'],\n    pathex=['{project_root.as_posix()}'],\n    binaries={binaries},\n    datas={datas},\n    hiddenimports={hidden_imports},\n    hookspath=[],\n    runtime_hooks=[],\n    excludes=['python_service'],\n    win_no_prefer_redirects=False,\n    win_private_assemblies=False,\n    cipher=block_cipher,\n    noarchive=False,\n)\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    [],\n    exclude_binaries=True,\n    name='{binary_name}',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    console={is_console},\n    icon=None,\n)\n\ncoll = COLLECT(\n    exe,\n    a.binaries,\n    a.zipfiles,\n    a.datas,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    name='{binary_name}',\n)\n\"\"\"\n\n    # 5. Write the spec file\n    spec_path = project_root / f\"{binary_name}.spec\"\n    print(f\"--- Writing spec file to {spec_path} ---\")\n    with open(spec_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(spec_content)\n    print(f\"\u2705 Spec file created.\")\n\n    # 6. Run PyInstaller\n    print(\"--- Running PyInstaller build ---\")\n    cmd = [\n        sys.executable,\n        \"-m\", \"PyInstaller\",\n        str(spec_path),\n        \"--clean\",\n        \"--noconfirm\",\n        \"--log-level\", \"WARN\"\n    ]\n    print(f\"Executing command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8')\n        print(\"\u2705 PyInstaller build successful.\")\n        print(result.stdout)\n    except subprocess.CalledProcessError as e:\n        print(\"\u274c PyInstaller build failed!\")\n        print(\"--- STDOUT ---\")\n        print(e.stdout)\n        print(\"--- STDERR ---\")\n        print(e.stderr)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate a PyInstaller spec file for different build modes.\")\n    parser.add_argument('--mode', required=True, choices=['ui', 'svc'], help=\"The build mode: 'ui' for Electron bridge or 'svc' for Windows Service.\")\n    args = parser.parse_args()\n    generate_spec(args.mode)\n",
    "scripts/launch-monolith.ps1": "# launch-monolith.ps1 - Lightweight launcher for fortuna-monolith.exe\nparam(\n    [string]$ExePath = \"dist/fortuna-monolith/fortuna-monolith.exe\",  # Path to your PyInstaller EXE\n    [int]$Port = 8000,\n    [switch]$AutoRestart\n)\n\n# Set environment variables (equivalent to Docker env)\n$env:FORTUNA_PORT = $Port\n$env:FORTUNA_MODE = \"monolith\"  # Custom flag for your app\n\n# Pre-launch checks (lightweight health check)\nfunction Test-PortFree {\n    param([int]$Port)\n    try {\n        $tcp = New-Object System.Net.Sockets.TcpClient\n        $tcp.Connect(\"127.0.0.1\", $Port)\n        $tcp.Close()\n        return $false  # Port in use\n    } catch {\n        return $true   # Port free\n    }\n}\n\nif (!(Test-Path $ExePath)) {\n    Write-Error \"Monolith EXE not found at $ExePath. Build it first with PyInstaller.\"\n    exit 1\n}\n\nif (!(Test-PortFree $Port)) {\n    Write-Error \"Port $Port is in use. Close conflicting app or change port.\"\n    exit 1\n}\n\n# Launch the EXE (in background, with logging)\nWrite-Host \"Launching Fortuna Monolith on port $Port...\"\n$process = Start-Process -FilePath $ExePath -ArgumentList \"--host 127.0.0.1 --port $Port\" -NoNewWindow -PassThru -RedirectStandardOutput \"monolith.log\" -RedirectStandardError \"monolith-error.log\"\n\n# Optional auto-restart loop (mimics Docker restart policies)\nif ($AutoRestart) {\n    while ($true) {\n        Start-Sleep 5  # Poll every 5 seconds\n        if ($process.HasExited) {\n            Write-Warning \"Monolith crashed (exit code $($process.ExitCode)). Restarting...\"\n            $process = Start-Process -FilePath $ExePath -ArgumentList \"--host 127.0.0.1 --port $Port\" -NoNewWindow -PassThru\n        }\n    }\n} else {\n    Write-Host \"Monolith launched successfully. Waiting for server to initialize...\"\n    Start-Sleep -Seconds 3 # Give the server a moment to start up before opening the browser\n\n    $url = \"http://127.0.0.1:$Port\"\n    Write-Host \"Opening application at $url in your default browser.\"\n    Start-Process $url\n\n    Write-Host \"Application is running. Press Ctrl+C in this window to stop the server.\"\n    Wait-Process -Id $process.Id\n}\n",
    "start_podman.bat": "@echo off\nREM ============================================================\nREM Fortuna Faucet - Podman Launcher for Windows\nREM A simple, friendly way to start your racing analysis engine\nREM ============================================================\n\nsetlocal enabledelayedexpansion\n\nREM Colors and styling\ncls\necho.\necho \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\necho \u2551                                                            \u2551\necho \u2551            \ud83d\udc34  FORTUNA FAUCET LAUNCHER (Podman) \ud83d\udc34         \u2551\necho \u2551          Racing Strategy Analysis Engine                  \u2551\necho \u2551                                                            \u2551\necho \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\necho.\n\nREM ============================================================\nREM STEP 1: Check if Podman is installed\nREM ============================================================\necho [1/5] Checking for Podman installation...\npodman --version >nul 2>&1\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Podman is not installed or not in PATH\n    echo.\n    echo To use Fortuna, you need Podman Desktop:\n    echo https://podman-desktop.io/\n    echo.\n    echo After installing Podman, restart your computer and try again.\n    echo.\n    pause\n    exit /b 1\n)\n\nfor /f \"tokens=*\" %%i in ('podman --version') do set PODMAN_VERSION=%%i\necho \u2713 Found: %PODMAN_VERSION%\necho.\n\nREM ============================================================\nREM STEP 2: Check if Podman machine is running\nREM ============================================================\necho [2/5] Checking if Podman machine is running...\npodman ps >nul 2>&1\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Podman machine is not running\n    echo.\n    echo Please:\n    echo 1. Open \"Podman Desktop\" from your Start Menu\n    echo 2. Make sure your Podman machine is started\n    echo 3. Then run this launcher again\n    echo.\n    pause\n    exit /b 1\n)\necho \u2713 Podman machine is running\necho.\n\nREM ============================================================\nREM STEP 3: Pull latest image\nREM ============================================================\necho [3/5] Pulling latest Fortuna image from Docker Hub...\necho (This may take a minute on first run)\necho.\npodman pull docker.io/masonj0/fortuna-faucet:latest\nif errorlevel 1 (\n    echo.\n    echo \u26a0 Warning: Could not pull from Docker Hub\n    echo Checking for local image...\n    podman image inspect masonj0/fortuna-faucet:latest >nul 2>&1\n    if errorlevel 1 (\n        echo \u2717 ERROR: No local image found\n        echo Please check your internet connection and try again.\n        echo.\n        pause\n        exit /b 1\n    )\n    echo \u2713 Using existing local image\n)\necho \u2713 Image ready\necho.\n\nREM ============================================================\nREM STEP 4: Start container\nREM ============================================================\necho [4/5] Starting Fortuna container...\necho.\n\nREM Stop any existing container (ignore errors)\npodman stop fortuna-faucet >nul 2>&1\npodman rm fortuna-faucet >nul 2>&1\n\nREM Create data directories if they don't exist\nif not exist \"data\" mkdir data\nif not exist \"logs\" mkdir logs\n\nREM Start container with proper quoting for paths with spaces\npodman run -d ^\n  --name fortuna-faucet ^\n  -p 8000:8000 ^\n  -v \"%cd%\\data:/app/web_service/backend/data\" ^\n  -v \"%cd%\\logs:/app/web_service/backend/logs\" ^\n  docker.io/masonj0/fortuna-faucet:latest\n\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Failed to start container\n    echo.\n    echo Try these troubleshooting steps:\n    echo 1. Open Podman Desktop\n    echo 2. Make sure your Podman machine is running\n    echo 3. Open Command Prompt and run: podman ps\n    echo    (This tests if Podman is working)\n    echo 4. Run this launcher again\n    echo.\n    pause\n    exit /b 1\n)\n\necho \u2713 Container started successfully\necho.\n\nREM ============================================================\nREM STEP 5: Wait and verify startup\nREM ============================================================\necho [5/5] Waiting for application to start...\ntimeout /t 3 /nobreak\n\nREM Check if container is still running\npodman inspect fortuna-faucet >nul 2>&1\nif errorlevel 1 (\n    echo.\n    echo \u2717 ERROR: Container exited unexpectedly\n    echo.\n    echo Showing container logs for debugging:\n    echo.\n    podman logs fortuna-faucet\n    echo.\n    pause\n    exit /b 1\n)\n\necho \u2713 Application is ready!\necho.\n\nREM ============================================================\nREM SUCCESS - Open browser and show logs\nREM ============================================================\ncls\necho.\necho \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\necho \u2551                                                            \u2551\necho \u2551            \ud83c\udf89  FORTUNA IS RUNNING! (Podman) \ud83c\udf89           \u2551\necho \u2551                                                            \u2551\necho \u2551  Your racing analysis engine is ready at:                \u2551\necho \u2551                                                            \u2551\necho \u2551          http://localhost:8000                            \u2551\necho \u2551                                                            \u2551\necho \u2551  Opening browser now...                                   \u2551\necho \u2551                                                            \u2551\necho \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\necho.\n\nREM Open browser\nstart http://localhost:8000\n\nREM Small delay to let browser open\ntimeout /t 2 /nobreak\n\nREM Show logs\necho.\necho \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\necho \u2502 Live Application Logs (Ctrl+C to stop)                    \u2502\necho \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\necho.\n\npodman logs -f fortuna-faucet\n\nREM Cleanup on exit\necho.\necho Stopping Fortuna...\npodman stop fortuna-faucet >nul 2>&1\necho \u2713 Fortuna stopped\n\nexit /b 0\n",
    "tests/adapters/test_gbgb_api_adapter.py": "# tests/adapters/test_gbgb_api_adapter.py\n\nfrom datetime import date\nfrom decimal import Decimal\nfrom unittest.mock import AsyncMock\n\nimport pytest\n\nfrom python_service.adapters.gbgb_api_adapter import GbgbApiAdapter\nfrom tests.conftest import get_test_settings\n\n\n@pytest.fixture\ndef gbgb_adapter():\n    \"\"\"Returns a GbgbApiAdapter instance for testing.\"\"\"\n    return GbgbApiAdapter(config=get_test_settings())\n\n\n@pytest.mark.asyncio\nasync def test_get_gbgb_races_successfully(gbgb_adapter):\n    \"\"\"\n    SPEC: The GbgbApiAdapter should correctly parse a standard API response,\n    creating Race and Runner objects with the correct data, including fractional odds.\n    \"\"\"\n    # ARRANGE\n    mock_date = date.today().strftime(\"%Y-%m-%d\")\n    mock_api_response = [\n        {\n            \"trackName\": \"Towcester\",\n            \"races\": [\n                {\n                    \"raceId\": 12345,\n                    \"raceNumber\": 1,\n                    \"raceTime\": \"2025-10-09T18:00:00Z\",\n                    \"raceTitle\": \"The October Sprint\",\n                    \"raceDistance\": 500,\n                    \"traps\": [\n                        {\"trapNumber\": 1, \"dogName\": \"Rapid Rover\", \"sp\": \"5/2\"},\n                        {\"trapNumber\": 2, \"dogName\": \"Speedy Sue\", \"sp\": \"EVS\"},\n                        {\"trapNumber\": 3, \"dogName\": \"Lazy Larry\", \"sp\": \"10/1\"},\n                    ],\n                }\n            ],\n        }\n    ]\n    gbgb_adapter._fetch_data = AsyncMock(return_value=mock_api_response)\n\n    # ACT\n    races = [race async for race in gbgb_adapter.get_races(mock_date)]\n\n    # ASSERT\n    assert len(races) == 1\n    race = races[0]\n    assert race.venue == \"Towcester\"\n    assert race.race_number == 1\n    assert race.race_name == \"The October Sprint\"\n    assert race.distance == \"500m\"\n    assert len(race.runners) == 3\n\n    runner1 = next(r for r in race.runners if r.number == 1)\n    assert runner1.name == \"Rapid Rover\"\n    assert runner1.odds[\"GBGB\"].win == Decimal(\"3.5\")\n\n    runner2 = next(r for r in race.runners if r.number == 2)\n    assert runner2.name == \"Speedy Sue\"\n    assert runner2.odds[\"GBGB\"].win == Decimal(\"2.0\")\n\n    runner3 = next(r for r in race.runners if r.number == 3)\n    assert runner3.name == \"Lazy Larry\"\n    assert runner3.odds[\"GBGB\"].win == Decimal(\"11.0\")\n\n\n@pytest.mark.asyncio\nasync def test_get_races_handles_fetch_failure(gbgb_adapter):\n    \"\"\"\n    Tests that get_races returns an empty list when _fetch_data returns None.\n    \"\"\"\n    # ARRANGE\n    mock_date = date.today().strftime(\"%Y-%m-%d\")\n    gbgb_adapter._fetch_data = AsyncMock(return_value=None)\n\n    # ACT\n    races = [race async for race in gbgb_adapter.get_races(mock_date)]\n\n    # ASSERT\n    assert races == []\n",
    "tests/adapters/test_twinspires_adapter.py": "# tests/adapters/test_twinspires_adapter.py\nimport pytest\nfrom python_service.adapters.twinspires_adapter import TwinSpiresAdapter\nfrom python_service.models import Race\n\n# A mock settings object to satisfy the adapter's config dependency\nclass MockSettings:\n    pass\n\n@pytest.fixture\ndef adapter():\n    return TwinSpiresAdapter(config=MockSettings())\n\n@pytest.mark.asyncio\nasync def test_get_races_from_fixture(adapter):\n    \"\"\"\n    Test that the adapter can correctly parse a local HTML fixture.\n    This test validates the end-to-end parsing logic, including runner data,\n    using the offline implementation.\n    \"\"\"\n    # Call the method under test, which is now wired to read from the fixture\n    races = await adapter._get_races_async(date=\"2025-11-12\")\n\n    # Assertions\n    assert isinstance(races, list)\n    assert len(races) == 1\n\n    # Check the race for correct parsing\n    race = races[0]\n    assert race.venue == \"Churchill Downs\"\n    assert race.race_number == 5\n\n    # Check that runners were parsed correctly\n    assert len(race.runners) == 4\n\n    # Verify a specific runner's details\n    runner_1 = next((r for r in race.runners if r.number == 1), None)\n    assert runner_1 is not None\n    assert runner_1.name == \"Braveheart\"\n    assert not runner_1.scratched\n    assert runner_1.odds[\"TwinSpires\"].win == 3.5\n\n    # Verify a scratched runner\n    runner_3 = next((r for r in race.runners if r.number == 3), None)\n    assert runner_3 is not None\n    assert runner_3.name == \"Steady Eddy\"\n    assert runner_3.scratched\n    assert not runner_3.odds\n",
    "tests/fixtures/timeform_modern_sample.html": "<div class=\"rp-horseTable_mainRow\">\n  <a class=\"rp-horseTable_horse-name\">Braveheart</a>\n  <span class=\"rp-horseTable_horse-number\">(1)</span>\n  <button class=\"rp-bet-placer-btn__odds\">5/2</button>\n</div>\n<div class=\"rp-horseTable_mainRow\">\n  <a class=\"rp-horseTable_horse-name\">Speedster</a>\n  <span class=\"rp-horseTable_horse-number\">(2)</span>\n  <button class=\"rp-bet-placer-btn__odds\">10/1</button>\n</div>\n<div class=\"rp-horseTable_mainRow\">\n  <a class=\"rp-horseTable_horse-name\">Steady Eddy</a>\n  <span class=\"rp-horseTable_horse-number\">(3)</span>\n  <button class=\"rp-bet-placer-btn__odds\">EVENS</button>\n</div>\n",
    "tests/test_ci_sanity.py": "def test_ci_pipeline_is_alive():\n    \"\"\"Basic TDD sanity check to ensure pytest is running in CI.\"\"\"\n    assert True",
    "tests/test_models/test_validation.py": "import pytest\nfrom pydantic import ValidationError\n\nfrom python_service.models import Race\n\n\ndef test_race_model_valid_data():\n    \"\"\"Tests that the Race model can be created with valid data.\"\"\"\n    race_data = {\n        \"id\": \"test_race_123\",\n        \"venue\": \"Test Park\",\n        \"race_number\": 1,\n        \"start_time\": \"2025-10-20T12:00:00Z\",\n        \"runners\": [],\n        \"source\": \"test_source\",\n    }\n    race = Race(**race_data)\n    assert race.id == \"test_race_123\"\n    assert race.venue == \"Test Park\"\n\n\ndef test_race_model_invalid_data():\n    \"\"\"Tests that the Race model raises a ValidationError with invalid data.\"\"\"\n    invalid_race_data = {\n        \"id\": \"test_race_456\",\n        \"venue\": 12345,  # Invalid type\n        \"race_number\": \"two\",  # Invalid type\n        \"start_time\": \"not-a-date\",\n        \"runners\": \"not-a-list\",\n        \"source\": \"test_source\",\n    }\n    with pytest.raises(ValidationError):\n        Race(**invalid_race_data)\n",
    "web_service/__init__.py": "\"\"\"Web service package for Fortuna Faucet.\"\"\"\n__version__ = \"1.0.0\"\n__all__ = [\"backend\"]\n",
    "web_service/backend/adapters/betfair_adapter.py": "# python_service/adapters/betfair_adapter.py\nimport re\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import List\n\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base_adapter_v3 import BaseAdapterV3\nfrom .betfair_auth_mixin import BetfairAuthMixin\n\n\nclass BetfairAdapter(BetfairAuthMixin, BaseAdapterV3):\n    \"\"\"Adapter for fetching horse racing data from the Betfair Exchange API, using V3 architecture.\"\"\"\n\n    SOURCE_NAME = \"BetfairExchange\"\n    BASE_URL = \"https://api.betfair.com/exchange/betting/rest/v1.0/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"Fetches the raw market catalogue for a given date.\"\"\"\n        await self._authenticate(self.http_client)\n        if not self.session_token:\n            self.logger.error(\"Authentication failed, cannot fetch data.\")\n            return None\n\n        start_time, end_time = self._get_datetime_range(date)\n\n        response = await self.make_request(\n            self.http_client,\n            method=\"post\",\n            url=f\"{self.BASE_URL}listMarketCatalogue/\",\n            json={\n                \"filter\": {\n                    \"eventTypeIds\": [\"7\"],  # Horse Racing\n                    \"marketCountries\": [\"GB\", \"IE\", \"AU\", \"US\", \"FR\", \"ZA\"],\n                    \"marketTypeCodes\": [\"WIN\"],\n                    \"marketStartTime\": {\n                        \"from\": start_time.isoformat(),\n                        \"to\": end_time.isoformat(),\n                    },\n                },\n                \"maxResults\": 1000,\n                \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"],\n            },\n        )\n        return response.json() if response else None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses the raw market catalogue into a list of Race objects.\"\"\"\n        if not raw_data:\n            return []\n\n        races = []\n        for market in raw_data:\n            try:\n                if race := self._parse_race(market):\n                    races.append(race)\n            except (KeyError, TypeError):\n                self.logger.warning(\"Failed to parse a Betfair market.\", exc_info=True, market=market)\n                continue\n        return races\n\n    def _parse_race(self, market: dict) -> Race:\n        \"\"\"Parses a single market from the Betfair API into a Race object.\"\"\"\n        market_id = market.get(\"marketId\")\n        event = market.get(\"event\", {})\n        market_start_time = market.get(\"marketStartTime\")\n\n        if not all([market_id, market_start_time]):\n            return None\n\n        start_time = datetime.fromisoformat(market_start_time.replace(\"Z\", \"+00:00\"))\n\n        runners = [\n            Runner(\n                number=runner.get(\"sortPriority\", i + 1),\n                name=runner.get(\"runnerName\"),\n                scratched=runner.get(\"status\") != \"ACTIVE\",\n                selection_id=runner.get(\"selectionId\"),\n            )\n            for i, runner in enumerate(market.get(\"runners\", []))\n            if runner.get(\"runnerName\")\n        ]\n\n        return Race(\n            id=f\"bf_{market_id}\",\n            venue=event.get(\"venue\", \"Unknown Venue\"),\n            race_number=self._extract_race_number(market.get(\"marketName\", \"\")),\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n\n    def _extract_race_number(self, name: str) -> int:\n        \"\"\"Extracts the race number from a market name (e.g., 'R1 1m Mdn Stks').\"\"\"\n        match = re.search(r\"\\bR(\\d{1,2})\\b\", name)\n        return int(match.group(1)) if match else 0\n\n    def _get_datetime_range(self, date_str: str):\n        # Helper to create a datetime range for the Betfair API\n        start_time = datetime.strptime(date_str, \"%Y-%m-%d\")\n        end_time = start_time + timedelta(days=1)\n        return start_time, end_time\n",
    "web_service/backend/adapters/equibase_adapter.py": "# python_service/adapters/equibase_adapter.py\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom selectolax.parser import HTMLParser\nfrom selectolax.parser import Node\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass EquibaseAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for scraping Equibase race entries, migrated to BaseAdapterV3.\n    \"\"\"\n\n    SOURCE_NAME = \"Equibase\"\n    BASE_URL = \"https://www.equibase.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Optional[dict]:\n        \"\"\"\n        Fetches the raw HTML for all race pages for a given date.\n        \"\"\"\n        index_url = f\"/entries/{date}\"\n        index_response = await self.make_request(self.http_client, \"GET\", index_url, headers=self._get_headers())\n        if not index_response:\n            self.logger.warning(\"Failed to fetch Equibase index page\", url=index_url)\n            return None\n\n        parser = HTMLParser(index_response.text)\n        race_links = [link.attributes[\"href\"] for link in parser.css(\"a.entry-race-level\")]\n\n        async def fetch_single_html(race_url: str):\n            response = await self.make_request(self.http_client, \"GET\", race_url, headers=self._get_headers())\n            return response.text if response else \"\"\n\n        tasks = [fetch_single_html(link) for link in race_links]\n        html_pages = await asyncio.gather(*tasks)\n        return {\"pages\": html_pages, \"date\": date}\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses a list of raw HTML strings into Race objects.\"\"\"\n        if not raw_data or not raw_data.get(\"pages\"):\n            return []\n\n        date = raw_data[\"date\"]\n        all_races = []\n        for html in raw_data[\"pages\"]:\n            if not html:\n                continue\n            try:\n                parser = HTMLParser(html)\n\n                venue_node = parser.css_first(\"div.track-information strong\")\n                if not venue_node:\n                    continue\n                venue = clean_text(venue_node.text())\n\n                race_number_node = parser.css_first(\"div.race-information strong\")\n                if not race_number_node:\n                    continue\n                race_number_text = race_number_node.text().replace(\"Race\", \"\").strip()\n                if not race_number_text.isdigit():\n                    continue\n                race_number = int(race_number_text)\n\n                post_time_node = parser.css_first(\"p.post-time span\")\n                if not post_time_node:\n                    continue\n                post_time_str = post_time_node.text().strip()\n                start_time = self._parse_post_time(date, post_time_str)\n\n                runners = []\n                runner_nodes = parser.css(\"table.entries-table tbody tr\")\n                for node in runner_nodes:\n                    if runner := self._parse_runner(node):\n                        runners.append(runner)\n\n                if not runners:\n                    continue\n\n                race = Race(\n                    id=f\"eqb_{venue.lower().replace(' ', '')}_{date}_{race_number}\",\n                    venue=venue,\n                    race_number=race_number,\n                    start_time=start_time,\n                    runners=runners,\n                    source=self.source_name,\n                )\n                all_races.append(race)\n            except (AttributeError, ValueError):\n                self.logger.error(\"Failed to parse Equibase race page.\", exc_info=True)\n                continue\n        return all_races\n\n    def _parse_runner(self, node: Node) -> Optional[Runner]:\n        try:\n            number_node = node.css_first(\"td:nth-child(1)\")\n            if not number_node or not number_node.text(strip=True).isdigit():\n                return None\n            number = int(number_node.text(strip=True))\n\n            name_node = node.css_first(\"td:nth-child(3)\")\n            if not name_node:\n                return None\n            name = clean_text(name_node.text())\n\n            odds_node = node.css_first(\"td:nth-child(10)\")\n            odds_str = clean_text(odds_node.text()) if odds_node else \"\"\n\n            scratched = \"scratched\" in node.attributes.get(\"class\", \"\").lower()\n\n            odds = {}\n            if not scratched:\n                win_odds = parse_odds_to_decimal(odds_str)\n                if win_odds and win_odds < 999:\n                    odds = {\n                        self.source_name: OddsData(\n                            win=win_odds,\n                            source=self.source_name,\n                            last_updated=datetime.now(),\n                        )\n                    }\n            return Runner(number=number, name=name, odds=odds, scratched=scratched)\n        except (ValueError, AttributeError, IndexError):\n            self.logger.warning(\"Could not parse Equibase runner, skipping.\", exc_info=True)\n            return None\n\n    def _parse_post_time(self, date_str: str, time_str: str) -> datetime:\n        \"\"\"Parses a time string like 'Post Time: 12:30 PM ET' into a datetime object.\"\"\"\n        time_part = time_str.split(\" \")[-2] + \" \" + time_str.split(\" \")[-1]\n        dt_str = f\"{date_str} {time_part}\"\n        return datetime.strptime(dt_str, \"%Y-%m-%d %I:%M %p\")\n\n    def _get_headers(self) -> dict:\n        return {\n            \"User-Agent\": (\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                \"Chrome/107.0.0.0 Safari/537.36\"\n            )\n        }\n",
    "web_service/backend/adapters/horseracingnation_adapter.py": "# python_service/adapters/horseracingnation_adapter.py\nfrom typing import Any\nfrom typing import List\n\nfrom ..models import Race\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass HorseRacingNationAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for horseracingnation.com.\n    This adapter is a non-functional stub and has not been implemented.\n    \"\"\"\n\n    SOURCE_NAME = \"HorseRacingNation\"\n    BASE_URL = \"https://www.horseracingnation.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"This is a stub and does not fetch any data.\"\"\"\n        self.logger.warning(\n            f\"{self.source_name} is a non-functional stub and has not been implemented. It will not fetch any data.\"\n        )\n        return None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"This is a stub and does not parse any data.\"\"\"\n        return []\n",
    "web_service/backend/adapters/racing_and_sports_adapter.py": "# python_service/adapters/racing_and_sports_adapter.py\n\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nfrom ..core.exceptions import AdapterConfigError\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass RacingAndSportsAdapter(BaseAdapterV3):\n    \"\"\"Adapter for Racing and Sports API, migrated to BaseAdapterV3.\"\"\"\n\n    SOURCE_NAME = \"RacingAndSports\"\n    BASE_URL = \"https://api.racingandsports.com.au/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n        if not hasattr(config, \"RACING_AND_SPORTS_TOKEN\") or not config.RACING_AND_SPORTS_TOKEN:\n            raise AdapterConfigError(self.source_name, \"RACING_AND_SPORTS_TOKEN is not configured.\")\n        self.api_token = config.RACING_AND_SPORTS_TOKEN\n\n    async def _fetch_data(self, date: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetches the raw meetings data from the Racing and Sports API.\"\"\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_token}\",\n            \"Accept\": \"application/json\",\n        }\n        params = {\"date\": date, \"jurisdiction\": \"AUS\"}\n        response = await self.make_request(\n            self.http_client,\n            \"GET\",\n            \"v1/racing/meetings\",\n            headers=headers,\n            params=params,\n        )\n        return response.json() if response else None\n\n    def _parse_races(self, raw_data: Optional[Dict[str, Any]]) -> List[Race]:\n        \"\"\"Parses the raw meetings data into a list of Race objects.\"\"\"\n        all_races = []\n        if not raw_data or not isinstance(raw_data.get(\"meetings\"), list):\n            self.logger.warning(\"No 'meetings' in RacingAndSports response or invalid format.\")\n            return all_races\n\n        for meeting in raw_data.get(\"meetings\", []):\n            if not isinstance(meeting, dict):\n                continue\n            for race_summary in meeting.get(\"races\", []):\n                if not isinstance(race_summary, dict):\n                    continue\n                try:\n                    if parsed_race := self._parse_ras_race(meeting, race_summary):\n                        all_races.append(parsed_race)\n                except (KeyError, TypeError, ValueError):\n                    self.logger.warning(\n                        \"Failed to parse RacingAndSports race, skipping\",\n                        meeting=meeting.get(\"venueName\"),\n                        race_id=race_summary.get(\"raceId\"),\n                        exc_info=True,\n                    )\n        return all_races\n\n    def _parse_ras_race(self, meeting: Dict[str, Any], race: Dict[str, Any]) -> Optional[Race]:\n        \"\"\"Parses a single race object from the API response.\"\"\"\n        race_id = race.get(\"raceId\")\n        start_time_str = race.get(\"startTime\")\n        race_number = race.get(\"raceNumber\")\n\n        if not all([race_id, start_time_str, race_number]):\n            return None\n\n        runners = [\n            Runner(\n                number=rd.get(\"runnerNumber\", 0),\n                name=rd.get(\"horseName\", \"Unknown\"),\n                scratched=rd.get(\"isScratched\", False),\n            )\n            for rd in race.get(\"runners\", [])\n            if isinstance(rd, dict) and rd.get(\"runnerNumber\")\n        ]\n\n        if not runners:\n            return None\n\n        try:\n            start_time = datetime.fromisoformat(start_time_str)\n        except (ValueError, TypeError):\n            self.logger.warning(\n                \"Invalid start time format for RacingAndSports race\",\n                start_time_str=start_time_str,\n                race_id=race_id,\n            )\n            return None\n\n        return Race(\n            id=f\"ras_{race_id}\",\n            venue=meeting.get(\"venueName\", \"Unknown Venue\"),\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n",
    "web_service/backend/adapters/tab_adapter.py": "# python_service/adapters/tab_adapter.py\nfrom typing import Any\nfrom typing import List\n\nfrom ..models import Race\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass TabAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for tab.com.au.\n    This adapter is a non-functional stub and has not been implemented.\n    \"\"\"\n\n    SOURCE_NAME = \"TAB\"\n    BASE_URL = \"https://www.tab.com.au\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"This is a stub and does not fetch any data.\"\"\"\n        self.logger.warning(\n            f\"{self.source_name} is a non-functional stub and has not been implemented. It will not fetch any data.\"\n        )\n        return None\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"This is a stub and does not parse any data.\"\"\"\n        return []\n",
    "web_service/backend/adapters/twinspires_adapter.py": "# python_service/adapters/twinspires_adapter.py\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\n\nfrom bs4 import BeautifulSoup\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom .base_adapter_v3 import BaseAdapterV3\n\n\nclass TwinSpiresAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for twinspires.com.\n    This is a placeholder for a full implementation using the discovered JSON API.\n    \"\"\"\n\n    SOURCE_NAME = \"TwinSpires\"\n    BASE_URL = \"https://www.twinspires.com\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL, config=config)\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"\n        [MODIFIED FOR OFFLINE DEVELOPMENT]\n        Reads HTML content from a local fixture file instead of making a live API call.\n        This is a temporary measure to allow development while the live API is blocking requests.\n        \"\"\"\n        # Read the local HTML fixture\n        try:\n            with open(\"tests/fixtures/twinspires_sample.html\", \"r\") as f:\n                html_content = f.read()\n        except FileNotFoundError:\n            self.logger.error(\"TwinSpires test fixture not found.\")\n            return None\n\n        # To maintain the data structure the parser expects, we will create a mock\n        # raw_data object that resembles the original API response, but includes\n        # the HTML content.\n        return {\n            \"html_content\": html_content,\n            \"mock_track_data\": {\"trackId\": \"cd\", \"trackName\": \"Churchill Downs\", \"raceType\": \"Thoroughbred\"},\n            \"mock_race_card\": {\"raceNumber\": 5, \"postTime\": \"2025-10-26T16:30:00Z\"},\n        }\n\n    def _parse_races(self, raw_data: Any) -> List[Dict[str, Any]]:\n        \"\"\"\n        [MODIFIED FOR OFFLINE DEVELOPMENT]\n        Parses race and runner data from the mock raw_data object, which now\n        includes the HTML content from the local fixture. Returns a list of dictionaries.\n        \"\"\"\n        if not raw_data or \"html_content\" not in raw_data:\n            return []\n\n        self.logger.info(\"Parsing TwinSpires data from local fixture.\")\n\n        html_content = raw_data[\"html_content\"]\n        track = raw_data[\"mock_track_data\"]\n        race_card = raw_data[\"mock_race_card\"]\n\n        # Parse the runners from the HTML content\n        runners = self._parse_runners_from_html(html_content)\n\n        try:\n            start_time = datetime.fromisoformat(race_card.get(\"postTime\").replace(\"Z\", \"+00:00\"))\n\n            race_dict = {\n                \"id\": f\"ts_{track.get('trackId')}_{race_card.get('raceNumber')}\",\n                \"venue\": track.get(\"trackName\"),\n                \"race_number\": race_card.get(\"raceNumber\"),\n                \"start_time\": start_time,\n                \"discipline\": track.get(\"raceType\", \"Unknown\"),\n                \"runners\": [runner.model_dump() for runner in runners],\n                \"source\": self.SOURCE_NAME,\n            }\n            return [race_dict]\n        except Exception as e:\n            self.logger.warning(\n                \"Failed to parse race card from mock data.\",\n                error=e,\n                exc_info=True,\n            )\n            return []\n\n    def _parse_runners_from_html(self, html_content: str) -> List[Runner]:\n        \"\"\"Parses runner data from a race card's HTML content.\"\"\"\n        runners = []\n        soup = BeautifulSoup(html_content, \"html.parser\")\n        runner_elements = soup.select(\"li.runner\")\n\n        for element in runner_elements:\n            try:\n                scratched = \"scratched\" in element.get(\"class\", [])\n\n                number_tag = element.select_one(\"span.runner-number\")\n                name_tag = element.select_one(\"span.runner-name\")\n                odds_tag = element.select_one(\"span.runner-odds\")\n\n                if not all([number_tag, name_tag, odds_tag]):\n                    continue\n\n                number = int(number_tag.text.strip())\n                name = name_tag.text.strip()\n                odds_str = odds_tag.text.strip()\n\n                odds = {}\n                if not scratched and odds_str not in [\"SCR\", \"\"]:\n                    win_odds = parse_odds_to_decimal(odds_str)\n                    if win_odds:\n                        odds[self.SOURCE_NAME] = OddsData(\n                            win=win_odds,\n                            source=self.SOURCE_NAME,\n                            last_updated=datetime.now(),\n                        )\n\n                runners.append(\n                    Runner(\n                        number=number,\n                        name=name,\n                        scratched=scratched,\n                        odds=odds,\n                    )\n                )\n            except (ValueError, TypeError) as e:\n                self.logger.warning(\"Failed to parse a runner, skipping.\", error=e, exc_info=True)\n                continue\n\n        return runners\n\n    async def get_races(self, date: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Orchestrates the fetching and parsing of race data for a given date.\n        This method will be called by the FortunaEngine.\n        \"\"\"\n        self.logger.info(f\"Getting races for {date} from {self.SOURCE_NAME}\")\n        raw_data = await self._fetch_data(date)\n        if raw_data:\n            return self._parse_races(raw_data)\n        return []\n",
    "web_service/backend/api.py": "# web_service/backend/api.py\n# Reconstructed by Jules to merge features from python_service with web_service structure.\n\nimport asyncio\nimport os\nimport sys\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\nfrom datetime import date\nfrom typing import List, Optional\n\nimport structlog\nfrom fastapi import APIRouter, Depends, FastAPI, HTTPException, Query, Request, WebSocket\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\nfrom slowapi.middleware import SlowAPIMiddleware\nfrom slowapi.util import get_remote_address\nfrom starlette.websockets import WebSocketDisconnect\n\n# Corrected imports for web_service.backend\nfrom .config import get_settings\nfrom .engine import OddsEngine\nfrom .health import router as health_router\nfrom .logging_config import configure_logging\nfrom .middleware.error_handler import UserFriendlyException, user_friendly_exception_handler, validation_exception_handler\nfrom .models import AggregatedResponse, QualifiedRacesResponse, Race\nfrom .security import verify_api_key\n\nlog = structlog.get_logger()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manages application startup and shutdown events.\"\"\"\n    configure_logging()\n    log.info(\"Lifespan: Startup sequence initiated.\")\n\n    settings = get_settings()\n    engine = OddsEngine(config=settings)\n    app.state.engine = engine\n\n    log.info(\"Lifespan: Engine initialized successfully. Startup complete.\")\n    yield\n    log.info(\"Lifespan: Shutdown sequence initiated.\")\n    if hasattr(app.state, \"engine\") and app.state.engine:\n        await app.state.engine.close()\n    log.info(\"Lifespan: Shutdown sequence complete.\")\n\n# --- FastAPI App Initialization ---\nrouter = APIRouter()\nlimiter = Limiter(key_func=get_remote_address)\napp = FastAPI(\n    title=\"Fortuna Faucet Web Service API\",\n    version=\"3.0\",\n    lifespan=lifespan,\n    docs_url=\"/api/docs\",\n    redoc_url=\"/api/redoc\",\n    openapi_url=\"/api/openapi.json\",\n)\n\n# Conditionally apply rate limiting middleware, disable in CI\n# The check is now more robust, looking for any truthy value.\nis_ci = os.environ.get(\"CI\", \"false\").lower() in (\"true\", \"1\", \"yes\")\nif not is_ci:\n    app.state.limiter = limiter\n    app.add_middleware(SlowAPIMiddleware)\n    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\nelse:\n    # In CI, we don't want rate limiting, so we provide a no-op limiter.\n    # The limiter instance is still required by endpoints even if not used.\n    log.info(\"CI environment detected. Rate limiting is disabled.\")\n    app.state.limiter = Limiter(key_func=get_remote_address, enabled=False)\napp.add_exception_handler(RequestValidationError, validation_exception_handler)\napp.add_exception_handler(UserFriendlyException, user_friendly_exception_handler)\nrouter.include_router(health_router)\n\n# Add CORS middleware for frontend development\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=get_settings().ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# --- Dependency Injection ---\ndef get_engine(request: Request) -> OddsEngine:\n    if not hasattr(request.app.state, \"engine\") or request.app.state.engine is None:\n        raise HTTPException(status_code=503, detail=\"The OddsEngine is not available.\")\n    return request.app.state.engine\n\n# --- API Endpoints (Restored and Adapted) ---\n\n@router.get(\"/races\", response_model=AggregatedResponse)\n@limiter.limit(\"30/minute\")\nasync def get_races(\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    source: Optional[str] = None,\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n):\n    \"\"\"Fetches all race data for a given date from all or a specific source.\"\"\"\n    if race_date is None:\n        race_date = date.today().strftime(\"%Y-%m-%d\")\n    return await engine.fetch_all_odds(race_date, source)\n\n@router.get(\"/races/qualified/tiny_field_trifecta\", response_model=QualifiedRacesResponse)\n@limiter.limit(\"120/minute\")\nasync def get_tiny_field_trifecta_races(\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n):\n    \"\"\"Fetches all race data and runs the tiny_field_trifecta analyzer to find qualified races.\"\"\"\n    if race_date is None:\n        race_date = date.today().strftime(\"%Y-%m-%d\")\n    response = await engine.fetch_all_odds(race_date)\n    races = [Race(**r) for r in response.get(\"races\", [])]\n\n    analyzer = engine.analyzer_engine.get_analyzer(\"tiny_field_trifecta\")\n    result = analyzer.qualify_races(races)\n\n    return QualifiedRacesResponse(qualified_races=result.get(\"races\", []), analysis_metadata=result.get(\"criteria\", {}))\n\n@router.get(\"/races/qualified/{analyzer_name}\", response_model=QualifiedRacesResponse)\n@limiter.limit(\"120/minute\")\nasync def get_qualified_races(\n    analyzer_name: str,\n    request: Request,\n    race_date: Optional[str] = Query(None, description=\"Date in YYYY-MM-DD format.\"),\n    engine: OddsEngine = Depends(get_engine),\n    _=Depends(verify_api_key),\n    # Example query parameters for an analyzer\n    max_field_size: int = Query(10, ge=3, le=20),\n    min_odds: float = Query(2.0, ge=1.0),\n):\n    \"\"\"Fetches all race data and runs a specific analyzer to find qualified races.\"\"\"\n    response = await engine.fetch_all_odds(race_date)\n    races = [Race(**r) for r in response.get(\"races\", [])]\n\n    try:\n        analyzer = engine.analyzer_engine.get_analyzer(analyzer_name, max_field_size=max_field_size, min_odds=min_odds)\n        result = analyzer.qualify_races(races)\n        return QualifiedRacesResponse(qualified_races=result.get(\"races\", []), analysis_metadata=result.get(\"criteria\", {}))\n    except ValueError:\n        raise HTTPException(status_code=404, detail=f\"Analyzer '{analyzer_name}' not found.\")\n\n\n# Add other endpoints as needed, following the pattern above.\n\napp.include_router(router, prefix=\"/api\")\n\n# Mount static files (frontend)\n# This logic ensures that the frontend is served both in development and in the frozen executable.\nstatic_dir = None\nif getattr(sys, 'frozen', False):\n    # Running in a PyInstaller bundle\n    static_dir = Path(sys.executable).parent / \"public\"\nelse:\n    # Running in a normal Python environment\n    static_dir = Path(__file__).parent.parent.joinpath(\"frontend\", \"public\")\n\nif static_dir and static_dir.exists():\n    app.mount(\"/\", StaticFiles(directory=static_dir, html=True), name=\"static\")\n\n    @app.middleware(\"http\")\n    async def spa_middleware(request: Request, call_next):\n        \"\"\"\n        Middleware to handle SPA routing. If a request is not for an API endpoint\n        and the file is not found, it serves index.html. This is crucial for\n        letting the frontend handle routing.\n        \"\"\"\n        response = await call_next(request)\n        # If a 404 is returned for a non-API, non-file path, serve the SPA index.\n        if response.status_code == 404 and not request.url.path.startswith(\"/api/\"):\n            # A simple check to avoid redirecting file requests (e.g. for .css, .js)\n            if \".\" not in request.url.path.split(\"/\")[-1]:\n                return FileResponse(static_dir / \"index.html\")\n        return response\nelse:\n    log.warning(f\"Static frontend directory not found at '{static_dir}'. The frontend will not be served.\")\n\n\n# --- Adapter Management Endpoints (v3.0.0) ---\n\nfrom typing import Dict, Any\n\nadapter_router = APIRouter()\n\n@adapter_router.get(\"/adapters/status\", response_model=List[Dict[str, Any]])\nasync def get_adapter_status_v3(\n    request: Request,\n    engine: OddsEngine = Depends(get_engine),\n):\n    \"\"\"\n    Get status of all adapters, including whether they require API keys.\n    This version is designed to be called by the adapter-aware script.\n    \"\"\"\n    try:\n        statuses = []\n        for name, adapter in engine.adapters.items():\n            statuses.append({\n                \"name\": name,\n                \"adapter_name\": name,\n                \"status\": \"active\",\n                \"enabled\": True,\n                \"requires_api_key\": _adapter_requires_key(adapter),\n                \"api_key_required\": _adapter_requires_key(adapter),\n            })\n        return statuses\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error fetching adapter status: {str(e)}\")\n\n@adapter_router.post(\"/adapters/disable\", response_model=Dict[str, Any])\nasync def disable_adapter(\n    payload: Dict[str, str],\n    request: Request,\n    engine: OddsEngine = Depends(get_engine),\n):\n    \"\"\"\n    Disable a specific adapter at runtime.\n    \"\"\"\n    adapter_name = payload.get(\"adapter_name\")\n    if not adapter_name:\n        raise HTTPException(status_code=400, detail=\"adapter_name is required\")\n\n    if adapter_name not in engine.adapters:\n        raise HTTPException(status_code=404, detail=f\"Adapter '{adapter_name}' not found\")\n\n    if not hasattr(engine, 'disabled_adapters'):\n        engine.disabled_adapters = set()\n    engine.disabled_adapters.add(adapter_name)\n\n    return {\"success\": True, \"message\": f\"Adapter '{adapter_name}' disabled\"}\n\ndef _adapter_requires_key(adapter) -> bool:\n    \"\"\"\n    Helper to determine if an adapter requires an API key.\n    Checks for common attributes and class name patterns.\n    \"\"\"\n    if not adapter or not hasattr(adapter, '__class__'):\n        return False\n\n    for attr in ['api_key_required', 'requires_api_key', 'requires_key']:\n        if hasattr(adapter, attr) and getattr(adapter, attr):\n            return True\n\n    key_indicators = ['betfair', 'tvg', 'equibase']\n    adapter_class_name = adapter.__class__.__name__.lower()\n    if any(indicator in adapter_class_name for indicator in key_indicators):\n        return True\n\n    return False\n\n# Include the new adapter router\nrouter.include_router(adapter_router)\n\n# Export app for Uvicorn\n__all__ = [\"app\"]\n",
    "web_service/backend/core/exceptions.py": "# python_service/core/exceptions.py\n\"\"\"\nCustom, application-specific exceptions for the Fortuna Faucet service.\n\nThis module defines a hierarchy of exception classes to provide standardized\nerror handling, particularly for the data adapter layer. Using these specific\nexceptions instead of generic ones allows for more precise error handling and\nclearer logging throughout the application.\n\"\"\"\n\n\nclass FortunaException(Exception):\n    \"\"\"Base class for all custom exceptions in this application.\"\"\"\n\n    pass\n\n\nclass AdapterError(FortunaException):\n    \"\"\"Base class for all adapter-related errors.\"\"\"\n\n    def __init__(self, adapter_name: str, message: str):\n        self.adapter_name = adapter_name\n        super().__init__(f\"[{adapter_name}] {message}\")\n\n\nclass AdapterRequestError(AdapterError):\n    \"\"\"Raised for general network or request-related issues.\"\"\"\n\n    pass\n\n\nclass AdapterHttpError(AdapterRequestError):\n    \"\"\"Raised for unsuccessful HTTP responses (e.g., 4xx or 5xx status codes).\"\"\"\n\n    def __init__(self, adapter_name: str, status_code: int, url: str):\n        self.status_code = status_code\n        self.url = url\n        message = f\"Received HTTP {status_code} from {url}\"\n        super().__init__(adapter_name, message)\n\n\nclass AdapterAuthError(AdapterHttpError):\n    \"\"\"Raised specifically for HTTP 401/403 errors, indicating an auth failure.\"\"\"\n\n    pass\n\n\nclass AdapterRateLimitError(AdapterHttpError):\n    \"\"\"Raised specifically for HTTP 429 errors, indicating a rate limit has been hit.\"\"\"\n\n    pass\n\n\nclass AdapterTimeoutError(AdapterRequestError):\n    \"\"\"Raised when a request to an external API times out.\"\"\"\n\n    pass\n\n\nclass AdapterConnectionError(AdapterRequestError):\n    \"\"\"Raised for DNS lookup failures or refused connections.\"\"\"\n\n    pass\n\n\nclass AdapterConfigError(AdapterError):\n    \"\"\"Raised when an adapter is missing necessary configuration (e.g., an API key).\"\"\"\n\n    pass\n\n\nclass AdapterParsingError(AdapterError):\n    \"\"\"Raised when an adapter fails to parse the response from an API.\"\"\"\n\n    pass\n",
    "web_service/backend/fortuna_watchman.py": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: The Watchman (v2 - Score-Aware)\n# ==============================================================================\n# This is the master orchestrator for the Fortuna Faucet project.\n# It executes the full, end-to-end handicapping strategy autonomously.\n# ==============================================================================\n\nimport asyncio\nfrom datetime import datetime\nfrom datetime import timezone\nfrom typing import List\n\nimport structlog\n\nfrom .analyzer import AnalyzerEngine\nfrom .config import get_settings\nfrom .engine import OddsEngine\nfrom .etl import run_etl_for_yesterday\nfrom .models import Race\n\nlog = structlog.get_logger(__name__)\n\n\nclass Watchman:\n    \"\"\"Orchestrates the daily operation of the Fortuna Faucet.\"\"\"\n\n    def __init__(self):\n        self.settings = get_settings()\n        self.odds_engine = OddsEngine(config=self.settings)\n        self.analyzer_engine = AnalyzerEngine()\n\n    async def get_initial_targets(self) -> List[Race]:\n        \"\"\"Uses the OddsEngine and AnalyzerEngine to get the day's ranked targets.\"\"\"\n        log.info(\"Watchman: Acquiring and ranking initial targets for the day...\")\n        today_str = datetime.now(timezone.utc).strftime(\"%Y-%m-%d\")\n        try:\n            background_tasks = set()  # Create a dummy set for background tasks\n            aggregated_data = await self.odds_engine.fetch_all_odds(today_str, background_tasks)\n            all_races = aggregated_data.get(\"races\", [])\n            if not all_races:\n                log.warning(\"Watchman: No races returned from OddsEngine.\")\n                return []\n\n            analyzer = self.analyzer_engine.get_analyzer(\"trifecta\")\n            qualified_races_result = analyzer.qualify_races(all_races)\n            qualified_races_list = qualified_races_result.get(\"races\", [])\n            log.info(\n                \"Watchman: Initial target acquisition and ranking complete\",\n                target_count=len(qualified_races_list),\n            )\n\n            # Log the top targets for better observability\n            for race in qualified_races_list[:5]:\n                log.info(\n                    \"Top Target Found\",\n                    score=race.qualification_score,\n                    venue=race.venue,\n                    race_number=race.race_number,\n                    post_time=race.start_time.isoformat(),\n                )\n            return qualified_races_list\n        except Exception as e:\n            log.error(\"Watchman: Failed to get initial targets\", error=str(e), exc_info=True)\n            return []\n\n    async def run_tactical_monitoring(self, targets: List[Race]):\n        \"\"\"Uses the LiveOddsMonitor on each target as it approaches post time.\"\"\"\n        log.info(\"Watchman: Entering tactical monitoring loop.\")\n        # active_targets = list(targets)\n\n        # from python_service.adapters.betfair_adapter import BetfairAdapter\n        # async with LiveOddsMonitor(betfair_adapter=BetfairAdapter(config=self.settings)) as live_monitor:\n        #     async with httpx.AsyncClient() as client:\n        #         while active_targets:\n        #             now = datetime.now(timezone.utc)\n\n        #             # Find races that are within the 5-minute monitoring window\n        #             races_to_monitor = [\n        #                 r\n        #                 for r in active_targets\n        #                 if r.start_time.replace(tzinfo=timezone.utc) > now\n        #                 and r.start_time.replace(tzinfo=timezone.utc)\n        #                 < now + timedelta(minutes=5)\n        #             ]\n\n        #             if races_to_monitor:\n        #                 for race in races_to_monitor:\n        #                     log.info(\"Watchman: Deploying Live Monitor for approaching target\",\n        #                         race_id=race.id,\n        #                         venue=race.venue,\n        #                         score=race.qualification_score\n        #                     )\n        #                     updated_race = await live_monitor.monitor_race(race, client)\n        #                     log.info(\"Watchman: Live monitoring complete for race\", race_id=updated_race.id)\n        #                     # Remove from target list to prevent re-monitoring\n        #                     active_targets = [t for t in active_targets if t.id != race.id]\n\n        #             if not active_targets:\n        #                 break # Exit loop if all targets are processed\n\n        #             await asyncio.sleep(30) # Check for upcoming races every 30 seconds\n\n        log.info(\"Watchman: All targets for the day have been monitored. Mission complete.\")\n\n    async def execute_daily_protocol(self):\n        \"\"\"The main, end-to-end orchestration method.\"\"\"\n        log.info(\"--- Fortuna Watchman Daily Protocol: ACTIVE ---\")\n        try:\n            initial_targets = await self.get_initial_targets()\n            if initial_targets:\n                await self.run_tactical_monitoring(initial_targets)\n            else:\n                log.info(\"Watchman: No initial targets found. Shutting down for the day.\")\n        finally:\n            await self.odds_engine.close()\n\n        # Run ETL for yesterday's data after all other operations are complete\n        try:\n            log.info(\"Starting daily ETL process for Scribe's Archives...\")\n            run_etl_for_yesterday()\n            log.info(\"Daily ETL process completed successfully.\")\n        except Exception:\n            log.error(\"Daily ETL process failed.\", exc_info=True)\n        log.info(\"--- Fortuna Watchman Daily Protocol: COMPLETE ---\")\n\n\nasync def main():\n    from .logging_config import configure_logging\n\n    configure_logging()\n    watchman = Watchman()\n    await watchman.execute_daily_protocol()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
    "web_service/backend/logging_config.py": "# python_service/logging_config.py\nimport logging\nimport sys\n\nimport structlog\n\n\ndef configure_logging(log_level: str = \"INFO\"):\n    \"\"\"Configures structlog for structured, JSON-formatted logging.\"\"\"\n    logging.basicConfig(\n        level=log_level,\n        format=\"%(message)s\",\n        stream=sys.stdout,\n    )\n\n    # Keep the processor chain simple for maximum reliability in bundled executables.\n    # More complex processors like StackInfoRenderer can cause issues in\n    # constrained environments.\n    structlog.configure(\n        processors=[\n            structlog.stdlib.filter_by_level,\n            structlog.stdlib.add_log_level,\n            structlog.processors.TimeStamper(fmt=\"iso\"),\n            structlog.processors.format_exc_info,\n            structlog.processors.JSONRenderer(),\n        ],\n        context_class=dict,\n        logger_factory=structlog.stdlib.LoggerFactory(),\n        wrapper_class=structlog.stdlib.BoundLogger,\n        cache_logger_on_first_use=True,\n    )\n",
    "web_service/backend/models.py": "# python_service/models.py\n\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Annotated\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nfrom pydantic import BaseModel\nfrom pydantic import ConfigDict\nfrom pydantic import Field\nfrom pydantic import WrapSerializer\n\n\ndef decimal_serializer(value: Decimal, handler: Callable[[Decimal], Any]) -> Any:\n    \"\"\"Custom serializer for Decimal to float conversion.\"\"\"\n    return float(value)\n\n\nJsonDecimal = Annotated[Decimal, WrapSerializer(decimal_serializer, when_used=\"json\")]\n\n\n# --- Configuration for Aliases (BUG #4 Fix) ---\nclass FortunaBaseModel(BaseModel):\n    model_config = ConfigDict(\n        populate_by_name=True,\n        arbitrary_types_allowed=True,\n    )\n\n\n# --- Core Data Models ---\nclass OddsData(FortunaBaseModel):\n    win: Optional[JsonDecimal] = None\n    place: Optional[JsonDecimal] = None\n    show: Optional[JsonDecimal] = None\n    source: str\n    last_updated: datetime\n\n\nclass Runner(FortunaBaseModel):\n    id: Optional[str] = None\n    name: str\n    number: Optional[int] = Field(None, alias=\"saddleClothNumber\")\n    scratched: bool = False\n    odds: Dict[str, OddsData] = {}\n    jockey: Optional[str] = None\n    trainer: Optional[str] = None\n\n\nclass Race(FortunaBaseModel):\n    id: str\n    venue: str\n    race_number: int = Field(..., alias=\"raceNumber\")\n    start_time: datetime = Field(..., alias=\"startTime\")\n    runners: List[Runner]\n    source: str\n    field_size: Optional[int] = None\n    qualification_score: Optional[float] = Field(None, alias=\"qualificationScore\")\n    favorite: Optional[Runner] = None\n    race_name: Optional[str] = None\n    distance: Optional[str] = None\n    is_error_placeholder: bool = Field(False, alias=\"isErrorPlaceholder\")\n    error_message: Optional[str] = Field(None, alias=\"errorMessage\")\n\n\nclass SourceInfo(FortunaBaseModel):\n    name: str\n    status: str\n    races_fetched: int = Field(..., alias=\"racesFetched\")\n    fetch_duration: float = Field(..., alias=\"fetchDuration\")\n    error_message: Optional[str] = Field(None, alias=\"errorMessage\")\n    attempted_url: Optional[str] = Field(None, alias=\"attemptedUrl\")\n\n\nclass AdapterError(FortunaBaseModel):\n    adapter_name: str = Field(..., alias=\"adapterName\")\n    error_message: str = Field(..., alias=\"errorMessage\")\n    attempted_url: Optional[str] = Field(None, alias=\"attemptedUrl\")\n\n\nclass AggregatedResponse(FortunaBaseModel):\n    races: List[Race]\n    errors: List[AdapterError]\n    source_info: List[SourceInfo] = Field(..., alias=\"sourceInfo\")\n\n\nclass QualifiedRacesResponse(FortunaBaseModel):\n    criteria: Dict[str, Any]\n    races: List[Race]\n\n\nclass TipsheetRace(FortunaBaseModel):\n    race_id: str = Field(..., alias=\"raceId\")\n    track_name: str = Field(..., alias=\"trackName\")\n    race_number: int = Field(..., alias=\"raceNumber\")\n    post_time: str = Field(..., alias=\"postTime\")\n    score: float\n    factors: Any  # JSON string stored as Any\n\n\nclass ManualParseRequest(FortunaBaseModel):\n    adapter_name: str\n    html_content: str = Field(..., max_length=5_000_000)  # ~5MB limit\n",
    "web_service/backend/monolith.py": "\"\"\"\nFortuna Monolith - Single executable frontend + backend\nProduction-grade with enhanced error handling, user-friendly startup, and better logging\n\nIMPORTANT: Uses WinForms instead of CEF for Python 3.10 compatibility\n(CEFPython3 v66.0 doesn't support Python 3.10.11)\n\"\"\"\nimport sys\nimport os\nfrom pathlib import Path\nimport logging\nimport io\nimport threading\nimport time\nimport json\nfrom contextlib import suppress\n\n# ====================================================================\n# CONSTANTS & CONFIGURATION\n# ====================================================================\nAPP_NAME = \"Fortuna Faucet\"\nAPP_VERSION = \"1.0.0\"\nAPI_HOST = \"127.0.0.1\"\nAPI_PORT = 8000\nBACKEND_STARTUP_TIMEOUT = 10\nHEALTH_CHECK_ATTEMPTS = 10\nHEALTH_CHECK_INTERVAL = 1\n\n# ====================================================================\n# LOGGING SETUP (BEFORE ANYTHING ELSE)\n# ====================================================================\ndef _get_log_file() -> Path:\n    \"\"\"Get log file path (works in both dev and frozen modes)\"\"\"\n    if getattr(sys, \"frozen\", False):\n        log_dir = Path(os.environ.get(\"TEMP\", \".\"))\n    else:\n        log_dir = Path(\".\")\n    return log_dir / \"fortuna-monolith.log\"\n\ndef _force_utf8_stream(stream):\n    \"\"\"Ensure stream uses UTF-8 encoding\"\"\"\n    if hasattr(stream, \"reconfigure\"):\n        with suppress(Exception):\n            stream.reconfigure(encoding=\"utf-8\", errors=\"replace\")\n            return stream\n\n    buffer = getattr(stream, \"buffer\", None)\n    if buffer is None:\n        return stream\n\n    with suppress(Exception):\n        return io.TextIOWrapper(buffer, encoding=\"utf-8\", errors=\"replace\")\n\n    return stream\n\ndef setup_logging():\n    \"\"\"Configure logging to both file and console\"\"\"\n    log_file = _get_log_file()\n\n    # Force UTF-8 on stdout/stderr\n    sys.stdout = _force_utf8_stream(sys.stdout)\n    sys.stderr = _force_utf8_stream(sys.stderr)\n\n    # Logging handlers\n    file_handler = logging.FileHandler(log_file, mode=\"w\", encoding=\"utf-8\")\n    console_handler = logging.StreamHandler(sys.stdout)\n\n    # Format with timestamps\n    formatter = logging.Formatter(\n        \"[%(levelname)-8s] %(asctime)s - %(message)s\",\n        datefmt=\"%H:%M:%S\"\n    )\n    file_handler.setFormatter(formatter)\n    console_handler.setFormatter(formatter)\n\n    # Setup root logger\n    logging.basicConfig(\n        level=logging.INFO,\n        handlers=[file_handler, console_handler],\n    )\n\n    logger = logging.getLogger(\"fortuna\")\n    return logger\n\nlogger = setup_logging()\n\n# Banner\nlogger.info(\"=\" * 70)\nlogger.info(f\"{APP_NAME} v{APP_VERSION} - Starting up\")\nlogger.info(\"=\" * 70)\nlogger.info(f\"Mode: {'Frozen EXE' if getattr(sys, 'frozen', False) else 'Development'}\")\nlogger.info(f\"Python: {sys.version.split()[0]}\")\n\n# ====================================================================\n# UI HELPERS (DEFINE BEFORE IMPORTS)\n# ====================================================================\ndef show_error_dialog(title: str, message: str):\n    \"\"\"Show error dialog (fallback if no GUI available)\"\"\"\n    try:\n        import tkinter as tk\n        from tkinter import messagebox\n        root = tk.Tk()\n        root.withdraw()\n        messagebox.showerror(title, message)\n    except:\n        # If tkinter fails, just log it\n        logger.error(f\"{title}: {message}\")\n\n# ====================================================================\n# FORCE PYINSTALLER TO INCLUDE DEPENDENCIES (TOP-LEVEL IMPORTS)\n# ====================================================================\nif False:  # Never executes, but PyInstaller sees the imports\n    import fastapi\n    import uvicorn\n    import webview\n    import pydantic\n    import starlette\n    import requests\n    from fastapi import FastAPI\n    from fastapi.staticfiles import StaticFiles\n    from fastapi.middleware.cors import CORSMiddleware\n    from fastapi.responses import FileResponse, JSONResponse\n\n# ====================================================================\n# IMPORT DEPENDENCIES WITH FRIENDLY ERROR HANDLING\n# ====================================================================\ndef _import_dependencies():\n    \"\"\"Import all required modules with descriptive error messages\"\"\"\n    try:\n        global uvicorn, webview, FastAPI, StaticFiles, CORSMiddleware, FileResponse, JSONResponse, requests\n\n        import requests\n        import uvicorn\n        import webview\n        from fastapi import FastAPI\n        from fastapi.staticfiles import StaticFiles\n        from fastapi.middleware.cors import CORSMiddleware\n        from fastapi.responses import FileResponse, JSONResponse\n\n        logger.info(\"OK - All dependencies loaded successfully\")\n        return True\n    except ImportError as e:\n        logger.critical(f\"FAILED - Missing dependency: {e}\")\n        show_error_dialog(\n            \"Missing Dependencies\",\n            f\"Could not load required library:\\n{str(e)}\\n\\n\"\n            \"Ensure all packages in requirements.txt are installed:\\n\"\n            \"pip install -r web_service/backend/requirements.txt\"\n        )\n        return False\n    except Exception as e:\n        logger.critical(f\"FAILED - Unexpected import error: {e}\", exc_info=True)\n        show_error_dialog(\n            \"Startup Error\",\n            f\"Unexpected error during startup:\\n{str(e)}\\n\\n\"\n            f\"Check the log file for details:\\n{_get_log_file()}\"\n        )\n        return False\n\nif not _import_dependencies():\n    sys.exit(1)\n\n# ====================================================================\n# UTILITY FUNCTIONS\n# ====================================================================\ndef get_resource_path(relative_path: str) -> Path:\n    \"\"\"Get absolute path to bundled resources\"\"\"\n    if getattr(sys, \"frozen\", False):\n        base_path = Path(sys._MEIPASS)\n    else:\n        base_path = Path(__file__).parent.parent.parent\n\n    full_path = base_path / relative_path\n    return full_path\n\n# ====================================================================\n# API CREATION\n# ====================================================================\ndef create_backend_api():\n    \"\"\"Create FastAPI instance with fallback support\"\"\"\n    api = FastAPI(title=\"Fortuna Backend\")\n\n    @api.get(\"/health\")\n    async def health():\n        \"\"\"Health check endpoint\"\"\"\n        return {\n            \"status\": \"ok\",\n            \"service\": \"fortuna-monolith\",\n            \"version\": APP_VERSION\n        }\n\n    try:\n        logger.info(\"Attempting to load full backend API...\")\n        from web_service.backend import api as backend_api\n\n        # Copy routes from full backend\n        for route in backend_api.app.routes:\n            api.routes.append(route)\n\n        logger.info(f\"OK - Full backend API loaded ({len(api.routes)} routes)\")\n        return api\n\n    except (ImportError, AttributeError) as e:\n        logger.warning(f\"Full backend import failed: {e}\")\n        logger.info(\"Running in minimal mode (basic endpoints only)\")\n\n        # Provide stub endpoints\n        @api.get(\"/races\")\n        async def get_races():\n            return {\n                \"status\": \"error\",\n                \"message\": \"Full API not available\",\n                \"sample\": [{\"id\": 1, \"name\": \"Example Race\", \"status\": \"pending\"}]\n            }\n\n        return api\n\n    except Exception as e:\n        logger.error(f\"Unexpected error loading backend: {e}\", exc_info=True)\n        return api\n\n# ====================================================================\n# APP CREATION\n# ====================================================================\ndef create_app():\n    \"\"\"Create main FastAPI application\"\"\"\n    logger.info(\"Creating FastAPI application...\")\n    app = FastAPI(title=\"Fortuna Monolith\")\n\n    # CORS for local development\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    logger.info(\"OK - CORS middleware configured\")\n\n    # Mount backend API\n    logger.info(\"Mounting backend API at /api...\")\n    backend = create_backend_api()\n    app.mount(\"/api\", backend, name=\"backend\")\n\n    # Setup frontend serving\n    frontend_path = get_resource_path(\"frontend_dist\")\n    index_file = frontend_path / \"index.html\"\n\n    logger.info(f\"Frontend path: {frontend_path}\")\n\n    if not frontend_path.exists():\n        logger.error(\"Frontend directory not found - app will run without UI\")\n\n        @app.get(\"/\")\n        async def fallback():\n            return JSONResponse(\n                {\"message\": \"Frontend not available\", \"api\": \"/api/health\"},\n                status_code=503\n            )\n        return app\n\n    # Mount static files\n    logger.info(\"Configuring static file serving...\")\n\n    # Mount Next.js build output\n    next_dir = frontend_path / \"_next\"\n    if next_dir.exists():\n        app.mount(\"/_next\", StaticFiles(directory=str(next_dir)), name=\"next\")\n        logger.info(\"OK - Static assets mounted\")\n\n    public_dir = frontend_path / \"public\"\n    if public_dir.exists():\n        app.mount(\"/public\", StaticFiles(directory=str(public_dir)), name=\"public\")\n\n    # SPA routing - catch all unmapped routes and serve index.html\n    @app.get(\"/{full_path:path}\")\n    async def serve_spa(full_path: str):\n        # Skip API routes\n        if full_path.startswith(\"api/\"):\n            return JSONResponse({\"error\": \"Not found\"}, status_code=404)\n\n        # Try exact file\n        file_path = frontend_path / full_path\n        try:\n            if file_path.is_file() and file_path.is_relative_to(frontend_path):\n                return FileResponse(file_path)\n        except (ValueError, RuntimeError):\n            pass\n\n        # Try with .html extension\n        html_path = frontend_path / f\"{full_path}.html\"\n        try:\n            if html_path.is_file() and html_path.is_relative_to(frontend_path):\n                return FileResponse(html_path)\n        except (ValueError, RuntimeError):\n            pass\n\n        # SPA fallback to index\n        if index_file.exists():\n            return FileResponse(index_file)\n\n        return JSONResponse({\"error\": \"Not found\"}, status_code=404)\n\n    logger.info(\"OK - SPA routing configured\")\n    return app\n\n# ====================================================================\n# BACKEND SERVER\n# ====================================================================\ndef run_backend():\n    \"\"\"Run Uvicorn server\"\"\"\n    try:\n        logger.info(\"-\" * 70)\n        logger.info(\"STARTING BACKEND SERVER\")\n        logger.info(f\"API: http://{API_HOST}:{API_PORT}\")\n        logger.info(\"-\" * 70)\n\n        app = create_app()\n\n        # Run Uvicorn\n        uvicorn.run(\n            app,\n            host=API_HOST,\n            port=API_PORT,\n            log_level=\"warning\",\n            access_log=False,\n        )\n    except OSError as e:\n        logger.critical(f\"Port {API_PORT} is already in use: {e}\")\n        raise\n    except Exception as e:\n        logger.critical(f\"Backend error: {e}\", exc_info=True)\n        raise\n\n# ====================================================================\n# HEALTH CHECKS\n# ====================================================================\ndef check_backend_health(max_attempts: int = HEALTH_CHECK_ATTEMPTS) -> bool:\n    \"\"\"Check if backend is responding\"\"\"\n    logger.info(\"Testing backend health...\")\n\n    for attempt in range(1, max_attempts + 1):\n        try:\n            response = requests.get(\n                f\"http://{API_HOST}:{API_PORT}/api/health\",\n                timeout=2\n            )\n\n            if response.status_code == 200:\n                data = response.json()\n                logger.info(f\"OK - Backend responding: {data}\")\n                return True\n\n        except requests.ConnectionError:\n            if attempt < max_attempts:\n                logger.debug(f\"Attempt {attempt}/{max_attempts} - waiting...\")\n                time.sleep(HEALTH_CHECK_INTERVAL)\n        except Exception as e:\n            logger.warning(f\"Health check error: {e}\")\n\n    logger.warning(f\"Backend did not respond after {max_attempts} attempts\")\n    return False\n\n# ====================================================================\n# MAIN APPLICATION\n# ====================================================================\ndef main():\n    \"\"\"Main entry point\"\"\"\n    try:\n        logger.info(\"-\" * 70)\n        logger.info(f\"STARTING {APP_NAME}\")\n        logger.info(\"-\" * 70)\n\n        # Start backend in background\n        logger.info(\"Starting backend server...\")\n        backend_thread = threading.Thread(target=run_backend, daemon=True)\n        backend_thread.start()\n        logger.info(\"OK - Backend thread started\")\n\n        # Wait for backend to initialize\n        logger.info(f\"Waiting for backend to be ready (max {BACKEND_STARTUP_TIMEOUT}s)...\")\n        time.sleep(2)\n\n        # Health check\n        backend_ready = check_backend_health()\n\n        if not backend_ready:\n            logger.warning(\"Backend not responding - launching UI anyway\")\n\n        # Launch UI\n        logger.info(\"-\" * 70)\n        logger.info(\"LAUNCHING USER INTERFACE\")\n        logger.info(\"-\" * 70)\n\n        try:\n            # Use WinForms GUI (default on Windows, compatible with Python 3.10)\n            # CEF is not used here to avoid Python version compatibility issues\n            webview.create_window(\n                title=APP_NAME,\n                url=f\"http://{API_HOST}:{API_PORT}\",\n                width=1400,\n                height=900,\n                resizable=True,\n                min_size=(800, 600),\n                background_color=\"#1a1a1a\",\n            )\n\n            logger.info(\"Starting webview event loop...\")\n            # Don't specify gui='cef' - let pywebview auto-detect WinForms\n            webview.start(debug=False)\n\n        except Exception as e:\n            logger.error(f\"Webview error: {e}\", exc_info=True)\n            # Fall back to browser message\n            logger.info(f\"Open http://{API_HOST}:{API_PORT} in your browser\")\n            input(\"Press ENTER to exit...\")\n\n        logger.info(f\"{APP_NAME} closed normally\")\n\n    except KeyboardInterrupt:\n        logger.info(\"Application interrupted by user\")\n    except Exception as e:\n        logger.critical(f\"Fatal error: {e}\", exc_info=True)\n        show_error_dialog(\n            f\"{APP_NAME} Error\",\n            f\"Application failed to start:\\n{str(e)}\\n\\n\"\n            f\"Please check the log file at:\\n{_get_log_file()}\"\n        )\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n",
    "web_service/backend/requirements-x86.txt": "#\n# This file is a modified version of requirements.txt for x86 architecture compatibility.\n# Some packages are pinned to older versions that provide x86 wheels.\n#\naiosqlite==0.17.0\n    # via -r web_service/backend/requirements.in\naltgraph==0.17.4\n    # via pyinstaller\nannotated-types==0.7.0\n    # via pydantic\nanyio==3.7.1\n    # via\n    #   httpx\n    #   starlette\n    #   watchfiles\nasync-timeout==5.0.1\n    # via redis\nbeautifulsoup4==4.12.3\n    # via -r web_service/backend/requirements.in\nblack==24.4.2\n    # via -r web_service/backend/requirements.in\nbuild==1.2.1\n    # via pip-tools\ncertifi==2024.7.4\n    # via\n    #   -r web_service/backend/requirements.in\n    #   httpcore\n    #   httpx\n    #   requests\ncffi==1.16.0\n    # via cryptography\ncharset-normalizer==3.3.2\n    # via requests\nclick==8.1.7\n    # via\n    #   black\n    #   pip-tools\n    #   rich-toolkit\n    #   typer\n    #   uvicorn\ncryptography==42.0.8\n    # via\n    #   -r web_service/backend/requirements.in\n    #   secretstorage\ndeprecated==1.2.14\n    # via limits\ndnspython==2.7.0\n    # via email-validator\nemail-validator==2.3.0\n    # via fastapi\nexceptiongroup==1.3.1\n    # via\n    #   anyio\n    #   pytest\nfastapi==0.111.0\n    # via -r web_service/backend/requirements.in\nfastapi-cli==0.0.20\n    # via fastapi\ngreenlet==1.1.2  # x86 PINNED\n    # via\n    #   -r web_service/backend/requirements.in\n    #   sqlalchemy\nh11==0.14.0\n    # via\n    #   httpcore\n    #   uvicorn\nh2==4.1.0\n    # via httpx\nhpack==4.0.0\n    # via h2\nhttpcore==1.0.5\n    # via httpx\nhttptools==0.7.1\n    # via uvicorn\nhttpx[http2]==0.27.0\n    # via\n    #   -r web_service/backend/requirements.in\n    #   fastapi\nhyperframe==6.0.1\n    # via h2\nidna==3.7\n    # via\n    #   anyio\n    #   email-validator\n    #   httpx\n    #   requests\nimportlib-metadata==8.7.1\n    # via\n    #   build\n    #   keyring\n    #   pyinstaller\n    #   pyinstaller-hooks-contrib\niniconfig==2.0.0\n    # via pytest\njaraco-classes==3.4.0\n    # via keyring\njaraco-context==4.3.0\n    # via keyring\njaraco-functools==4.3.0\n    # via keyring\njeepney==0.8.0\n    # via\n    #   keyring\n    #   secretstorage\njinja2==3.1.6\n    # via fastapi\nkeyring==25.2.1\n    # via -r web_service/backend/requirements.in\nlimits==3.14.1\n    # via slowapi\nmarkdown-it-py==3.0.0\n    # via rich\nmarkupsafe==3.0.3\n    # via jinja2\nmdurl==0.1.2\n    # via markdown-it-py\nmore-itertools==10.3.0\n    # via\n    #   jaraco-classes\n    #   jaraco-functools\nmypy-extensions==1.0.0\n    # via black\nnumpy==1.23.5  # x86 PINNED\n    # via\n    #   -r web_service/backend/requirements.in\n    #   pandas\n    #   scipy\norjson==3.11.5\n    # via fastapi\npackaging==24.1\n    # via\n    #   black\n    #   build\n    #   limits\n    #   pyinstaller\n    #   pyinstaller-hooks-contrib\n    #   pytest\npandas==1.5.3  # x86 PINNED\n    # via -r web_service/backend/requirements.in\npathspec==0.12.1\n    # via black\npip-tools==7.4.1\n    # via -r web_service/backend/requirements.in\nplatformdirs==4.2.2\n    # via black\npluggy==1.5.0\n    # via pytest\npsutil==5.9.8\n    # via -r web_service/backend/requirements.in\npsycopg2-binary==2.9.9\n    # via -r web_service/backend/requirements.in\npycparser==2.22\n    # via cffi\npydantic==2.8.2\n    # via\n    #   fastapi\n    #   pydantic-settings\npydantic-core==2.20.1\n    # via pydantic\npydantic-settings==2.3.4\n    # via -r web_service/backend/requirements.in\npygments==2.18.0\n    # via rich\npyinstaller==6.5.0\n    # via -r web_service/backend/requirements.in\npyinstaller-hooks-contrib==2024.6\n    # via pyinstaller\npyproject-hooks==1.1.0\n    # via\n    #   build\n    #   pip-tools\npytest==8.2.2\n    # via\n    #   -r web_service/backend/requirements.in\n    #   pytest-asyncio\npytest-asyncio==0.23.7\n    # via -r web_service/backend/requirements.in\npython-dateutil==2.9.0.post0\n    # via pandas\npython-dotenv==1.0.1\n    # via\n    #   pydantic-settings\n    #   uvicorn\npython-multipart==0.0.20\n    # via fastapi\npytz==2024.1\n    # via pandas\npyyaml==6.0.3\n    # via uvicorn\nredis==5.0.6\n    # via -r web_service/backend/requirements.in\nrequests==2.32.5\n    # via -r web_service/backend/requirements.in\nrich==14.2.0\n    # via\n    #   rich-toolkit\n    #   typer\nrich-toolkit==0.17.1\n    # via fastapi-cli\nscipy==1.10.1  # x86 PINNED\n    # via -r web_service/backend/requirements.in\nsecretstorage==3.3.3\n    # via keyring\nselectolax==0.4.0\n    # via -r web_service/backend/requirements.in\nshellingham==1.5.4\n    # via typer\nsix==1.16.0\n    # via python-dateutil\nslowapi==0.1.9\n    # via -r web_service/backend/requirements.in\nsniffio==1.3.1\n    # via\n    #   anyio\n    #   httpx\nsoupsieve==2.5\n    # via beautifulsoup4\nsqlalchemy==1.4.46  # x86 PINNED\n    # via -r web_service/backend/requirements.in\nstarlette==0.37.2\n    # via fastapi\nstructlog==24.2.0\n    # via -r web_service/backend/requirements.in\ntenacity==8.2.3\n    # via -r web_service/backend/requirements.in\ntomli==2.3.0\n    # via\n    #   black\n    #   build\n    #   fastapi-cli\n    #   pip-tools\n    #   pytest\ntyper==0.21.0\n    # via fastapi-cli\ntyping-extensions==4.12.2\n    # via\n    #   aiosqlite\n    #   black\n    #   exceptiongroup\n    #   fastapi\n    #   limits\n    #   pydantic\n    #   pydantic-core\n    #   rich-toolkit\n    #   starlette\n    #   typer\n    #   uvicorn\nujson==5.11.0\n    # via fastapi\nurllib3==2.6.2\n    # via\n    #   -r web_service/backend/requirements.in\n    #   requests\nuvicorn==0.30.1\n    # via\n    #   -r web_service/backend/requirements.in\n    #   fastapi\n    #   fastapi-cli\nhttptools==0.7.1\n    # via uvicorn\nwebsockets==15.0.1\n    # via uvicorn\nwatchfiles==1.1.1\n    # via uvicorn\nwebsockets==15.0.1\n    # via uvicorn\nwheel==0.43.0\n    # via\n    #   -r web_service/backend/requirements.in\n    #   pip-tools\nwrapt==1.16.0\n    # via deprecated\nzipp==3.23.0\n    # via importlib-metadata\n",
    "web_service/backend/service_entry.py": "import win32serviceutil\nimport win32service\nimport win32event\nimport servicemanager\nimport socket\nimport sys\nimport os\nimport uvicorn\nimport multiprocessing\nimport threading\nfrom pathlib import Path\n\n# --- Resilient Import Block ---\n# This block is designed to robustly locate the `main` module and its `app` object,\n# whether running from source, as a PyInstaller bundle, or as a Windows Service.\n\nimport asyncio\n\ndef _bootstrap_path():\n    \"\"\"\n    Ensures the application's root directories are on the Python path.\n    This is critical for PyInstaller's frozen executables to find modules.\n    \"\"\"\n    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):\n        # We are running in a PyInstaller bundle.\n        # The `_MEIPASS` directory is the root of our bundled files.\n        # In our `--onedir` build, this is where `main.py`'s content is.\n        sys.path.insert(0, sys._MEIPASS)\n    else:\n        # We are running from source.\n        # The entry point is in `web_service/backend`, so we need to add the project root.\n        project_root = str(Path(__file__).parent.parent.parent)\n        sys.path.insert(0, project_root)\n\n_bootstrap_path()\n\ntry:\n    # This is the most direct import path and should work when the CWD\n    # is correctly set to the directory containing the executable.\n    print(f\"[service_entry] Attempting direct import of 'main:app'...\")\n    from main import app\n    print(f\"[service_entry] Direct import successful.\")\nexcept (ImportError, ModuleNotFoundError) as e:\n    print(f\"[service_entry] Direct import failed: {e}. Attempting namespace import...\")\n    try:\n        # This is a fallback for environments where the `web_service` namespace is preserved.\n        from web_service.backend.main import app\n        print(f\"[service_entry] Namespace import successful.\")\n    except (ImportError, ModuleNotFoundError) as e2:\n        print(f\"[service_entry] All import attempts failed: {e2}. Cannot start service.\")\n        sys.exit(1) # Exit if the app cannot be imported, to prevent service start failure.\n\nclass FortunaSvc(win32serviceutil.ServiceFramework):\n    _svc_name_ = 'FortunaWebService'\n    _svc_display_name_ = 'Fortuna Faucet Backend Service'\n    _svc_description_ = 'Data aggregation and analysis engine.'\n\n    def __init__(self, args):\n        win32serviceutil.ServiceFramework.__init__(self, args)\n        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)\n        self.server = None\n        self.server_thread = None\n\n    def SvcStop(self):\n        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\n        win32event.SetEvent(self.hWaitStop)\n        if self.server:\n            self.server.should_exit = True\n\n    def SvcDoRun(self):\n        # When running as a Windows Service, the default working directory is System32,\n        # which can cause issues with relative paths. This fix changes the working\n        # directory to the location of the executable.\n        if getattr(sys, 'frozen', False):\n            os.chdir(os.path.dirname(sys.executable))\n            # \u2622\ufe0f CRITICAL FIX for Windows Services running asyncio \u2622\ufe0f\n            # This policy prevents the notorious \"NotImplementedError\" when uvicorn\n            # tries to create a subprocess in a non-interactive service environment.\n            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n\n        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE,\n                              servicemanager.PYS_SERVICE_STARTED,\n                              (self._svc_name_, ''))\n\n        config = uvicorn.Config(app, host='127.0.0.1', port=8102, log_config=None, reload=False)\n        self.server = uvicorn.Server(config)\n\n        # Run the server in a separate thread\n        self.server_thread = threading.Thread(target=self.server.run)\n        self.server_thread.start()\n\n        # Wait for the stop event\n        win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)\n\n        # Wait for the server thread to finish\n        self.server_thread.join()\n\nif __name__ == '__main__':\n    multiprocessing.freeze_support()\n    if len(sys.argv) == 1:\n        servicemanager.Initialize()\n        servicemanager.PrepareToHostSingle(FortunaSvc)\n        servicemanager.StartServiceCtrlDispatcher()\n    else:\n        win32serviceutil.HandleCommandLine(FortunaSvc)\n",
    "web_service/backend/utils/odds.py": "# Centralized odds parsing utility, created by Operation: The A+ Trifecta\nfrom decimal import Decimal\nfrom decimal import InvalidOperation\nfrom typing import Optional\nfrom typing import Union\n\n\ndef parse_odds_to_decimal(odds: Union[str, int, float, None]) -> Optional[Decimal]:\n    \"\"\"\n    Parse various odds formats to Decimal for precise financial calculations.\n    Handles fractional, decimal, and special cases ('EVS', 'SP', etc.).\n    Returns None for unparseable or invalid values.\n    \"\"\"\n    if odds is None:\n        return None\n\n    if isinstance(odds, (int, float)):\n        return Decimal(str(odds))\n\n    odds_str = str(odds).strip().upper()\n\n    SPECIAL_CASES = {\n        \"EVS\": Decimal(\"2.0\"),\n        \"EVENS\": Decimal(\"2.0\"),\n        \"SP\": None,\n        \"SCRATCHED\": None,\n        \"SCR\": None,\n        \"\": None,\n    }\n\n    if odds_str in SPECIAL_CASES:\n        return SPECIAL_CASES[odds_str]\n\n    if \"/\" in odds_str:\n        try:\n            parts = odds_str.split(\"/\")\n            if len(parts) != 2:\n                return None\n            num, den = map(Decimal, parts)\n            if den <= 0:\n                return None\n            return Decimal(\"1.0\") + (num / den)\n        except (ValueError, InvalidOperation):\n            return None\n\n    try:\n        return Decimal(odds_str)\n    except (ValueError, InvalidOperation):\n        return None\n",
    "web_service/frontend/app/components/AdapterStatusPanel.tsx": "// web_platform/frontend/src/components/AdapterStatusPanel.tsx\n'use client';\n\nimport React from 'react';\nimport { SourceInfo } from '../types/racing';\n\ninterface AdapterStatusPanelProps {\n  adapter: SourceInfo;\n  onFetchRaces: (sourceName: string) => void;\n}\n\nexport const AdapterStatusPanel: React.FC<AdapterStatusPanelProps> = ({ adapter, onFetchRaces }) => {\n  const isConfigured = adapter.status !== 'CONFIG_ERROR';\n\n  return (\n    <div className={`p-4 rounded-lg border ${isConfigured ? 'bg-slate-800 border-slate-700' : 'bg-yellow-900/20 border-yellow-700/50'}`}>\n      <div className=\"flex justify-between items-center\">\n        <h3 className=\"font-bold text-lg text-white\">{adapter.name}</h3>\n        <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${isConfigured ? 'bg-green-500/20 text-green-300' : 'bg-yellow-500/20 text-yellow-300'}`}>\n          {isConfigured ? 'Ready' : 'Not Configured'}\n        </span>\n      </div>\n      <div className=\"mt-4 flex gap-2\">\n        <button\n          onClick={() => onFetchRaces(adapter.name)}\n          disabled={!isConfigured}\n          className=\"flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-slate-700 disabled:text-slate-400 disabled:cursor-not-allowed\"\n        >\n          Automatic Load\n        </button>\n        <button\n          disabled\n          className=\"flex-1 px-4 py-2 bg-slate-700 text-slate-400 rounded cursor-not-allowed\"\n        >\n          Manual Entry (Coming Soon)\n        </button>\n      </div>\n    </div>\n  );\n};\n",
    "web_service/frontend/app/components/ManualOverridePanel.tsx": "// web_platform/frontend/src/components/ManualOverridePanel.tsx\nimport React, { useState } from 'react';\nimport { Race } from '../types/racing';\n\ninterface ManualOverridePanelProps {\n  adapterName: string;\n  attemptedUrl: string;\n  apiKey: string | null;\n  onParseSuccess: (adapterName: string, parsedRaces: Race[]) => void;\n}\n\nconst ManualOverridePanel: React.FC<ManualOverridePanelProps> = ({\n  adapterName,\n  attemptedUrl,\n  apiKey,\n  onParseSuccess,\n}) => {\n  const [showPanel, setShowPanel] = useState(true);\n  const [htmlContent, setHtmlContent] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleSubmit = async () => {\n    if (!htmlContent.trim()) {\n      setError('HTML content cannot be empty.');\n      return;\n    }\n    if (!apiKey) {\n      setError('API key is not available. Cannot submit.');\n      return;\n    }\n\n    setIsSubmitting(true);\n    setError(null);\n\n    try {\n      const response = await fetch('/api/races/parse-manual', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': apiKey,\n        },\n        body: JSON.stringify({\n          adapter_name: adapterName,\n          html_content: htmlContent,\n        }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to parse HTML.');\n      }\n\n      const parsedRaces: Race[] = await response.json();\n      onParseSuccess(adapterName, parsedRaces);\n      setShowPanel(false); // Hide panel on success\n\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred.';\n      setError(errorMessage);\n      console.error('Manual parse submission failed:', err);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n\n  if (!showPanel) {\n    return null;\n  }\n\n  return (\n    <div className=\"bg-red-900 bg-opacity-50 border border-red-700 p-4 rounded-lg shadow-lg mb-4\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h3 className=\"font-bold text-red-300\">Data Fetch Failed: {adapterName}</h3>\n          <p className=\"text-sm text-red-400\">\n            The application failed to automatically retrieve data from:{' '}\n            <a href={attemptedUrl} target=\"_blank\" rel=\"noopener noreferrer\" className=\"underline hover:text-red-200\">\n              {attemptedUrl}\n            </a>\n          </p>\n        </div>\n        <button onClick={() => setShowPanel(false)} className=\"text-red-400 hover:text-red-200 text-2xl\">&times;</button>\n      </div>\n      <div className=\"mt-4\">\n        <p className=\"text-sm text-red-300 mb-2\">\n          <strong>To resolve this:</strong>\n          <ol className=\"list-decimal list-inside pl-4\">\n            <li>Click the link above to open the page in a new tab.</li>\n            <li>Right-click on the page and select \"View Page Source\".</li>\n            <li>Copy the entire HTML source code.</li>\n            <li>Paste the code into the text area below and click \"Submit Manual Data\".</li>\n          </ol>\n        </p>\n        <textarea\n          className=\"w-full h-24 p-2 bg-gray-900 border border-gray-700 rounded text-gray-300 font-mono text-xs\"\n          placeholder={`Paste HTML source for ${adapterName} here...`}\n          value={htmlContent}\n          onChange={(e) => setHtmlContent(e.target.value)}\n          disabled={isSubmitting}\n        />\n        {error && <p className=\"text-red-400 text-sm mt-2\">{error}</p>}\n        <div className=\"mt-2 flex gap-2\">\n          <button\n            onClick={handleSubmit}\n            className=\"px-3 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm disabled:bg-blue-800 disabled:cursor-not-allowed\"\n            disabled={isSubmitting}\n          >\n            {isSubmitting ? 'Submitting...' : 'Submit Manual Data'}\n          </button>\n          <button\n            onClick={() => setShowPanel(false)}\n            className=\"px-3 py-1.5 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm\"\n          >\n            Skip for Now\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ManualOverridePanel;\n",
    "web_service/frontend/app/components/SettingsPage.tsx": "// src/components/SettingsPage.tsx\n'use client';\n\nimport React, { useState, useEffect } from 'react';\n\nexport function SettingsPage() {\n  const [apiKey, setApiKey] = useState('');\n  const [betfairAppKey, setBetfairAppKey] = useState('');\n  const [betfairUsername, setBetfairUsername] = useState('');\n  const [betfairPassword, setBetfairPassword] = useState('');\n\n  useEffect(() => {\n    // Fetch the current API key when the component mounts\n    const fetchApiKey = async () => {\n      if (window.electronAPI?.getApiKey) {\n        const key = await window.electronAPI.getApiKey();\n        if (key) {\n          setApiKey(key);\n        }\n      }\n    };\n    fetchApiKey();\n  }, []);\n\n  const handleGenerateApiKey = async () => {\n    if (window.electronAPI?.generateApiKey) {\n      const newKey = await window.electronAPI.generateApiKey();\n      setApiKey(newKey);\n    }\n  };\n\n  const handleSaveSettings = async () => {\n    if (window.electronAPI?.saveApiKey && window.electronAPI?.saveBetfairCredentials) {\n      await window.electronAPI.saveApiKey(apiKey);\n      await window.electronAPI.saveBetfairCredentials({\n        appKey: betfairAppKey,\n        username: betfairUsername,\n        password: betfairPassword,\n      });\n      alert('Settings saved successfully!');\n    }\n  };\n\n  return (\n    <div className=\"bg-slate-800 p-8 rounded-lg border border-slate-700 text-white max-w-2xl mx-auto\">\n      <h2 className=\"text-3xl font-bold text-white mb-6\">Application Settings</h2>\n\n      <div className=\"space-y-8\">\n        <div>\n          <h3 className=\"text-xl font-semibold text-slate-300 mb-2\">API Key</h3>\n          <p className=\"text-sm text-slate-400 mb-3\">This key is required for the dashboard to communicate with the backend service.</p>\n          <div className=\"flex items-center space-x-2\">\n            <input\n              type=\"text\"\n              readOnly\n              value={apiKey}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 font-mono text-sm\"\n            />\n            <button\n              onClick={handleGenerateApiKey}\n              className=\"px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition-colors font-semibold\"\n            >\n              Generate New Key\n            </button>\n          </div>\n        </div>\n\n        <div>\n          <h3 className=\"text-xl font-semibold text-slate-300 mb-2\">Betfair Credentials (Optional)</h3>\n           <p className=\"text-sm text-slate-400 mb-3\">Required for adapters that use the Betfair Exchange API.</p>\n          <div className=\"space-y-3\">\n            <input\n              type=\"password\"\n              placeholder=\"App Key\"\n              value={betfairAppKey}\n              onChange={(e) => setBetfairAppKey(e.target.value)}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 placeholder-slate-500\"\n            />\n            <input\n              type=\"text\"\n              placeholder=\"Username\"\n              value={betfairUsername}\n              onChange={(e) => setBetfairUsername(e.target.value)}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 placeholder-slate-500\"\n            />\n            <input\n              type=\"password\"\n              placeholder=\"Password\"\n              value={betfairPassword}\n              onChange={(e) => setBetfairPassword(e.target.value)}\n              className=\"w-full p-2 bg-slate-700 rounded border border-slate-600 placeholder-slate-500\"\n            />\n          </div>\n        </div>\n\n        <div className=\"flex justify-end pt-6 border-t border-slate-700\">\n          <button\n            onClick={handleSaveSettings}\n            className=\"px-8 py-3 bg-green-600 hover:bg-green-700 rounded font-bold text-lg transition-colors\"\n          >\n            Save All Settings\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
    "web_service/frontend/app/hooks/useRealTimeRaces.ts": "import { useState, useEffect } from 'react';\nimport { io, Socket } from 'socket.io-client';\nimport { Race } from '../types/racing';\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';\n\nexport function useRealTimeRaces() {\n  const [races, setRaces] = useState<Race[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n\n  useEffect(() => {\n    const socket: Socket = io(API_URL);\n\n    socket.on('connect', () => setIsConnected(true));\n    socket.on('disconnect', () => setIsConnected(false));\n\n    socket.on('races_update', (data: { races: Race[] }) => {\n      if (data && Array.isArray(data.races)) {\n        setRaces(data.races);\n      }\n    });\n\n    // Cleanup on component unmount\n    return () => {\n      socket.disconnect();\n    };\n  }, []);\n\n  return { races, isConnected };\n}",
    "web_service/frontend/app/types/electron.d.ts": "// web_platform/frontend/src/types/electron.d.ts\n\n/**\n * This declaration file extends the global Window interface to include the\n * 'electronAPI' object exposed by the preload script. This provides\n * TypeScript with type information for the functions we're using for IPC.\n */\nexport {};\n\ndeclare global {\n  interface Window {\n    electronAPI?: {\n      /**\n       * Asynchronously fetches the secure API key from the main process.\n       * @returns {Promise<string|null>} A promise that resolves with the API key or null if not found.\n       */\n      getApiKey: () => Promise<string | null>;\n      /**\n       * Registers a callback for backend status updates from the main process.\n       * @param callback The function to execute. Receives an object with state and logs.\n       * @returns A function to unsubscribe the listener.\n       */\n      onBackendStatusUpdate: (callback: (status: { state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }) => void) => () => void;\n\n      /**\n       * Sends a command to the main process to restart the backend executable.\n       */\n      restartBackend: () => void;\n\n      /**\n       * Asynchronously fetches the current backend status from the main process.\n       * @returns {Promise<{ state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }>}\n       */\n      getBackendStatus: () => Promise<{ state: 'starting' | 'running' | 'error' | 'stopped'; logs: string[] }>;\n      generateApiKey: () => Promise<string>;\n      saveApiKey: (apiKey: string) => Promise<{ success: boolean }>;\n      saveBetfairCredentials: (credentials: { appKey: string; username: string; password: string }) => Promise<{ success: boolean }>;\n      getApiPort: () => Promise<number | null>;\n    };\n  }\n}\n",
    "web_service/frontend/next.config.mjs": "/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',  // Critical for static HTML export\n  distDir: 'out',\n  trailingSlash: true,\n  images: {\n    unoptimized: true  // Required for static export\n  },\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*',\n        destination: 'http://127.0.0.1:8000/api/:path*',\n      },\n    ]\n  },\n};\n\nexport default nextConfig;\n",
    "web_service/frontend/postcss.config.js": "module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};",
    "wix/product.wxs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\"\n     xmlns:util=\"http://schemas.microsoft.com/wix/UtilExtension\">\n\n  <Product\n    Id=\"*\"\n    Name=\"Fortuna Faucet - Racing Analysis Engine\"\n    Language=\"1033\"\n    Version=\"$(var.Version)\"\n    Manufacturer=\"Mason J0 Studios\"\n    UpgradeCode=\"12345678-1234-1234-1234-123456789012\">\n\n    <Package\n      InstallerVersion=\"200\"\n      Compressed=\"yes\"\n      InstallScope=\"perMachine\"\n      Platform=\"x64\"\n      Description=\"Horse racing analysis platform\"\n      Comments=\"Professional-grade installer\"/>\n\n    <Media Id=\"1\" Cabinet=\"fortuna.cab\" EmbedCab=\"yes\"/>\n\n    <!-- Directory Structure -->\n    <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n      <Directory Id=\"ProgramFiles64Folder\">\n        <Directory Id=\"INSTALLFOLDER\" Name=\"Fortuna Faucet\">\n        </Directory>\n      </Directory>\n      <Directory Id=\"ProgramMenuFolder\">\n        <Directory Id=\"ApplicationProgramsFolder\" Name=\"Fortuna Faucet\"/>\n      </Directory>\n    </Directory>\n\n    <!-- Environment Variable -->\n    <ComponentGroup Id=\"EnvironmentComponentGroup\" Directory=\"INSTALLFOLDER\">\n      <Component Id=\"FortunaPortEnvironmentVar\" Guid=\"*\">\n        <Environment Id=\"FortunaPort\" Name=\"FORTUNA_PORT\" Value=\"8000\" Permanent=\"no\" Action=\"set\" System=\"yes\" />\n        <RegistryValue Root=\"HKLM\" Key=\"Software\\Fortuna Faucet\" Name=\"Path\" Type=\"string\" Value=\"[INSTALLFOLDER]\" KeyPath=\"yes\" />\n      </Component>\n    </ComponentGroup>\n\n    <!-- Features -->\n    <!-- Service Installation -->\n    <ComponentGroup Id=\"ServiceComponentGroup\" Directory=\"INSTALLFOLDER\">\n        <Component Id=\"FortunaBackendService\" Guid=\"*\">\n            <File Id=\"fortuna-backend.exe\" Source=\"$(var.BackendPath)\" KeyPath=\"yes\" />\n            <ServiceInstall\n                Id=\"FortunaServiceInstall\"\n                Type=\"ownProcess\"\n                Name=\"Fortuna\"\n                DisplayName=\"Fortuna Faucet Backend\"\n                Description=\"Data aggregation and analysis engine for horse racing.\"\n                Start=\"auto\"\n                Account=\"LocalSystem\"\n                ErrorControl=\"normal\" />\n            <ServiceControl Id=\"StartFortunaService\" Start=\"install\" Stop=\"uninstall\" Remove=\"uninstall\" Name=\"Fortuna\" Wait=\"no\" />\n        </Component>\n    </ComponentGroup>\n\n    <Feature Id=\"ProductFeature\" Title=\"Fortuna Faucet\" Level=\"1\">\n        <ComponentGroupRef Id=\"BackendFileGroup\"/>\n        <ComponentGroupRef Id=\"FrontendFileGroup\"/>\n        <ComponentGroupRef Id=\"ShortcutsComponentGroup\"/>\n        <ComponentGroupRef Id=\"EnvironmentComponentGroup\"/>\n        <ComponentGroupRef Id=\"ServiceComponentGroup\"/>\n    </Feature>\n\n    <!-- Shortcuts -->\n    <ComponentGroup Id=\"ShortcutsComponentGroup\" Directory=\"ApplicationProgramsFolder\">\n      <Component Id=\"ApplicationShortcuts\" Guid=\"*\">\n          <util:InternetShortcut Id=\"DashboardShortcut\" Name=\"Fortuna Faucet Dashboard\" Target=\"http://localhost:3000\"/>\n          <Shortcut Id=\"UninstallShortcut\" Name=\"Uninstall Fortuna Faucet\" Description=\"Remove this application\" Target=\"[SystemFolder]msiexec.exe\" Arguments=\"/x [ProductCode]\" Advertise=\"no\"/>\n          <RemoveFolder Id=\"ApplicationProgramsFolder\" On=\"uninstall\"/>\n          <RegistryValue Root=\"HKCU\" Key=\"Software\\Fortuna Faucet\" Name=\"Installed\" Type=\"integer\" Value=\"1\" KeyPath=\"yes\"/>\n      </Component>\n    </ComponentGroup>\n\n    <!-- UI -->\n    <UI>\n      <UIRef Id=\"WixUI_CustomInstallDir\" />\n    </UI>\n    <UIRef Id=\"WixUI_Common\" />\n    <Property Id=\"WIXUI_INSTALLDIR\" Value=\"INSTALLFOLDER\" />\n    <WixVariable Id=\"WixUILicenseRtf\" Value=\"electron\\assets\\license.rtf\"/>\n    <WixVariable Id=\"WixUIBannerBmp\" Value=\"electron\\assets\\banner.bmp\"/>\n    <WixVariable Id=\"WixUIDialogBmp\" Value=\"electron\\assets\\dialog.bmp\"/>\n\n    <Condition Message=\"Windows 7 or later (64-bit) is required\">\n      <![CDATA[Installed OR (VersionNT64 >= 601)]]>\n    </Condition>\n\n  </Product>\n</Wix>\n"
}